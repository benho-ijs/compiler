declare module "typescript" {
    /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

declare namespace ts {
    const versionMajorMinor = "5.0";
    /** The version of the TypeScript compiler release */
    const version: string;
    /**
     * Type of objects whose values are all of the same type.
     * The `in` and `for-in` operators can *not* be safely used,
     * since `Object.prototype` may be modified by outside code.
     */
    interface MapLike<T> {
        [index: string]: T;
    }
    interface SortedReadonlyArray<T> extends ReadonlyArray<T> {
        " __sortedArrayBrand": any;
    }
    interface SortedArray<T> extends Array<T> {
        " __sortedArrayBrand": any;
    }
    type Path = string & {
        __pathBrand: any;
    };
    interface TextRange {
        pos: number;
        end: number;
    }
    interface ReadonlyTextRange {
        readonly pos: number;
        readonly end: number;
    }
    enum SyntaxKind {
        Unknown = 0,
        EndOfFileToken = 1,
        SingleLineCommentTrivia = 2,
        MultiLineCommentTrivia = 3,
        NewLineTrivia = 4,
        WhitespaceTrivia = 5,
        ShebangTrivia = 6,
        ConflictMarkerTrivia = 7,
        NumericLiteral = 8,
        BigIntLiteral = 9,
        StringLiteral = 10,
        JsxText = 11,
        JsxTextAllWhiteSpaces = 12,
        RegularExpressionLiteral = 13,
        NoSubstitutionTemplateLiteral = 14,
        TemplateHead = 15,
        TemplateMiddle = 16,
        TemplateTail = 17,
        OpenBraceToken = 18,
        CloseBraceToken = 19,
        OpenParenToken = 20,
        CloseParenToken = 21,
        OpenBracketToken = 22,
        CloseBracketToken = 23,
        DotToken = 24,
        DotDotDotToken = 25,
        SemicolonToken = 26,
        CommaToken = 27,
        QuestionDotToken = 28,
        LessThanToken = 29,
        LessThanSlashToken = 30,
        GreaterThanToken = 31,
        LessThanEqualsToken = 32,
        GreaterThanEqualsToken = 33,
        EqualsEqualsToken = 34,
        ExclamationEqualsToken = 35,
        EqualsEqualsEqualsToken = 36,
        ExclamationEqualsEqualsToken = 37,
        EqualsGreaterThanToken = 38,
        PlusToken = 39,
        MinusToken = 40,
        AsteriskToken = 41,
        AsteriskAsteriskToken = 42,
        SlashToken = 43,
        PercentToken = 44,
        PlusPlusToken = 45,
        MinusMinusToken = 46,
        LessThanLessThanToken = 47,
        GreaterThanGreaterThanToken = 48,
        GreaterThanGreaterThanGreaterThanToken = 49,
        AmpersandToken = 50,
        BarToken = 51,
        CaretToken = 52,
        ExclamationToken = 53,
        TildeToken = 54,
        AmpersandAmpersandToken = 55,
        BarBarToken = 56,
        QuestionToken = 57,
        ColonToken = 58,
        AtToken = 59,
        QuestionQuestionToken = 60,
        /** Only the JSDoc scanner produces BacktickToken. The normal scanner produces NoSubstitutionTemplateLiteral and related kinds. */
        BacktickToken = 61,
        /** Only the JSDoc scanner produces HashToken. The normal scanner produces PrivateIdentifier. */
        HashToken = 62,
        EqualsToken = 63,
        PlusEqualsToken = 64,
        MinusEqualsToken = 65,
        AsteriskEqualsToken = 66,
        AsteriskAsteriskEqualsToken = 67,
        SlashEqualsToken = 68,
        PercentEqualsToken = 69,
        LessThanLessThanEqualsToken = 70,
        GreaterThanGreaterThanEqualsToken = 71,
        GreaterThanGreaterThanGreaterThanEqualsToken = 72,
        AmpersandEqualsToken = 73,
        BarEqualsToken = 74,
        BarBarEqualsToken = 75,
        AmpersandAmpersandEqualsToken = 76,
        QuestionQuestionEqualsToken = 77,
        CaretEqualsToken = 78,
        Identifier = 79,
        PrivateIdentifier = 80,
        BreakKeyword = 81,
        CaseKeyword = 82,
        CatchKeyword = 83,
        ClassKeyword = 84,
        ConstKeyword = 85,
        ContinueKeyword = 86,
        DebuggerKeyword = 87,
        DefaultKeyword = 88,
        DeleteKeyword = 89,
        DoKeyword = 90,
        ElseKeyword = 91,
        EnumKeyword = 92,
        ExportKeyword = 93,
        ExtendsKeyword = 94,
        FalseKeyword = 95,
        FinallyKeyword = 96,
        ForKeyword = 97,
        FunctionKeyword = 98,
        IfKeyword = 99,
        ImportKeyword = 100,
        InKeyword = 101,
        InstanceOfKeyword = 102,
        NewKeyword = 103,
        NullKeyword = 104,
        ReturnKeyword = 105,
        SuperKeyword = 106,
        SwitchKeyword = 107,
        ThisKeyword = 108,
        ThrowKeyword = 109,
        TrueKeyword = 110,
        TryKeyword = 111,
        TypeOfKeyword = 112,
        VarKeyword = 113,
        VoidKeyword = 114,
        WhileKeyword = 115,
        WithKeyword = 116,
        ImplementsKeyword = 117,
        InterfaceKeyword = 118,
        LetKeyword = 119,
        PackageKeyword = 120,
        PrivateKeyword = 121,
        ProtectedKeyword = 122,
        PublicKeyword = 123,
        StaticKeyword = 124,
        YieldKeyword = 125,
        AbstractKeyword = 126,
        AccessorKeyword = 127,
        AsKeyword = 128,
        AssertsKeyword = 129,
        AssertKeyword = 130,
        AnyKeyword = 131,
        AsyncKeyword = 132,
        AwaitKeyword = 133,
        BooleanKeyword = 134,
        ConstructorKeyword = 135,
        DeclareKeyword = 136,
        GetKeyword = 137,
        InferKeyword = 138,
        IntrinsicKeyword = 139,
        IsKeyword = 140,
        KeyOfKeyword = 141,
        ModuleKeyword = 142,
        NamespaceKeyword = 143,
        NeverKeyword = 144,
        OutKeyword = 145,
        ReadonlyKeyword = 146,
        RequireKeyword = 147,
        NumberKeyword = 148,
        ObjectKeyword = 149,
        SatisfiesKeyword = 150,
        SetKeyword = 151,
        StringKeyword = 152,
        SymbolKeyword = 153,
        TypeKeyword = 154,
        UndefinedKeyword = 155,
        UniqueKeyword = 156,
        UnknownKeyword = 157,
        FromKeyword = 158,
        GlobalKeyword = 159,
        BigIntKeyword = 160,
        OverrideKeyword = 161,
        OfKeyword = 162,
        QualifiedName = 163,
        ComputedPropertyName = 164,
        TypeParameter = 165,
        Parameter = 166,
        Decorator = 167,
        PropertySignature = 168,
        PropertyDeclaration = 169,
        MethodSignature = 170,
        MethodDeclaration = 171,
        ClassStaticBlockDeclaration = 172,
        Constructor = 173,
        GetAccessor = 174,
        SetAccessor = 175,
        CallSignature = 176,
        ConstructSignature = 177,
        IndexSignature = 178,
        TypePredicate = 179,
        TypeReference = 180,
        FunctionType = 181,
        ConstructorType = 182,
        TypeQuery = 183,
        TypeLiteral = 184,
        ArrayType = 185,
        TupleType = 186,
        OptionalType = 187,
        RestType = 188,
        UnionType = 189,
        IntersectionType = 190,
        ConditionalType = 191,
        InferType = 192,
        ParenthesizedType = 193,
        ThisType = 194,
        TypeOperator = 195,
        IndexedAccessType = 196,
        MappedType = 197,
        LiteralType = 198,
        NamedTupleMember = 199,
        TemplateLiteralType = 200,
        TemplateLiteralTypeSpan = 201,
        ImportType = 202,
        ObjectBindingPattern = 203,
        ArrayBindingPattern = 204,
        BindingElement = 205,
        ArrayLiteralExpression = 206,
        ObjectLiteralExpression = 207,
        PropertyAccessExpression = 208,
        ElementAccessExpression = 209,
        CallExpression = 210,
        NewExpression = 211,
        TaggedTemplateExpression = 212,
        TypeAssertionExpression = 213,
        ParenthesizedExpression = 214,
        FunctionExpression = 215,
        ArrowFunction = 216,
        DeleteExpression = 217,
        TypeOfExpression = 218,
        VoidExpression = 219,
        AwaitExpression = 220,
        PrefixUnaryExpression = 221,
        PostfixUnaryExpression = 222,
        BinaryExpression = 223,
        ConditionalExpression = 224,
        TemplateExpression = 225,
        YieldExpression = 226,
        SpreadElement = 227,
        ClassExpression = 228,
        OmittedExpression = 229,
        ExpressionWithTypeArguments = 230,
        AsExpression = 231,
        NonNullExpression = 232,
        MetaProperty = 233,
        SyntheticExpression = 234,
        SatisfiesExpression = 235,
        TemplateSpan = 236,
        SemicolonClassElement = 237,
        Block = 238,
        EmptyStatement = 239,
        VariableStatement = 240,
        ExpressionStatement = 241,
        IfStatement = 242,
        DoStatement = 243,
        WhileStatement = 244,
        ForStatement = 245,
        ForInStatement = 246,
        ForOfStatement = 247,
        ContinueStatement = 248,
        BreakStatement = 249,
        ReturnStatement = 250,
        WithStatement = 251,
        SwitchStatement = 252,
        LabeledStatement = 253,
        ThrowStatement = 254,
        TryStatement = 255,
        DebuggerStatement = 256,
        VariableDeclaration = 257,
        VariableDeclarationList = 258,
        FunctionDeclaration = 259,
        ClassDeclaration = 260,
        InterfaceDeclaration = 261,
        TypeAliasDeclaration = 262,
        EnumDeclaration = 263,
        ModuleDeclaration = 264,
        ModuleBlock = 265,
        CaseBlock = 266,
        NamespaceExportDeclaration = 267,
        ImportEqualsDeclaration = 268,
        ImportDeclaration = 269,
        ImportClause = 270,
        NamespaceImport = 271,
        NamedImports = 272,
        ImportSpecifier = 273,
        ExportAssignment = 274,
        ExportDeclaration = 275,
        NamedExports = 276,
        NamespaceExport = 277,
        ExportSpecifier = 278,
        MissingDeclaration = 279,
        ExternalModuleReference = 280,
        JsxElement = 281,
        JsxSelfClosingElement = 282,
        JsxOpeningElement = 283,
        JsxClosingElement = 284,
        JsxFragment = 285,
        JsxOpeningFragment = 286,
        JsxClosingFragment = 287,
        JsxAttribute = 288,
        JsxAttributes = 289,
        JsxSpreadAttribute = 290,
        JsxExpression = 291,
        CaseClause = 292,
        DefaultClause = 293,
        HeritageClause = 294,
        CatchClause = 295,
        AssertClause = 296,
        AssertEntry = 297,
        ImportTypeAssertionContainer = 298,
        PropertyAssignment = 299,
        ShorthandPropertyAssignment = 300,
        SpreadAssignment = 301,
        EnumMember = 302,
        /** @deprecated */ UnparsedPrologue = 303,
        /** @deprecated */ UnparsedPrepend = 304,
        /** @deprecated */ UnparsedText = 305,
        /** @deprecated */ UnparsedInternalText = 306,
        /** @deprecated */ UnparsedSyntheticReference = 307,
        SourceFile = 308,
        Bundle = 309,
        /** @deprecated */ UnparsedSource = 310,
        /** @deprecated */ InputFiles = 311,
        JSDocTypeExpression = 312,
        JSDocNameReference = 313,
        JSDocMemberName = 314,
        JSDocAllType = 315,
        JSDocUnknownType = 316,
        JSDocNullableType = 317,
        JSDocNonNullableType = 318,
        JSDocOptionalType = 319,
        JSDocFunctionType = 320,
        JSDocVariadicType = 321,
        JSDocNamepathType = 322,
        JSDoc = 323,
        /** @deprecated Use SyntaxKind.JSDoc */
        JSDocComment = 323,
        JSDocText = 324,
        JSDocTypeLiteral = 325,
        JSDocSignature = 326,
        JSDocLink = 327,
        JSDocLinkCode = 328,
        JSDocLinkPlain = 329,
        JSDocTag = 330,
        JSDocAugmentsTag = 331,
        JSDocImplementsTag = 332,
        JSDocAuthorTag = 333,
        JSDocDeprecatedTag = 334,
        JSDocClassTag = 335,
        JSDocPublicTag = 336,
        JSDocPrivateTag = 337,
        JSDocProtectedTag = 338,
        JSDocReadonlyTag = 339,
        JSDocOverrideTag = 340,
        JSDocCallbackTag = 341,
        JSDocOverloadTag = 342,
        JSDocEnumTag = 343,
        JSDocParameterTag = 344,
        JSDocReturnTag = 345,
        JSDocThisTag = 346,
        JSDocTypeTag = 347,
        JSDocTemplateTag = 348,
        JSDocTypedefTag = 349,
        JSDocSeeTag = 350,
        JSDocPropertyTag = 351,
        JSDocThrowsTag = 352,
        JSDocSatisfiesTag = 353,
        SyntaxList = 354,
        NotEmittedStatement = 355,
        PartiallyEmittedExpression = 356,
        CommaListExpression = 357,
        MergeDeclarationMarker = 358,
        EndOfDeclarationMarker = 359,
        SyntheticReferenceExpression = 360,
        Count = 361,
        FirstAssignment = 63,
        LastAssignment = 78,
        FirstCompoundAssignment = 64,
        LastCompoundAssignment = 78,
        FirstReservedWord = 81,
        LastReservedWord = 116,
        FirstKeyword = 81,
        LastKeyword = 162,
        FirstFutureReservedWord = 117,
        LastFutureReservedWord = 125,
        FirstTypeNode = 179,
        LastTypeNode = 202,
        FirstPunctuation = 18,
        LastPunctuation = 78,
        FirstToken = 0,
        LastToken = 162,
        FirstTriviaToken = 2,
        LastTriviaToken = 7,
        FirstLiteralToken = 8,
        LastLiteralToken = 14,
        FirstTemplateToken = 14,
        LastTemplateToken = 17,
        FirstBinaryOperator = 29,
        LastBinaryOperator = 78,
        FirstStatement = 240,
        LastStatement = 256,
        FirstNode = 163,
        FirstJSDocNode = 312,
        LastJSDocNode = 353,
        FirstJSDocTagNode = 330,
        LastJSDocTagNode = 353
    }
    type TriviaSyntaxKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia | SyntaxKind.NewLineTrivia | SyntaxKind.WhitespaceTrivia | SyntaxKind.ShebangTrivia | SyntaxKind.ConflictMarkerTrivia;
    type LiteralSyntaxKind = SyntaxKind.NumericLiteral | SyntaxKind.BigIntLiteral | SyntaxKind.StringLiteral | SyntaxKind.JsxText | SyntaxKind.JsxTextAllWhiteSpaces | SyntaxKind.RegularExpressionLiteral | SyntaxKind.NoSubstitutionTemplateLiteral;
    type PseudoLiteralSyntaxKind = SyntaxKind.TemplateHead | SyntaxKind.TemplateMiddle | SyntaxKind.TemplateTail;
    type PunctuationSyntaxKind = SyntaxKind.OpenBraceToken | SyntaxKind.CloseBraceToken | SyntaxKind.OpenParenToken | SyntaxKind.CloseParenToken | SyntaxKind.OpenBracketToken | SyntaxKind.CloseBracketToken | SyntaxKind.DotToken | SyntaxKind.DotDotDotToken | SyntaxKind.SemicolonToken | SyntaxKind.CommaToken | SyntaxKind.QuestionDotToken | SyntaxKind.LessThanToken | SyntaxKind.LessThanSlashToken | SyntaxKind.GreaterThanToken | SyntaxKind.LessThanEqualsToken | SyntaxKind.GreaterThanEqualsToken | SyntaxKind.EqualsEqualsToken | SyntaxKind.ExclamationEqualsToken | SyntaxKind.EqualsEqualsEqualsToken | SyntaxKind.ExclamationEqualsEqualsToken | SyntaxKind.EqualsGreaterThanToken | SyntaxKind.PlusToken | SyntaxKind.MinusToken | SyntaxKind.AsteriskToken | SyntaxKind.AsteriskAsteriskToken | SyntaxKind.SlashToken | SyntaxKind.PercentToken | SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken | SyntaxKind.LessThanLessThanToken | SyntaxKind.GreaterThanGreaterThanToken | SyntaxKind.GreaterThanGreaterThanGreaterThanToken | SyntaxKind.AmpersandToken | SyntaxKind.BarToken | SyntaxKind.CaretToken | SyntaxKind.ExclamationToken | SyntaxKind.TildeToken | SyntaxKind.AmpersandAmpersandToken | SyntaxKind.AmpersandAmpersandEqualsToken | SyntaxKind.BarBarToken | SyntaxKind.BarBarEqualsToken | SyntaxKind.QuestionQuestionToken | SyntaxKind.QuestionQuestionEqualsToken | SyntaxKind.QuestionToken | SyntaxKind.ColonToken | SyntaxKind.AtToken | SyntaxKind.BacktickToken | SyntaxKind.HashToken | SyntaxKind.EqualsToken | SyntaxKind.PlusEqualsToken | SyntaxKind.MinusEqualsToken | SyntaxKind.AsteriskEqualsToken | SyntaxKind.AsteriskAsteriskEqualsToken | SyntaxKind.SlashEqualsToken | SyntaxKind.PercentEqualsToken | SyntaxKind.LessThanLessThanEqualsToken | SyntaxKind.GreaterThanGreaterThanEqualsToken | SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken | SyntaxKind.AmpersandEqualsToken | SyntaxKind.BarEqualsToken | SyntaxKind.CaretEqualsToken;
    type KeywordSyntaxKind = SyntaxKind.AbstractKeyword | SyntaxKind.AccessorKeyword | SyntaxKind.AnyKeyword | SyntaxKind.AsKeyword | SyntaxKind.AssertsKeyword | SyntaxKind.AssertKeyword | SyntaxKind.AsyncKeyword | SyntaxKind.AwaitKeyword | SyntaxKind.BigIntKeyword | SyntaxKind.BooleanKeyword | SyntaxKind.BreakKeyword | SyntaxKind.CaseKeyword | SyntaxKind.CatchKeyword | SyntaxKind.ClassKeyword | SyntaxKind.ConstKeyword | SyntaxKind.ConstructorKeyword | SyntaxKind.ContinueKeyword | SyntaxKind.DebuggerKeyword | SyntaxKind.DeclareKeyword | SyntaxKind.DefaultKeyword | SyntaxKind.DeleteKeyword | SyntaxKind.DoKeyword | SyntaxKind.ElseKeyword | SyntaxKind.EnumKeyword | SyntaxKind.ExportKeyword | SyntaxKind.ExtendsKeyword | SyntaxKind.FalseKeyword | SyntaxKind.FinallyKeyword | SyntaxKind.ForKeyword | SyntaxKind.FromKeyword | SyntaxKind.FunctionKeyword | SyntaxKind.GetKeyword | SyntaxKind.GlobalKeyword | SyntaxKind.IfKeyword | SyntaxKind.ImplementsKeyword | SyntaxKind.ImportKeyword | SyntaxKind.InferKeyword | SyntaxKind.InKeyword | SyntaxKind.InstanceOfKeyword | SyntaxKind.InterfaceKeyword | SyntaxKind.IntrinsicKeyword | SyntaxKind.IsKeyword | SyntaxKind.KeyOfKeyword | SyntaxKind.LetKeyword | SyntaxKind.ModuleKeyword | SyntaxKind.NamespaceKeyword | SyntaxKind.NeverKeyword | SyntaxKind.NewKeyword | SyntaxKind.NullKeyword | SyntaxKind.NumberKeyword | SyntaxKind.ObjectKeyword | SyntaxKind.OfKeyword | SyntaxKind.PackageKeyword | SyntaxKind.PrivateKeyword | SyntaxKind.ProtectedKeyword | SyntaxKind.PublicKeyword | SyntaxKind.ReadonlyKeyword | SyntaxKind.OutKeyword | SyntaxKind.OverrideKeyword | SyntaxKind.RequireKeyword | SyntaxKind.ReturnKeyword | SyntaxKind.SatisfiesKeyword | SyntaxKind.SetKeyword | SyntaxKind.StaticKeyword | SyntaxKind.StringKeyword | SyntaxKind.SuperKeyword | SyntaxKind.SwitchKeyword | SyntaxKind.SymbolKeyword | SyntaxKind.ThisKeyword | SyntaxKind.ThrowKeyword | SyntaxKind.TrueKeyword | SyntaxKind.TryKeyword | SyntaxKind.TypeKeyword | SyntaxKind.TypeOfKeyword | SyntaxKind.UndefinedKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.UnknownKeyword | SyntaxKind.VarKeyword | SyntaxKind.VoidKeyword | SyntaxKind.WhileKeyword | SyntaxKind.WithKeyword | SyntaxKind.YieldKeyword;
    type ModifierSyntaxKind = SyntaxKind.AbstractKeyword | SyntaxKind.AccessorKeyword | SyntaxKind.AsyncKeyword | SyntaxKind.ConstKeyword | SyntaxKind.DeclareKeyword | SyntaxKind.DefaultKeyword | SyntaxKind.ExportKeyword | SyntaxKind.InKeyword | SyntaxKind.PrivateKeyword | SyntaxKind.ProtectedKeyword | SyntaxKind.PublicKeyword | SyntaxKind.ReadonlyKeyword | SyntaxKind.OutKeyword | SyntaxKind.OverrideKeyword | SyntaxKind.StaticKeyword;
    type KeywordTypeSyntaxKind = SyntaxKind.AnyKeyword | SyntaxKind.BigIntKeyword | SyntaxKind.BooleanKeyword | SyntaxKind.IntrinsicKeyword | SyntaxKind.NeverKeyword | SyntaxKind.NumberKeyword | SyntaxKind.ObjectKeyword | SyntaxKind.StringKeyword | SyntaxKind.SymbolKeyword | SyntaxKind.UndefinedKeyword | SyntaxKind.UnknownKeyword | SyntaxKind.VoidKeyword;
    type TokenSyntaxKind = SyntaxKind.Unknown | SyntaxKind.EndOfFileToken | TriviaSyntaxKind | LiteralSyntaxKind | PseudoLiteralSyntaxKind | PunctuationSyntaxKind | SyntaxKind.Identifier | KeywordSyntaxKind;
    type JsxTokenSyntaxKind = SyntaxKind.LessThanSlashToken | SyntaxKind.EndOfFileToken | SyntaxKind.ConflictMarkerTrivia | SyntaxKind.JsxText | SyntaxKind.JsxTextAllWhiteSpaces | SyntaxKind.OpenBraceToken | SyntaxKind.LessThanToken;
    type JSDocSyntaxKind = SyntaxKind.EndOfFileToken | SyntaxKind.WhitespaceTrivia | SyntaxKind.AtToken | SyntaxKind.NewLineTrivia | SyntaxKind.AsteriskToken | SyntaxKind.OpenBraceToken | SyntaxKind.CloseBraceToken | SyntaxKind.LessThanToken | SyntaxKind.GreaterThanToken | SyntaxKind.OpenBracketToken | SyntaxKind.CloseBracketToken | SyntaxKind.EqualsToken | SyntaxKind.CommaToken | SyntaxKind.DotToken | SyntaxKind.Identifier | SyntaxKind.BacktickToken | SyntaxKind.HashToken | SyntaxKind.Unknown | KeywordSyntaxKind;
    enum NodeFlags {
        None = 0,
        Let = 1,
        Const = 2,
        NestedNamespace = 4,
        Synthesized = 8,
        Namespace = 16,
        OptionalChain = 32,
        ExportContext = 64,
        ContainsThis = 128,
        HasImplicitReturn = 256,
        HasExplicitReturn = 512,
        GlobalAugmentation = 1024,
        HasAsyncFunctions = 2048,
        DisallowInContext = 4096,
        YieldContext = 8192,
        DecoratorContext = 16384,
        AwaitContext = 32768,
        DisallowConditionalTypesContext = 65536,
        ThisNodeHasError = 131072,
        JavaScriptFile = 262144,
        ThisNodeOrAnySubNodesHasError = 524288,
        HasAggregatedChildData = 1048576,
        JSDoc = 8388608,
        JsonFile = 67108864,
        BlockScoped = 3,
        ReachabilityCheckFlags = 768,
        ReachabilityAndEmitFlags = 2816,
        ContextFlags = 50720768,
        TypeExcludesFlags = 40960
    }
    enum ModifierFlags {
        None = 0,
        Export = 1,
        Ambient = 2,
        Public = 4,
        Private = 8,
        Protected = 16,
        Static = 32,
        Readonly = 64,
        Accessor = 128,
        Abstract = 256,
        Async = 512,
        Default = 1024,
        Const = 2048,
        HasComputedJSDocModifiers = 4096,
        Deprecated = 8192,
        Override = 16384,
        In = 32768,
        Out = 65536,
        Decorator = 131072,
        HasComputedFlags = 536870912,
        AccessibilityModifier = 28,
        ParameterPropertyModifier = 16476,
        NonPublicAccessibilityModifier = 24,
        TypeScriptModifier = 117086,
        ExportDefault = 1025,
        All = 258047,
        Modifier = 126975
    }
    enum JsxFlags {
        None = 0,
        /** An element from a named property of the JSX.IntrinsicElements interface */
        IntrinsicNamedElement = 1,
        /** An element inferred from the string index signature of the JSX.IntrinsicElements interface */
        IntrinsicIndexedElement = 2,
        IntrinsicElement = 3
    }
    interface Node extends ReadonlyTextRange {
        readonly kind: SyntaxKind;
        readonly flags: NodeFlags;
        readonly parent: Node;
    }
    interface Node {
        getSourceFile(): SourceFile;
        getChildCount(sourceFile?: SourceFile): number;
        getChildAt(index: number, sourceFile?: SourceFile): Node;
        getChildren(sourceFile?: SourceFile): Node[];
        getStart(sourceFile?: SourceFile, includeJsDocComment?: boolean): number;
        getFullStart(): number;
        getEnd(): number;
        getWidth(sourceFile?: SourceFileLike): number;
        getFullWidth(): number;
        getLeadingTriviaWidth(sourceFile?: SourceFile): number;
        getFullText(sourceFile?: SourceFile): string;
        getText(sourceFile?: SourceFile): string;
        getFirstToken(sourceFile?: SourceFile): Node | undefined;
        getLastToken(sourceFile?: SourceFile): Node | undefined;
        forEachChild<T>(cbNode: (node: Node) => T | undefined, cbNodeArray?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;
    }
    interface JSDocContainer extends Node {
        _jsdocContainerBrand: any;
    }
    interface LocalsContainer extends Node {
        _localsContainerBrand: any;
    }
    interface FlowContainer extends Node {
        _flowContainerBrand: any;
    }
    type HasJSDoc = AccessorDeclaration | ArrowFunction | BinaryExpression | Block | BreakStatement | CallSignatureDeclaration | CaseClause | ClassLikeDeclaration | ClassStaticBlockDeclaration | ConstructorDeclaration | ConstructorTypeNode | ConstructSignatureDeclaration | ContinueStatement | DebuggerStatement | DoStatement | ElementAccessExpression | EmptyStatement | EndOfFileToken | EnumDeclaration | EnumMember | ExportAssignment | ExportDeclaration | ExportSpecifier | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | FunctionDeclaration | FunctionExpression | FunctionTypeNode | Identifier | IfStatement | ImportDeclaration | ImportEqualsDeclaration | IndexSignatureDeclaration | InterfaceDeclaration | JSDocFunctionType | JSDocSignature | LabeledStatement | MethodDeclaration | MethodSignature | ModuleDeclaration | NamedTupleMember | NamespaceExportDeclaration | ObjectLiteralExpression | ParameterDeclaration | ParenthesizedExpression | PropertyAccessExpression | PropertyAssignment | PropertyDeclaration | PropertySignature | ReturnStatement | ShorthandPropertyAssignment | SpreadAssignment | SwitchStatement | ThrowStatement | TryStatement | TypeAliasDeclaration | TypeParameterDeclaration | VariableDeclaration | VariableStatement | WhileStatement | WithStatement;
    type HasType = SignatureDeclaration | VariableDeclaration | ParameterDeclaration | PropertySignature | PropertyDeclaration | TypePredicateNode | ParenthesizedTypeNode | TypeOperatorNode | MappedTypeNode | AssertionExpression | TypeAliasDeclaration | JSDocTypeExpression | JSDocNonNullableType | JSDocNullableType | JSDocOptionalType | JSDocVariadicType;
    type HasTypeArguments = CallExpression | NewExpression | TaggedTemplateExpression | JsxOpeningElement | JsxSelfClosingElement;
    type HasInitializer = HasExpressionInitializer | ForStatement | ForInStatement | ForOfStatement | JsxAttribute;
    type HasExpressionInitializer = VariableDeclaration | ParameterDeclaration | BindingElement | PropertyDeclaration | PropertyAssignment | EnumMember;
    type HasDecorators = ParameterDeclaration | PropertyDeclaration | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ClassExpression | ClassDeclaration;
    type HasModifiers = TypeParameterDeclaration | ParameterDeclaration | ConstructorTypeNode | PropertySignature | PropertyDeclaration | MethodSignature | MethodDeclaration | ConstructorDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | IndexSignatureDeclaration | FunctionExpression | ArrowFunction | ClassExpression | VariableStatement | FunctionDeclaration | ClassDeclaration | InterfaceDeclaration | TypeAliasDeclaration | EnumDeclaration | ModuleDeclaration | ImportEqualsDeclaration | ImportDeclaration | ExportAssignment | ExportDeclaration;
    interface NodeArray<T extends Node> extends ReadonlyArray<T>, ReadonlyTextRange {
        readonly hasTrailingComma: boolean;
    }
    interface Token<TKind extends SyntaxKind> extends Node {
        readonly kind: TKind;
    }
    type EndOfFileToken = Token<SyntaxKind.EndOfFileToken> & JSDocContainer;
    interface PunctuationToken<TKind extends PunctuationSyntaxKind> extends Token<TKind> {
    }
    type DotToken = PunctuationToken<SyntaxKind.DotToken>;
    type DotDotDotToken = PunctuationToken<SyntaxKind.DotDotDotToken>;
    type QuestionToken = PunctuationToken<SyntaxKind.QuestionToken>;
    type ExclamationToken = PunctuationToken<SyntaxKind.ExclamationToken>;
    type ColonToken = PunctuationToken<SyntaxKind.ColonToken>;
    type EqualsToken = PunctuationToken<SyntaxKind.EqualsToken>;
    type AmpersandAmpersandEqualsToken = PunctuationToken<SyntaxKind.AmpersandAmpersandEqualsToken>;
    type BarBarEqualsToken = PunctuationToken<SyntaxKind.BarBarEqualsToken>;
    type QuestionQuestionEqualsToken = PunctuationToken<SyntaxKind.QuestionQuestionEqualsToken>;
    type AsteriskToken = PunctuationToken<SyntaxKind.AsteriskToken>;
    type EqualsGreaterThanToken = PunctuationToken<SyntaxKind.EqualsGreaterThanToken>;
    type PlusToken = PunctuationToken<SyntaxKind.PlusToken>;
    type MinusToken = PunctuationToken<SyntaxKind.MinusToken>;
    type QuestionDotToken = PunctuationToken<SyntaxKind.QuestionDotToken>;
    interface KeywordToken<TKind extends KeywordSyntaxKind> extends Token<TKind> {
    }
    type AssertsKeyword = KeywordToken<SyntaxKind.AssertsKeyword>;
    type AssertKeyword = KeywordToken<SyntaxKind.AssertKeyword>;
    type AwaitKeyword = KeywordToken<SyntaxKind.AwaitKeyword>;
    type CaseKeyword = KeywordToken<SyntaxKind.CaseKeyword>;
    interface ModifierToken<TKind extends ModifierSyntaxKind> extends KeywordToken<TKind> {
    }
    type AbstractKeyword = ModifierToken<SyntaxKind.AbstractKeyword>;
    type AccessorKeyword = ModifierToken<SyntaxKind.AccessorKeyword>;
    type AsyncKeyword = ModifierToken<SyntaxKind.AsyncKeyword>;
    type ConstKeyword = ModifierToken<SyntaxKind.ConstKeyword>;
    type DeclareKeyword = ModifierToken<SyntaxKind.DeclareKeyword>;
    type DefaultKeyword = ModifierToken<SyntaxKind.DefaultKeyword>;
    type ExportKeyword = ModifierToken<SyntaxKind.ExportKeyword>;
    type InKeyword = ModifierToken<SyntaxKind.InKeyword>;
    type PrivateKeyword = ModifierToken<SyntaxKind.PrivateKeyword>;
    type ProtectedKeyword = ModifierToken<SyntaxKind.ProtectedKeyword>;
    type PublicKeyword = ModifierToken<SyntaxKind.PublicKeyword>;
    type ReadonlyKeyword = ModifierToken<SyntaxKind.ReadonlyKeyword>;
    type OutKeyword = ModifierToken<SyntaxKind.OutKeyword>;
    type OverrideKeyword = ModifierToken<SyntaxKind.OverrideKeyword>;
    type StaticKeyword = ModifierToken<SyntaxKind.StaticKeyword>;
    type Modifier = AbstractKeyword | AccessorKeyword | AsyncKeyword | ConstKeyword | DeclareKeyword | DefaultKeyword | ExportKeyword | InKeyword | PrivateKeyword | ProtectedKeyword | PublicKeyword | OutKeyword | OverrideKeyword | ReadonlyKeyword | StaticKeyword;
    type ModifierLike = Modifier | Decorator;
    type AccessibilityModifier = PublicKeyword | PrivateKeyword | ProtectedKeyword;
    type ParameterPropertyModifier = AccessibilityModifier | ReadonlyKeyword;
    type ClassMemberModifier = AccessibilityModifier | ReadonlyKeyword | StaticKeyword | AccessorKeyword;
    type ModifiersArray = NodeArray<Modifier>;
    enum GeneratedIdentifierFlags {
        None = 0,
        ReservedInNestedScopes = 8,
        Optimistic = 16,
        FileLevel = 32,
        AllowNameSubstitution = 64
    }
    interface Identifier extends PrimaryExpression, Declaration, JSDocContainer, FlowContainer {
        readonly kind: SyntaxKind.Identifier;
        /**
         * Prefer to use `id.unescapedText`. (Note: This is available only in services, not internally to the TypeScript compiler.)
         * Text of identifier, but if the identifier begins with two underscores, this will begin with three.
         */
        readonly escapedText: __String;
    }
    interface Identifier {
        readonly text: string;
    }
    interface Identifier {
        /** @deprecated Use `idKeyword(identifier)` instead. */
        readonly originalKeywordKind?: SyntaxKind;
        /** @deprecated Use `.parent` or the surrounding context to determine this instead. */
        readonly isInJSDocNamespace?: boolean;
    }
    interface TransientIdentifier extends Identifier {
        resolvedSymbol: Symbol;
    }
    interface QualifiedName extends Node, FlowContainer {
        readonly kind: SyntaxKind.QualifiedName;
        readonly left: EntityName;
        readonly right: Identifier;
    }
    type EntityName = Identifier | QualifiedName;
    type PropertyName = Identifier | StringLiteral | NumericLiteral | ComputedPropertyName | PrivateIdentifier;
    type MemberName = Identifier | PrivateIdentifier;
    type DeclarationName = Identifier | PrivateIdentifier | StringLiteralLike | NumericLiteral | ComputedPropertyName | ElementAccessExpression | BindingPattern | EntityNameExpression;
    interface Declaration extends Node {
        _declarationBrand: any;
    }
    interface NamedDeclaration extends Declaration {
        readonly name?: DeclarationName;
    }
    interface DeclarationStatement extends NamedDeclaration, Statement {
        readonly name?: Identifier | StringLiteral | NumericLiteral;
    }
    interface ComputedPropertyName extends Node {
        readonly kind: SyntaxKind.ComputedPropertyName;
        readonly parent: Declaration;
        readonly expression: Expression;
    }
    interface PrivateIdentifier extends PrimaryExpression {
        readonly kind: SyntaxKind.PrivateIdentifier;
        readonly escapedText: __String;
    }
    interface PrivateIdentifier {
        readonly text: string;
    }
    interface Decorator extends Node {
        readonly kind: SyntaxKind.Decorator;
        readonly parent: NamedDeclaration;
        readonly expression: LeftHandSideExpression;
    }
    interface TypeParameterDeclaration extends NamedDeclaration, JSDocContainer {
        readonly kind: SyntaxKind.TypeParameter;
        readonly parent: DeclarationWithTypeParameterChildren | InferTypeNode;
        readonly modifiers?: NodeArray<Modifier>;
        readonly name: Identifier;
        /** Note: Consider calling `getEffectiveConstraintOfTypeParameter` */
        readonly constraint?: TypeNode;
        readonly default?: TypeNode;
        expression?: Expression;
    }
    interface SignatureDeclarationBase extends NamedDeclaration, JSDocContainer {
        readonly kind: SignatureDeclaration["kind"];
        readonly name?: PropertyName;
        readonly typeParameters?: NodeArray<TypeParameterDeclaration> | undefined;
        readonly parameters: NodeArray<ParameterDeclaration>;
        readonly type?: TypeNode | undefined;
    }
    type SignatureDeclaration = CallSignatureDeclaration | ConstructSignatureDeclaration | MethodSignature | IndexSignatureDeclaration | FunctionTypeNode | ConstructorTypeNode | JSDocFunctionType | FunctionDeclaration | MethodDeclaration | ConstructorDeclaration | AccessorDeclaration | FunctionExpression | ArrowFunction;
    interface CallSignatureDeclaration extends SignatureDeclarationBase, TypeElement, LocalsContainer {
        readonly kind: SyntaxKind.CallSignature;
    }
    interface ConstructSignatureDeclaration extends SignatureDeclarationBase, TypeElement, LocalsContainer {
        readonly kind: SyntaxKind.ConstructSignature;
    }
    type BindingName = Identifier | BindingPattern;
    interface VariableDeclaration extends NamedDeclaration, JSDocContainer {
        readonly kind: SyntaxKind.VariableDeclaration;
        readonly parent: VariableDeclarationList | CatchClause;
        readonly name: BindingName;
        readonly exclamationToken?: ExclamationToken;
        readonly type?: TypeNode;
        readonly initializer?: Expression;
    }
    interface VariableDeclarationList extends Node {
        readonly kind: SyntaxKind.VariableDeclarationList;
        readonly parent: VariableStatement | ForStatement | ForOfStatement | ForInStatement;
        readonly declarations: NodeArray<VariableDeclaration>;
    }
    interface ParameterDeclaration extends NamedDeclaration, JSDocContainer {
        readonly kind: SyntaxKind.Parameter;
        readonly parent: SignatureDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly dotDotDotToken?: DotDotDotToken;
        readonly name: BindingName;
        readonly questionToken?: QuestionToken;
        readonly type?: TypeNode;
        readonly initializer?: Expression;
    }
    interface BindingElement extends NamedDeclaration, FlowContainer {
        readonly kind: SyntaxKind.BindingElement;
        readonly parent: BindingPattern;
        readonly propertyName?: PropertyName;
        readonly dotDotDotToken?: DotDotDotToken;
        readonly name: BindingName;
        readonly initializer?: Expression;
    }
    interface PropertySignature extends TypeElement, JSDocContainer {
        readonly kind: SyntaxKind.PropertySignature;
        readonly parent: TypeLiteralNode | InterfaceDeclaration;
        readonly modifiers?: NodeArray<Modifier>;
        readonly name: PropertyName;
        readonly questionToken?: QuestionToken;
        readonly type?: TypeNode;
    }
    interface PropertyDeclaration extends ClassElement, JSDocContainer {
        readonly kind: SyntaxKind.PropertyDeclaration;
        readonly parent: ClassLikeDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly name: PropertyName;
        readonly questionToken?: QuestionToken;
        readonly exclamationToken?: ExclamationToken;
        readonly type?: TypeNode;
        readonly initializer?: Expression;
    }
    interface AutoAccessorPropertyDeclaration extends PropertyDeclaration {
        _autoAccessorBrand: any;
    }
    interface ObjectLiteralElement extends NamedDeclaration {
        _objectLiteralBrand: any;
        readonly name?: PropertyName;
    }
    /** Unlike ObjectLiteralElement, excludes JSXAttribute and JSXSpreadAttribute. */
    type ObjectLiteralElementLike = PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment | MethodDeclaration | AccessorDeclaration;
    interface PropertyAssignment extends ObjectLiteralElement, JSDocContainer {
        readonly kind: SyntaxKind.PropertyAssignment;
        readonly parent: ObjectLiteralExpression;
        readonly name: PropertyName;
        readonly initializer: Expression;
    }
    interface ShorthandPropertyAssignment extends ObjectLiteralElement, JSDocContainer {
        readonly kind: SyntaxKind.ShorthandPropertyAssignment;
        readonly parent: ObjectLiteralExpression;
        readonly name: Identifier;
        readonly equalsToken?: EqualsToken;
        readonly objectAssignmentInitializer?: Expression;
    }
    interface SpreadAssignment extends ObjectLiteralElement, JSDocContainer {
        readonly kind: SyntaxKind.SpreadAssignment;
        readonly parent: ObjectLiteralExpression;
        readonly expression: Expression;
    }
    type VariableLikeDeclaration = VariableDeclaration | ParameterDeclaration | BindingElement | PropertyDeclaration | PropertyAssignment | PropertySignature | JsxAttribute | ShorthandPropertyAssignment | EnumMember | JSDocPropertyTag | JSDocParameterTag;
    interface ObjectBindingPattern extends Node {
        readonly kind: SyntaxKind.ObjectBindingPattern;
        readonly parent: VariableDeclaration | ParameterDeclaration | BindingElement;
        readonly elements: NodeArray<BindingElement>;
    }
    interface ArrayBindingPattern extends Node {
        readonly kind: SyntaxKind.ArrayBindingPattern;
        readonly parent: VariableDeclaration | ParameterDeclaration | BindingElement;
        readonly elements: NodeArray<ArrayBindingElement>;
    }
    type BindingPattern = ObjectBindingPattern | ArrayBindingPattern;
    type ArrayBindingElement = BindingElement | OmittedExpression;
    /**
     * Several node kinds share function-like features such as a signature,
     * a name, and a body. These nodes should extend FunctionLikeDeclarationBase.
     * Examples:
     * - FunctionDeclaration
     * - MethodDeclaration
     * - AccessorDeclaration
     */
    interface FunctionLikeDeclarationBase extends SignatureDeclarationBase {
        _functionLikeDeclarationBrand: any;
        readonly asteriskToken?: AsteriskToken | undefined;
        readonly questionToken?: QuestionToken | undefined;
        readonly exclamationToken?: ExclamationToken | undefined;
        readonly body?: Block | Expression | undefined;
    }
    type FunctionLikeDeclaration = FunctionDeclaration | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ConstructorDeclaration | FunctionExpression | ArrowFunction;
    /** @deprecated Use SignatureDeclaration */
    type FunctionLike = SignatureDeclaration;
    interface FunctionDeclaration extends FunctionLikeDeclarationBase, DeclarationStatement, LocalsContainer {
        readonly kind: SyntaxKind.FunctionDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly name?: Identifier;
        readonly body?: FunctionBody;
    }
    interface MethodSignature extends SignatureDeclarationBase, TypeElement, LocalsContainer {
        readonly kind: SyntaxKind.MethodSignature;
        readonly parent: TypeLiteralNode | InterfaceDeclaration;
        readonly modifiers?: NodeArray<Modifier>;
        readonly name: PropertyName;
    }
    interface MethodDeclaration extends FunctionLikeDeclarationBase, ClassElement, ObjectLiteralElement, JSDocContainer, LocalsContainer, FlowContainer {
        readonly kind: SyntaxKind.MethodDeclaration;
        readonly parent: ClassLikeDeclaration | ObjectLiteralExpression;
        readonly modifiers?: NodeArray<ModifierLike> | undefined;
        readonly name: PropertyName;
        readonly body?: FunctionBody | undefined;
    }
    interface ConstructorDeclaration extends FunctionLikeDeclarationBase, ClassElement, JSDocContainer, LocalsContainer {
        readonly kind: SyntaxKind.Constructor;
        readonly parent: ClassLikeDeclaration;
        readonly modifiers?: NodeArray<ModifierLike> | undefined;
        readonly body?: FunctionBody | undefined;
    }
    /** For when we encounter a semicolon in a class declaration. ES6 allows these as class elements. */
    interface SemicolonClassElement extends ClassElement {
        readonly kind: SyntaxKind.SemicolonClassElement;
        readonly parent: ClassLikeDeclaration;
    }
    interface GetAccessorDeclaration extends FunctionLikeDeclarationBase, ClassElement, TypeElement, ObjectLiteralElement, JSDocContainer, LocalsContainer, FlowContainer {
        readonly kind: SyntaxKind.GetAccessor;
        readonly parent: ClassLikeDeclaration | ObjectLiteralExpression | TypeLiteralNode | InterfaceDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly name: PropertyName;
        readonly body?: FunctionBody;
    }
    interface SetAccessorDeclaration extends FunctionLikeDeclarationBase, ClassElement, TypeElement, ObjectLiteralElement, JSDocContainer, LocalsContainer, FlowContainer {
        readonly kind: SyntaxKind.SetAccessor;
        readonly parent: ClassLikeDeclaration | ObjectLiteralExpression | TypeLiteralNode | InterfaceDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly name: PropertyName;
        readonly body?: FunctionBody;
    }
    type AccessorDeclaration = GetAccessorDeclaration | SetAccessorDeclaration;
    interface IndexSignatureDeclaration extends SignatureDeclarationBase, ClassElement, TypeElement, LocalsContainer {
        readonly kind: SyntaxKind.IndexSignature;
        readonly parent: ObjectTypeDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly type: TypeNode;
    }
    interface ClassStaticBlockDeclaration extends ClassElement, JSDocContainer, LocalsContainer {
        readonly kind: SyntaxKind.ClassStaticBlockDeclaration;
        readonly parent: ClassDeclaration | ClassExpression;
        readonly body: Block;
    }
    interface TypeNode extends Node {
        _typeNodeBrand: any;
    }
    interface KeywordTypeNode<TKind extends KeywordTypeSyntaxKind = KeywordTypeSyntaxKind> extends KeywordToken<TKind>, TypeNode {
        readonly kind: TKind;
    }
    interface ImportTypeAssertionContainer extends Node {
        readonly kind: SyntaxKind.ImportTypeAssertionContainer;
        readonly parent: ImportTypeNode;
        readonly assertClause: AssertClause;
        readonly multiLine?: boolean;
    }
    interface ImportTypeNode extends NodeWithTypeArguments {
        readonly kind: SyntaxKind.ImportType;
        readonly isTypeOf: boolean;
        readonly argument: TypeNode;
        readonly assertions?: ImportTypeAssertionContainer;
        readonly qualifier?: EntityName;
    }
    interface ThisTypeNode extends TypeNode {
        readonly kind: SyntaxKind.ThisType;
    }
    type FunctionOrConstructorTypeNode = FunctionTypeNode | ConstructorTypeNode;
    interface FunctionOrConstructorTypeNodeBase extends TypeNode, SignatureDeclarationBase {
        readonly kind: SyntaxKind.FunctionType | SyntaxKind.ConstructorType;
        readonly type: TypeNode;
    }
    interface FunctionTypeNode extends FunctionOrConstructorTypeNodeBase, LocalsContainer {
        readonly kind: SyntaxKind.FunctionType;
    }
    interface ConstructorTypeNode extends FunctionOrConstructorTypeNodeBase, LocalsContainer {
        readonly kind: SyntaxKind.ConstructorType;
        readonly modifiers?: NodeArray<Modifier>;
    }
    interface NodeWithTypeArguments extends TypeNode {
        readonly typeArguments?: NodeArray<TypeNode>;
    }
    type TypeReferenceType = TypeReferenceNode | ExpressionWithTypeArguments;
    interface TypeReferenceNode extends NodeWithTypeArguments {
        readonly kind: SyntaxKind.TypeReference;
        readonly typeName: EntityName;
    }
    interface TypePredicateNode extends TypeNode {
        readonly kind: SyntaxKind.TypePredicate;
        readonly parent: SignatureDeclaration | JSDocTypeExpression;
        readonly assertsModifier?: AssertsKeyword;
        readonly parameterName: Identifier | ThisTypeNode;
        readonly type?: TypeNode;
    }
    interface TypeQueryNode extends NodeWithTypeArguments {
        readonly kind: SyntaxKind.TypeQuery;
        readonly exprName: EntityName;
    }
    interface TypeLiteralNode extends TypeNode, Declaration {
        readonly kind: SyntaxKind.TypeLiteral;
        readonly members: NodeArray<TypeElement>;
    }
    interface ArrayTypeNode extends TypeNode {
        readonly kind: SyntaxKind.ArrayType;
        readonly elementType: TypeNode;
    }
    interface TupleTypeNode extends TypeNode {
        readonly kind: SyntaxKind.TupleType;
        readonly elements: NodeArray<TypeNode | NamedTupleMember>;
    }
    interface NamedTupleMember extends TypeNode, Declaration, JSDocContainer {
        readonly kind: SyntaxKind.NamedTupleMember;
        readonly dotDotDotToken?: Token<SyntaxKind.DotDotDotToken>;
        readonly name: Identifier;
        readonly questionToken?: Token<SyntaxKind.QuestionToken>;
        readonly type: TypeNode;
    }
    interface OptionalTypeNode extends TypeNode {
        readonly kind: SyntaxKind.OptionalType;
        readonly type: TypeNode;
    }
    interface RestTypeNode extends TypeNode {
        readonly kind: SyntaxKind.RestType;
        readonly type: TypeNode;
    }
    type UnionOrIntersectionTypeNode = UnionTypeNode | IntersectionTypeNode;
    interface UnionTypeNode extends TypeNode {
        readonly kind: SyntaxKind.UnionType;
        readonly types: NodeArray<TypeNode>;
    }
    interface IntersectionTypeNode extends TypeNode {
        readonly kind: SyntaxKind.IntersectionType;
        readonly types: NodeArray<TypeNode>;
    }
    interface ConditionalTypeNode extends TypeNode, LocalsContainer {
        readonly kind: SyntaxKind.ConditionalType;
        readonly checkType: TypeNode;
        readonly extendsType: TypeNode;
        readonly trueType: TypeNode;
        readonly falseType: TypeNode;
    }
    interface InferTypeNode extends TypeNode {
        readonly kind: SyntaxKind.InferType;
        readonly typeParameter: TypeParameterDeclaration;
    }
    interface ParenthesizedTypeNode extends TypeNode {
        readonly kind: SyntaxKind.ParenthesizedType;
        readonly type: TypeNode;
    }
    interface TypeOperatorNode extends TypeNode {
        readonly kind: SyntaxKind.TypeOperator;
        readonly operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword;
        readonly type: TypeNode;
    }
    interface IndexedAccessTypeNode extends TypeNode {
        readonly kind: SyntaxKind.IndexedAccessType;
        readonly objectType: TypeNode;
        readonly indexType: TypeNode;
    }
    interface MappedTypeNode extends TypeNode, Declaration, LocalsContainer {
        readonly kind: SyntaxKind.MappedType;
        readonly readonlyToken?: ReadonlyKeyword | PlusToken | MinusToken;
        readonly typeParameter: TypeParameterDeclaration;
        readonly nameType?: TypeNode;
        readonly questionToken?: QuestionToken | PlusToken | MinusToken;
        readonly type?: TypeNode;
        /** Used only to produce grammar errors */
        readonly members?: NodeArray<TypeElement>;
    }
    interface LiteralTypeNode extends TypeNode {
        readonly kind: SyntaxKind.LiteralType;
        readonly literal: NullLiteral | BooleanLiteral | LiteralExpression | PrefixUnaryExpression;
    }
    interface StringLiteral extends LiteralExpression, Declaration {
        readonly kind: SyntaxKind.StringLiteral;
    }
    type StringLiteralLike = StringLiteral | NoSubstitutionTemplateLiteral;
    type PropertyNameLiteral = Identifier | StringLiteralLike | NumericLiteral;
    interface TemplateLiteralTypeNode extends TypeNode {
        kind: SyntaxKind.TemplateLiteralType;
        readonly head: TemplateHead;
        readonly templateSpans: NodeArray<TemplateLiteralTypeSpan>;
    }
    interface TemplateLiteralTypeSpan extends TypeNode {
        readonly kind: SyntaxKind.TemplateLiteralTypeSpan;
        readonly parent: TemplateLiteralTypeNode;
        readonly type: TypeNode;
        readonly literal: TemplateMiddle | TemplateTail;
    }
    interface Expression extends Node {
        _expressionBrand: any;
    }
    interface OmittedExpression extends Expression {
        readonly kind: SyntaxKind.OmittedExpression;
    }
    interface PartiallyEmittedExpression extends LeftHandSideExpression {
        readonly kind: SyntaxKind.PartiallyEmittedExpression;
        readonly expression: Expression;
    }
    interface UnaryExpression extends Expression {
        _unaryExpressionBrand: any;
    }
    /** Deprecated, please use UpdateExpression */
    type IncrementExpression = UpdateExpression;
    interface UpdateExpression extends UnaryExpression {
        _updateExpressionBrand: any;
    }
    type PrefixUnaryOperator = SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken | SyntaxKind.PlusToken | SyntaxKind.MinusToken | SyntaxKind.TildeToken | SyntaxKind.ExclamationToken;
    interface PrefixUnaryExpression extends UpdateExpression {
        readonly kind: SyntaxKind.PrefixUnaryExpression;
        readonly operator: PrefixUnaryOperator;
        readonly operand: UnaryExpression;
    }
    type PostfixUnaryOperator = SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken;
    interface PostfixUnaryExpression extends UpdateExpression {
        readonly kind: SyntaxKind.PostfixUnaryExpression;
        readonly operand: LeftHandSideExpression;
        readonly operator: PostfixUnaryOperator;
    }
    interface LeftHandSideExpression extends UpdateExpression {
        _leftHandSideExpressionBrand: any;
    }
    interface MemberExpression extends LeftHandSideExpression {
        _memberExpressionBrand: any;
    }
    interface PrimaryExpression extends MemberExpression {
        _primaryExpressionBrand: any;
    }
    interface NullLiteral extends PrimaryExpression {
        readonly kind: SyntaxKind.NullKeyword;
    }
    interface TrueLiteral extends PrimaryExpression {
        readonly kind: SyntaxKind.TrueKeyword;
    }
    interface FalseLiteral extends PrimaryExpression {
        readonly kind: SyntaxKind.FalseKeyword;
    }
    type BooleanLiteral = TrueLiteral | FalseLiteral;
    interface ThisExpression extends PrimaryExpression, FlowContainer {
        readonly kind: SyntaxKind.ThisKeyword;
    }
    interface SuperExpression extends PrimaryExpression, FlowContainer {
        readonly kind: SyntaxKind.SuperKeyword;
    }
    interface ImportExpression extends PrimaryExpression {
        readonly kind: SyntaxKind.ImportKeyword;
    }
    interface DeleteExpression extends UnaryExpression {
        readonly kind: SyntaxKind.DeleteExpression;
        readonly expression: UnaryExpression;
    }
    interface TypeOfExpression extends UnaryExpression {
        readonly kind: SyntaxKind.TypeOfExpression;
        readonly expression: UnaryExpression;
    }
    interface VoidExpression extends UnaryExpression {
        readonly kind: SyntaxKind.VoidExpression;
        readonly expression: UnaryExpression;
    }
    interface AwaitExpression extends UnaryExpression {
        readonly kind: SyntaxKind.AwaitExpression;
        readonly expression: UnaryExpression;
    }
    interface YieldExpression extends Expression {
        readonly kind: SyntaxKind.YieldExpression;
        readonly asteriskToken?: AsteriskToken;
        readonly expression?: Expression;
    }
    interface SyntheticExpression extends Expression {
        readonly kind: SyntaxKind.SyntheticExpression;
        readonly isSpread: boolean;
        readonly type: Type;
        readonly tupleNameSource?: ParameterDeclaration | NamedTupleMember;
    }
    type ExponentiationOperator = SyntaxKind.AsteriskAsteriskToken;
    type MultiplicativeOperator = SyntaxKind.AsteriskToken | SyntaxKind.SlashToken | SyntaxKind.PercentToken;
    type MultiplicativeOperatorOrHigher = ExponentiationOperator | MultiplicativeOperator;
    type AdditiveOperator = SyntaxKind.PlusToken | SyntaxKind.MinusToken;
    type AdditiveOperatorOrHigher = MultiplicativeOperatorOrHigher | AdditiveOperator;
    type ShiftOperator = SyntaxKind.LessThanLessThanToken | SyntaxKind.GreaterThanGreaterThanToken | SyntaxKind.GreaterThanGreaterThanGreaterThanToken;
    type ShiftOperatorOrHigher = AdditiveOperatorOrHigher | ShiftOperator;
    type RelationalOperator = SyntaxKind.LessThanToken | SyntaxKind.LessThanEqualsToken | SyntaxKind.GreaterThanToken | SyntaxKind.GreaterThanEqualsToken | SyntaxKind.InstanceOfKeyword | SyntaxKind.InKeyword;
    type RelationalOperatorOrHigher = ShiftOperatorOrHigher | RelationalOperator;
    type EqualityOperator = SyntaxKind.EqualsEqualsToken | SyntaxKind.EqualsEqualsEqualsToken | SyntaxKind.ExclamationEqualsEqualsToken | SyntaxKind.ExclamationEqualsToken;
    type EqualityOperatorOrHigher = RelationalOperatorOrHigher | EqualityOperator;
    type BitwiseOperator = SyntaxKind.AmpersandToken | SyntaxKind.BarToken | SyntaxKind.CaretToken;
    type BitwiseOperatorOrHigher = EqualityOperatorOrHigher | BitwiseOperator;
    type LogicalOperator = SyntaxKind.AmpersandAmpersandToken | SyntaxKind.BarBarToken;
    type LogicalOperatorOrHigher = BitwiseOperatorOrHigher | LogicalOperator;
    type CompoundAssignmentOperator = SyntaxKind.PlusEqualsToken | SyntaxKind.MinusEqualsToken | SyntaxKind.AsteriskAsteriskEqualsToken | SyntaxKind.AsteriskEqualsToken | SyntaxKind.SlashEqualsToken | SyntaxKind.PercentEqualsToken | SyntaxKind.AmpersandEqualsToken | SyntaxKind.BarEqualsToken | SyntaxKind.CaretEqualsToken | SyntaxKind.LessThanLessThanEqualsToken | SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken | SyntaxKind.GreaterThanGreaterThanEqualsToken | SyntaxKind.BarBarEqualsToken | SyntaxKind.AmpersandAmpersandEqualsToken | SyntaxKind.QuestionQuestionEqualsToken;
    type AssignmentOperator = SyntaxKind.EqualsToken | CompoundAssignmentOperator;
    type AssignmentOperatorOrHigher = SyntaxKind.QuestionQuestionToken | LogicalOperatorOrHigher | AssignmentOperator;
    type BinaryOperator = AssignmentOperatorOrHigher | SyntaxKind.CommaToken;
    type LogicalOrCoalescingAssignmentOperator = SyntaxKind.AmpersandAmpersandEqualsToken | SyntaxKind.BarBarEqualsToken | SyntaxKind.QuestionQuestionEqualsToken;
    type BinaryOperatorToken = Token<BinaryOperator>;
    interface BinaryExpression extends Expression, Declaration, JSDocContainer {
        readonly kind: SyntaxKind.BinaryExpression;
        readonly left: Expression;
        readonly operatorToken: BinaryOperatorToken;
        readonly right: Expression;
    }
    type AssignmentOperatorToken = Token<AssignmentOperator>;
    interface AssignmentExpression<TOperator extends AssignmentOperatorToken> extends BinaryExpression {
        readonly left: LeftHandSideExpression;
        readonly operatorToken: TOperator;
    }
    interface ObjectDestructuringAssignment extends AssignmentExpression<EqualsToken> {
        readonly left: ObjectLiteralExpression;
    }
    interface ArrayDestructuringAssignment extends AssignmentExpression<EqualsToken> {
        readonly left: ArrayLiteralExpression;
    }
    type DestructuringAssignment = ObjectDestructuringAssignment | ArrayDestructuringAssignment;
    type BindingOrAssignmentElement = VariableDeclaration | ParameterDeclaration | ObjectBindingOrAssignmentElement | ArrayBindingOrAssignmentElement;
    type ObjectBindingOrAssignmentElement = BindingElement | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment;
    type ArrayBindingOrAssignmentElement = BindingElement | OmittedExpression | SpreadElement | ArrayLiteralExpression | ObjectLiteralExpression | AssignmentExpression<EqualsToken> | Identifier | PropertyAccessExpression | ElementAccessExpression;
    type BindingOrAssignmentElementRestIndicator = DotDotDotToken | SpreadElement | SpreadAssignment;
    type BindingOrAssignmentElementTarget = BindingOrAssignmentPattern | Identifier | PropertyAccessExpression | ElementAccessExpression | OmittedExpression;
    type ObjectBindingOrAssignmentPattern = ObjectBindingPattern | ObjectLiteralExpression;
    type ArrayBindingOrAssignmentPattern = ArrayBindingPattern | ArrayLiteralExpression;
    type AssignmentPattern = ObjectLiteralExpression | ArrayLiteralExpression;
    type BindingOrAssignmentPattern = ObjectBindingOrAssignmentPattern | ArrayBindingOrAssignmentPattern;
    interface ConditionalExpression extends Expression {
        readonly kind: SyntaxKind.ConditionalExpression;
        readonly condition: Expression;
        readonly questionToken: QuestionToken;
        readonly whenTrue: Expression;
        readonly colonToken: ColonToken;
        readonly whenFalse: Expression;
    }
    type FunctionBody = Block;
    type ConciseBody = FunctionBody | Expression;
    interface FunctionExpression extends PrimaryExpression, FunctionLikeDeclarationBase, JSDocContainer, LocalsContainer, FlowContainer {
        readonly kind: SyntaxKind.FunctionExpression;
        readonly modifiers?: NodeArray<Modifier>;
        readonly name?: Identifier;
        readonly body: FunctionBody;
    }
    interface ArrowFunction extends Expression, FunctionLikeDeclarationBase, JSDocContainer, LocalsContainer, FlowContainer {
        readonly kind: SyntaxKind.ArrowFunction;
        readonly modifiers?: NodeArray<Modifier>;
        readonly equalsGreaterThanToken: EqualsGreaterThanToken;
        readonly body: ConciseBody;
        readonly name: never;
    }
    interface LiteralLikeNode extends Node {
        text: string;
        isUnterminated?: boolean;
        hasExtendedUnicodeEscape?: boolean;
    }
    interface TemplateLiteralLikeNode extends LiteralLikeNode {
        rawText?: string;
    }
    interface LiteralExpression extends LiteralLikeNode, PrimaryExpression {
        _literalExpressionBrand: any;
    }
    interface RegularExpressionLiteral extends LiteralExpression {
        readonly kind: SyntaxKind.RegularExpressionLiteral;
    }
    interface NoSubstitutionTemplateLiteral extends LiteralExpression, TemplateLiteralLikeNode, Declaration {
        readonly kind: SyntaxKind.NoSubstitutionTemplateLiteral;
    }
    enum TokenFlags {
        None = 0,
        Scientific = 16,
        Octal = 32,
        HexSpecifier = 64,
        BinarySpecifier = 128,
        OctalSpecifier = 256
    }
    interface NumericLiteral extends LiteralExpression, Declaration {
        readonly kind: SyntaxKind.NumericLiteral;
    }
    interface BigIntLiteral extends LiteralExpression {
        readonly kind: SyntaxKind.BigIntLiteral;
    }
    type LiteralToken = NumericLiteral | BigIntLiteral | StringLiteral | JsxText | RegularExpressionLiteral | NoSubstitutionTemplateLiteral;
    interface TemplateHead extends TemplateLiteralLikeNode {
        readonly kind: SyntaxKind.TemplateHead;
        readonly parent: TemplateExpression | TemplateLiteralTypeNode;
    }
    interface TemplateMiddle extends TemplateLiteralLikeNode {
        readonly kind: SyntaxKind.TemplateMiddle;
        readonly parent: TemplateSpan | TemplateLiteralTypeSpan;
    }
    interface TemplateTail extends TemplateLiteralLikeNode {
        readonly kind: SyntaxKind.TemplateTail;
        readonly parent: TemplateSpan | TemplateLiteralTypeSpan;
    }
    type PseudoLiteralToken = TemplateHead | TemplateMiddle | TemplateTail;
    type TemplateLiteralToken = NoSubstitutionTemplateLiteral | PseudoLiteralToken;
    interface TemplateExpression extends PrimaryExpression {
        readonly kind: SyntaxKind.TemplateExpression;
        readonly head: TemplateHead;
        readonly templateSpans: NodeArray<TemplateSpan>;
    }
    type TemplateLiteral = TemplateExpression | NoSubstitutionTemplateLiteral;
    interface TemplateSpan extends Node {
        readonly kind: SyntaxKind.TemplateSpan;
        readonly parent: TemplateExpression;
        readonly expression: Expression;
        readonly literal: TemplateMiddle | TemplateTail;
    }
    interface ParenthesizedExpression extends PrimaryExpression, JSDocContainer {
        readonly kind: SyntaxKind.ParenthesizedExpression;
        readonly expression: Expression;
    }
    interface ArrayLiteralExpression extends PrimaryExpression {
        readonly kind: SyntaxKind.ArrayLiteralExpression;
        readonly elements: NodeArray<Expression>;
    }
    interface SpreadElement extends Expression {
        readonly kind: SyntaxKind.SpreadElement;
        readonly parent: ArrayLiteralExpression | CallExpression | NewExpression;
        readonly expression: Expression;
    }
    /**
     * This interface is a base interface for ObjectLiteralExpression and JSXAttributes to extend from. JSXAttributes is similar to
     * ObjectLiteralExpression in that it contains array of properties; however, JSXAttributes' properties can only be
     * JSXAttribute or JSXSpreadAttribute. ObjectLiteralExpression, on the other hand, can only have properties of type
     * ObjectLiteralElement (e.g. PropertyAssignment, ShorthandPropertyAssignment etc.)
     */
    interface ObjectLiteralExpressionBase<T extends ObjectLiteralElement> extends PrimaryExpression, Declaration {
        readonly properties: NodeArray<T>;
    }
    interface ObjectLiteralExpression extends ObjectLiteralExpressionBase<ObjectLiteralElementLike>, JSDocContainer {
        readonly kind: SyntaxKind.ObjectLiteralExpression;
    }
    type EntityNameExpression = Identifier | PropertyAccessEntityNameExpression;
    type EntityNameOrEntityNameExpression = EntityName | EntityNameExpression;
    type AccessExpression = PropertyAccessExpression | ElementAccessExpression;
    interface PropertyAccessExpression extends MemberExpression, NamedDeclaration, JSDocContainer, FlowContainer {
        readonly kind: SyntaxKind.PropertyAccessExpression;
        readonly expression: LeftHandSideExpression;
        readonly questionDotToken?: QuestionDotToken;
        readonly name: MemberName;
    }
    interface PropertyAccessChain extends PropertyAccessExpression {
        _optionalChainBrand: any;
        readonly name: MemberName;
    }
    interface SuperPropertyAccessExpression extends PropertyAccessExpression {
        readonly expression: SuperExpression;
    }
    /** Brand for a PropertyAccessExpression which, like a QualifiedName, consists of a sequence of identifiers separated by dots. */
    interface PropertyAccessEntityNameExpression extends PropertyAccessExpression {
        _propertyAccessExpressionLikeQualifiedNameBrand?: any;
        readonly expression: EntityNameExpression;
        readonly name: Identifier;
    }
    interface ElementAccessExpression extends MemberExpression, Declaration, JSDocContainer, FlowContainer {
        readonly kind: SyntaxKind.ElementAccessExpression;
        readonly expression: LeftHandSideExpression;
        readonly questionDotToken?: QuestionDotToken;
        readonly argumentExpression: Expression;
    }
    interface ElementAccessChain extends ElementAccessExpression {
        _optionalChainBrand: any;
    }
    interface SuperElementAccessExpression extends ElementAccessExpression {
        readonly expression: SuperExpression;
    }
    type SuperProperty = SuperPropertyAccessExpression | SuperElementAccessExpression;
    interface CallExpression extends LeftHandSideExpression, Declaration {
        readonly kind: SyntaxKind.CallExpression;
        readonly expression: LeftHandSideExpression;
        readonly questionDotToken?: QuestionDotToken;
        readonly typeArguments?: NodeArray<TypeNode>;
        readonly arguments: NodeArray<Expression>;
    }
    interface CallChain extends CallExpression {
        _optionalChainBrand: any;
    }
    type OptionalChain = PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;
    interface SuperCall extends CallExpression {
        readonly expression: SuperExpression;
    }
    interface ImportCall extends CallExpression {
        readonly expression: ImportExpression;
    }
    interface ExpressionWithTypeArguments extends MemberExpression, NodeWithTypeArguments {
        readonly kind: SyntaxKind.ExpressionWithTypeArguments;
        readonly expression: LeftHandSideExpression;
    }
    interface NewExpression extends PrimaryExpression, Declaration {
        readonly kind: SyntaxKind.NewExpression;
        readonly expression: LeftHandSideExpression;
        readonly typeArguments?: NodeArray<TypeNode>;
        readonly arguments?: NodeArray<Expression>;
    }
    interface TaggedTemplateExpression extends MemberExpression {
        readonly kind: SyntaxKind.TaggedTemplateExpression;
        readonly tag: LeftHandSideExpression;
        readonly typeArguments?: NodeArray<TypeNode>;
        readonly template: TemplateLiteral;
    }
    type CallLikeExpression = CallExpression | NewExpression | TaggedTemplateExpression | Decorator | JsxOpeningLikeElement;
    interface AsExpression extends Expression {
        readonly kind: SyntaxKind.AsExpression;
        readonly expression: Expression;
        readonly type: TypeNode;
    }
    interface TypeAssertion extends UnaryExpression {
        readonly kind: SyntaxKind.TypeAssertionExpression;
        readonly type: TypeNode;
        readonly expression: UnaryExpression;
    }
    interface SatisfiesExpression extends Expression {
        readonly kind: SyntaxKind.SatisfiesExpression;
        readonly expression: Expression;
        readonly type: TypeNode;
    }
    type AssertionExpression = TypeAssertion | AsExpression;
    interface NonNullExpression extends LeftHandSideExpression {
        readonly kind: SyntaxKind.NonNullExpression;
        readonly expression: Expression;
    }
    interface NonNullChain extends NonNullExpression {
        _optionalChainBrand: any;
    }
    interface MetaProperty extends PrimaryExpression, FlowContainer {
        readonly kind: SyntaxKind.MetaProperty;
        readonly keywordToken: SyntaxKind.NewKeyword | SyntaxKind.ImportKeyword;
        readonly name: Identifier;
    }
    interface JsxElement extends PrimaryExpression {
        readonly kind: SyntaxKind.JsxElement;
        readonly openingElement: JsxOpeningElement;
        readonly children: NodeArray<JsxChild>;
        readonly closingElement: JsxClosingElement;
    }
    type JsxOpeningLikeElement = JsxSelfClosingElement | JsxOpeningElement;
    type JsxAttributeLike = JsxAttribute | JsxSpreadAttribute;
    type JsxTagNameExpression = Identifier | ThisExpression | JsxTagNamePropertyAccess;
    interface JsxTagNamePropertyAccess extends PropertyAccessExpression {
        readonly expression: JsxTagNameExpression;
    }
    interface JsxAttributes extends ObjectLiteralExpressionBase<JsxAttributeLike> {
        readonly kind: SyntaxKind.JsxAttributes;
        readonly parent: JsxOpeningLikeElement;
    }
    interface JsxOpeningElement extends Expression {
        readonly kind: SyntaxKind.JsxOpeningElement;
        readonly parent: JsxElement;
        readonly tagName: JsxTagNameExpression;
        readonly typeArguments?: NodeArray<TypeNode>;
        readonly attributes: JsxAttributes;
    }
    interface JsxSelfClosingElement extends PrimaryExpression {
        readonly kind: SyntaxKind.JsxSelfClosingElement;
        readonly tagName: JsxTagNameExpression;
        readonly typeArguments?: NodeArray<TypeNode>;
        readonly attributes: JsxAttributes;
    }
    interface JsxFragment extends PrimaryExpression {
        readonly kind: SyntaxKind.JsxFragment;
        readonly openingFragment: JsxOpeningFragment;
        readonly children: NodeArray<JsxChild>;
        readonly closingFragment: JsxClosingFragment;
    }
    interface JsxOpeningFragment extends Expression {
        readonly kind: SyntaxKind.JsxOpeningFragment;
        readonly parent: JsxFragment;
    }
    interface JsxClosingFragment extends Expression {
        readonly kind: SyntaxKind.JsxClosingFragment;
        readonly parent: JsxFragment;
    }
    interface JsxAttribute extends ObjectLiteralElement {
        readonly kind: SyntaxKind.JsxAttribute;
        readonly parent: JsxAttributes;
        readonly name: Identifier;
        readonly initializer?: JsxAttributeValue;
    }
    type JsxAttributeValue = StringLiteral | JsxExpression | JsxElement | JsxSelfClosingElement | JsxFragment;
    interface JsxSpreadAttribute extends ObjectLiteralElement {
        readonly kind: SyntaxKind.JsxSpreadAttribute;
        readonly parent: JsxAttributes;
        readonly expression: Expression;
    }
    interface JsxClosingElement extends Node {
        readonly kind: SyntaxKind.JsxClosingElement;
        readonly parent: JsxElement;
        readonly tagName: JsxTagNameExpression;
    }
    interface JsxExpression extends Expression {
        readonly kind: SyntaxKind.JsxExpression;
        readonly parent: JsxElement | JsxFragment | JsxAttributeLike;
        readonly dotDotDotToken?: Token<SyntaxKind.DotDotDotToken>;
        readonly expression?: Expression;
    }
    interface JsxText extends LiteralLikeNode {
        readonly kind: SyntaxKind.JsxText;
        readonly parent: JsxElement | JsxFragment;
        readonly containsOnlyTriviaWhiteSpaces: boolean;
    }
    type JsxChild = JsxText | JsxExpression | JsxElement | JsxSelfClosingElement | JsxFragment;
    interface Statement extends Node, JSDocContainer {
        _statementBrand: any;
    }
    interface NotEmittedStatement extends Statement {
        readonly kind: SyntaxKind.NotEmittedStatement;
    }
    /**
     * A list of comma-separated expressions. This node is only created by transformations.
     */
    interface CommaListExpression extends Expression {
        readonly kind: SyntaxKind.CommaListExpression;
        readonly elements: NodeArray<Expression>;
    }
    interface EmptyStatement extends Statement {
        readonly kind: SyntaxKind.EmptyStatement;
    }
    interface DebuggerStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.DebuggerStatement;
    }
    interface MissingDeclaration extends DeclarationStatement, PrimaryExpression {
        readonly kind: SyntaxKind.MissingDeclaration;
        readonly name?: Identifier;
    }
    type BlockLike = SourceFile | Block | ModuleBlock | CaseOrDefaultClause;
    interface Block extends Statement, LocalsContainer {
        readonly kind: SyntaxKind.Block;
        readonly statements: NodeArray<Statement>;
    }
    interface VariableStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.VariableStatement;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly declarationList: VariableDeclarationList;
    }
    interface ExpressionStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.ExpressionStatement;
        readonly expression: Expression;
    }
    interface IfStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.IfStatement;
        readonly expression: Expression;
        readonly thenStatement: Statement;
        readonly elseStatement?: Statement;
    }
    interface IterationStatement extends Statement {
        readonly statement: Statement;
    }
    interface DoStatement extends IterationStatement, FlowContainer {
        readonly kind: SyntaxKind.DoStatement;
        readonly expression: Expression;
    }
    interface WhileStatement extends IterationStatement, FlowContainer {
        readonly kind: SyntaxKind.WhileStatement;
        readonly expression: Expression;
    }
    type ForInitializer = VariableDeclarationList | Expression;
    interface ForStatement extends IterationStatement, LocalsContainer, FlowContainer {
        readonly kind: SyntaxKind.ForStatement;
        readonly initializer?: ForInitializer;
        readonly condition?: Expression;
        readonly incrementor?: Expression;
    }
    type ForInOrOfStatement = ForInStatement | ForOfStatement;
    interface ForInStatement extends IterationStatement, LocalsContainer, FlowContainer {
        readonly kind: SyntaxKind.ForInStatement;
        readonly initializer: ForInitializer;
        readonly expression: Expression;
    }
    interface ForOfStatement extends IterationStatement, LocalsContainer, FlowContainer {
        readonly kind: SyntaxKind.ForOfStatement;
        readonly awaitModifier?: AwaitKeyword;
        readonly initializer: ForInitializer;
        readonly expression: Expression;
    }
    interface BreakStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.BreakStatement;
        readonly label?: Identifier;
    }
    interface ContinueStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.ContinueStatement;
        readonly label?: Identifier;
    }
    type BreakOrContinueStatement = BreakStatement | ContinueStatement;
    interface ReturnStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.ReturnStatement;
        readonly expression?: Expression;
    }
    interface WithStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.WithStatement;
        readonly expression: Expression;
        readonly statement: Statement;
    }
    interface SwitchStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.SwitchStatement;
        readonly expression: Expression;
        readonly caseBlock: CaseBlock;
        possiblyExhaustive?: boolean;
    }
    interface CaseBlock extends Node, LocalsContainer {
        readonly kind: SyntaxKind.CaseBlock;
        readonly parent: SwitchStatement;
        readonly clauses: NodeArray<CaseOrDefaultClause>;
    }
    interface CaseClause extends Node, JSDocContainer {
        readonly kind: SyntaxKind.CaseClause;
        readonly parent: CaseBlock;
        readonly expression: Expression;
        readonly statements: NodeArray<Statement>;
    }
    interface DefaultClause extends Node {
        readonly kind: SyntaxKind.DefaultClause;
        readonly parent: CaseBlock;
        readonly statements: NodeArray<Statement>;
    }
    type CaseOrDefaultClause = CaseClause | DefaultClause;
    interface LabeledStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.LabeledStatement;
        readonly label: Identifier;
        readonly statement: Statement;
    }
    interface ThrowStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.ThrowStatement;
        readonly expression: Expression;
    }
    interface TryStatement extends Statement, FlowContainer {
        readonly kind: SyntaxKind.TryStatement;
        readonly tryBlock: Block;
        readonly catchClause?: CatchClause;
        readonly finallyBlock?: Block;
    }
    interface CatchClause extends Node, LocalsContainer {
        readonly kind: SyntaxKind.CatchClause;
        readonly parent: TryStatement;
        readonly variableDeclaration?: VariableDeclaration;
        readonly block: Block;
    }
    type ObjectTypeDeclaration = ClassLikeDeclaration | InterfaceDeclaration | TypeLiteralNode;
    type DeclarationWithTypeParameters = DeclarationWithTypeParameterChildren | JSDocTypedefTag | JSDocCallbackTag | JSDocSignature;
    type DeclarationWithTypeParameterChildren = SignatureDeclaration | ClassLikeDeclaration | InterfaceDeclaration | TypeAliasDeclaration | JSDocTemplateTag;
    interface ClassLikeDeclarationBase extends NamedDeclaration, JSDocContainer {
        readonly kind: SyntaxKind.ClassDeclaration | SyntaxKind.ClassExpression;
        readonly name?: Identifier;
        readonly typeParameters?: NodeArray<TypeParameterDeclaration>;
        readonly heritageClauses?: NodeArray<HeritageClause>;
        readonly members: NodeArray<ClassElement>;
    }
    interface ClassDeclaration extends ClassLikeDeclarationBase, DeclarationStatement {
        readonly kind: SyntaxKind.ClassDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        /** May be undefined in `export default class { ... }`. */
        readonly name?: Identifier;
    }
    interface ClassExpression extends ClassLikeDeclarationBase, PrimaryExpression {
        readonly kind: SyntaxKind.ClassExpression;
        readonly modifiers?: NodeArray<ModifierLike>;
    }
    type ClassLikeDeclaration = ClassDeclaration | ClassExpression;
    interface ClassElement extends NamedDeclaration {
        _classElementBrand: any;
        readonly name?: PropertyName;
    }
    interface TypeElement extends NamedDeclaration {
        _typeElementBrand: any;
        readonly name?: PropertyName;
        readonly questionToken?: QuestionToken | undefined;
    }
    interface InterfaceDeclaration extends DeclarationStatement, JSDocContainer {
        readonly kind: SyntaxKind.InterfaceDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly name: Identifier;
        readonly typeParameters?: NodeArray<TypeParameterDeclaration>;
        readonly heritageClauses?: NodeArray<HeritageClause>;
        readonly members: NodeArray<TypeElement>;
    }
    interface HeritageClause extends Node {
        readonly kind: SyntaxKind.HeritageClause;
        readonly parent: InterfaceDeclaration | ClassLikeDeclaration;
        readonly token: SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword;
        readonly types: NodeArray<ExpressionWithTypeArguments>;
    }
    interface TypeAliasDeclaration extends DeclarationStatement, JSDocContainer, LocalsContainer {
        readonly kind: SyntaxKind.TypeAliasDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly name: Identifier;
        readonly typeParameters?: NodeArray<TypeParameterDeclaration>;
        readonly type: TypeNode;
    }
    interface EnumMember extends NamedDeclaration, JSDocContainer {
        readonly kind: SyntaxKind.EnumMember;
        readonly parent: EnumDeclaration;
        readonly name: PropertyName;
        readonly initializer?: Expression;
    }
    interface EnumDeclaration extends DeclarationStatement, JSDocContainer {
        readonly kind: SyntaxKind.EnumDeclaration;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly name: Identifier;
        readonly members: NodeArray<EnumMember>;
    }
    type ModuleName = Identifier | StringLiteral;
    type ModuleBody = NamespaceBody | JSDocNamespaceBody;
    interface ModuleDeclaration extends DeclarationStatement, JSDocContainer, LocalsContainer {
        readonly kind: SyntaxKind.ModuleDeclaration;
        readonly parent: ModuleBody | SourceFile;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly name: ModuleName;
        readonly body?: ModuleBody | JSDocNamespaceDeclaration;
    }
    type NamespaceBody = ModuleBlock | NamespaceDeclaration;
    interface NamespaceDeclaration extends ModuleDeclaration {
        readonly name: Identifier;
        readonly body: NamespaceBody;
    }
    type JSDocNamespaceBody = Identifier | JSDocNamespaceDeclaration;
    interface JSDocNamespaceDeclaration extends ModuleDeclaration {
        readonly name: Identifier;
        readonly body?: JSDocNamespaceBody;
    }
    interface ModuleBlock extends Node, Statement {
        readonly kind: SyntaxKind.ModuleBlock;
        readonly parent: ModuleDeclaration;
        readonly statements: NodeArray<Statement>;
    }
    type ModuleReference = EntityName | ExternalModuleReference;
    /**
     * One of:
     * - import x = require("mod");
     * - import x = M.x;
     */
    interface ImportEqualsDeclaration extends DeclarationStatement, JSDocContainer {
        readonly kind: SyntaxKind.ImportEqualsDeclaration;
        readonly parent: SourceFile | ModuleBlock;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly name: Identifier;
        readonly isTypeOnly: boolean;
        readonly moduleReference: ModuleReference;
    }
    interface ExternalModuleReference extends Node {
        readonly kind: SyntaxKind.ExternalModuleReference;
        readonly parent: ImportEqualsDeclaration;
        readonly expression: Expression;
    }
    interface ImportDeclaration extends Statement {
        readonly kind: SyntaxKind.ImportDeclaration;
        readonly parent: SourceFile | ModuleBlock;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly importClause?: ImportClause;
        /** If this is not a StringLiteral it will be a grammar error. */
        readonly moduleSpecifier: Expression;
        readonly assertClause?: AssertClause;
    }
    type NamedImportBindings = NamespaceImport | NamedImports;
    type NamedExportBindings = NamespaceExport | NamedExports;
    interface ImportClause extends NamedDeclaration {
        readonly kind: SyntaxKind.ImportClause;
        readonly parent: ImportDeclaration;
        readonly isTypeOnly: boolean;
        readonly name?: Identifier;
        readonly namedBindings?: NamedImportBindings;
    }
    type AssertionKey = Identifier | StringLiteral;
    interface AssertEntry extends Node {
        readonly kind: SyntaxKind.AssertEntry;
        readonly parent: AssertClause;
        readonly name: AssertionKey;
        readonly value: Expression;
    }
    interface AssertClause extends Node {
        readonly kind: SyntaxKind.AssertClause;
        readonly parent: ImportDeclaration | ExportDeclaration;
        readonly elements: NodeArray<AssertEntry>;
        readonly multiLine?: boolean;
    }
    interface NamespaceImport extends NamedDeclaration {
        readonly kind: SyntaxKind.NamespaceImport;
        readonly parent: ImportClause;
        readonly name: Identifier;
    }
    interface NamespaceExport extends NamedDeclaration {
        readonly kind: SyntaxKind.NamespaceExport;
        readonly parent: ExportDeclaration;
        readonly name: Identifier;
    }
    interface NamespaceExportDeclaration extends DeclarationStatement, JSDocContainer {
        readonly kind: SyntaxKind.NamespaceExportDeclaration;
        readonly name: Identifier;
    }
    interface ExportDeclaration extends DeclarationStatement, JSDocContainer {
        readonly kind: SyntaxKind.ExportDeclaration;
        readonly parent: SourceFile | ModuleBlock;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly isTypeOnly: boolean;
        /** Will not be assigned in the case of `export * from "foo";` */
        readonly exportClause?: NamedExportBindings;
        /** If this is not a StringLiteral it will be a grammar error. */
        readonly moduleSpecifier?: Expression;
        readonly assertClause?: AssertClause;
    }
    interface NamedImports extends Node {
        readonly kind: SyntaxKind.NamedImports;
        readonly parent: ImportClause;
        readonly elements: NodeArray<ImportSpecifier>;
    }
    interface NamedExports extends Node {
        readonly kind: SyntaxKind.NamedExports;
        readonly parent: ExportDeclaration;
        readonly elements: NodeArray<ExportSpecifier>;
    }
    type NamedImportsOrExports = NamedImports | NamedExports;
    interface ImportSpecifier extends NamedDeclaration {
        readonly kind: SyntaxKind.ImportSpecifier;
        readonly parent: NamedImports;
        readonly propertyName?: Identifier;
        readonly name: Identifier;
        readonly isTypeOnly: boolean;
    }
    interface ExportSpecifier extends NamedDeclaration, JSDocContainer {
        readonly kind: SyntaxKind.ExportSpecifier;
        readonly parent: NamedExports;
        readonly isTypeOnly: boolean;
        readonly propertyName?: Identifier;
        readonly name: Identifier;
    }
    type ImportOrExportSpecifier = ImportSpecifier | ExportSpecifier;
    type TypeOnlyCompatibleAliasDeclaration = ImportClause | ImportEqualsDeclaration | NamespaceImport | ImportOrExportSpecifier | ExportDeclaration | NamespaceExport;
    type TypeOnlyImportDeclaration = ImportClause & {
        readonly isTypeOnly: true;
        readonly name: Identifier;
    } | ImportEqualsDeclaration & {
        readonly isTypeOnly: true;
    } | NamespaceImport & {
        readonly parent: ImportClause & {
            readonly isTypeOnly: true;
        };
    } | ImportSpecifier & ({
        readonly isTypeOnly: true;
    } | {
        readonly parent: NamedImports & {
            readonly parent: ImportClause & {
                readonly isTypeOnly: true;
            };
        };
    });
    type TypeOnlyExportDeclaration = ExportSpecifier & ({
        readonly isTypeOnly: true;
    } | {
        readonly parent: NamedExports & {
            readonly parent: ExportDeclaration & {
                readonly isTypeOnly: true;
            };
        };
    }) | ExportDeclaration & {
        readonly isTypeOnly: true;
    } | NamespaceExport & {
        readonly parent: ExportDeclaration & {
            readonly isTypeOnly: true;
        };
    };
    type TypeOnlyAliasDeclaration = TypeOnlyImportDeclaration | TypeOnlyExportDeclaration;
    /**
     * This is either an `export =` or an `export default` declaration.
     * Unless `isExportEquals` is set, this node was parsed as an `export default`.
     */
    interface ExportAssignment extends DeclarationStatement, JSDocContainer {
        readonly kind: SyntaxKind.ExportAssignment;
        readonly parent: SourceFile;
        readonly modifiers?: NodeArray<ModifierLike>;
        readonly isExportEquals?: boolean;
        readonly expression: Expression;
    }
    interface FileReference extends TextRange {
        fileName: string;
        resolutionMode?: ResolutionMode;
    }
    interface CheckJsDirective extends TextRange {
        enabled: boolean;
    }
    type CommentKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia;
    interface CommentRange extends TextRange {
        hasTrailingNewLine?: boolean;
        kind: CommentKind;
    }
    interface SynthesizedComment extends CommentRange {
        text: string;
        pos: -1;
        end: -1;
        hasLeadingNewline?: boolean;
    }
    interface JSDocTypeExpression extends TypeNode {
        readonly kind: SyntaxKind.JSDocTypeExpression;
        readonly type: TypeNode;
    }
    interface JSDocNameReference extends Node {
        readonly kind: SyntaxKind.JSDocNameReference;
        readonly name: EntityName | JSDocMemberName;
    }
    /** Class#method reference in JSDoc */
    interface JSDocMemberName extends Node {
        readonly kind: SyntaxKind.JSDocMemberName;
        readonly left: EntityName | JSDocMemberName;
        readonly right: Identifier;
    }
    interface JSDocType extends TypeNode {
        _jsDocTypeBrand: any;
    }
    interface JSDocAllType extends JSDocType {
        readonly kind: SyntaxKind.JSDocAllType;
    }
    interface JSDocUnknownType extends JSDocType {
        readonly kind: SyntaxKind.JSDocUnknownType;
    }
    interface JSDocNonNullableType extends JSDocType {
        readonly kind: SyntaxKind.JSDocNonNullableType;
        readonly type: TypeNode;
        readonly postfix: boolean;
    }
    interface JSDocNullableType extends JSDocType {
        readonly kind: SyntaxKind.JSDocNullableType;
        readonly type: TypeNode;
        readonly postfix: boolean;
    }
    interface JSDocOptionalType extends JSDocType {
        readonly kind: SyntaxKind.JSDocOptionalType;
        readonly type: TypeNode;
    }
    interface JSDocFunctionType extends JSDocType, SignatureDeclarationBase, LocalsContainer {
        readonly kind: SyntaxKind.JSDocFunctionType;
    }
    interface JSDocVariadicType extends JSDocType {
        readonly kind: SyntaxKind.JSDocVariadicType;
        readonly type: TypeNode;
    }
    interface JSDocNamepathType extends JSDocType {
        readonly kind: SyntaxKind.JSDocNamepathType;
        readonly type: TypeNode;
    }
    type JSDocTypeReferencingNode = JSDocVariadicType | JSDocOptionalType | JSDocNullableType | JSDocNonNullableType;
    interface JSDoc extends Node {
        readonly kind: SyntaxKind.JSDoc;
        readonly parent: HasJSDoc;
        readonly tags?: NodeArray<JSDocTag>;
        readonly comment?: string | NodeArray<JSDocComment>;
    }
    interface JSDocTag extends Node {
        readonly parent: JSDoc | JSDocTypeLiteral;
        readonly tagName: Identifier;
        readonly comment?: string | NodeArray<JSDocComment>;
    }
    interface JSDocLink extends Node {
        readonly kind: SyntaxKind.JSDocLink;
        readonly name?: EntityName | JSDocMemberName;
        text: string;
    }
    interface JSDocLinkCode extends Node {
        readonly kind: SyntaxKind.JSDocLinkCode;
        readonly name?: EntityName | JSDocMemberName;
        text: string;
    }
    interface JSDocLinkPlain extends Node {
        readonly kind: SyntaxKind.JSDocLinkPlain;
        readonly name?: EntityName | JSDocMemberName;
        text: string;
    }
    type JSDocComment = JSDocText | JSDocLink | JSDocLinkCode | JSDocLinkPlain;
    interface JSDocText extends Node {
        readonly kind: SyntaxKind.JSDocText;
        text: string;
    }
    interface JSDocUnknownTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocTag;
    }
    /**
     * Note that `@extends` is a synonym of `@augments`.
     * Both tags are represented by this interface.
     */
    interface JSDocAugmentsTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocAugmentsTag;
        readonly class: ExpressionWithTypeArguments & {
            readonly expression: Identifier | PropertyAccessEntityNameExpression;
        };
    }
    interface JSDocImplementsTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocImplementsTag;
        readonly class: ExpressionWithTypeArguments & {
            readonly expression: Identifier | PropertyAccessEntityNameExpression;
        };
    }
    interface JSDocAuthorTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocAuthorTag;
    }
    interface JSDocDeprecatedTag extends JSDocTag {
        kind: SyntaxKind.JSDocDeprecatedTag;
    }
    interface JSDocClassTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocClassTag;
    }
    interface JSDocPublicTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocPublicTag;
    }
    interface JSDocPrivateTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocPrivateTag;
    }
    interface JSDocProtectedTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocProtectedTag;
    }
    interface JSDocReadonlyTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocReadonlyTag;
    }
    interface JSDocOverrideTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocOverrideTag;
    }
    interface JSDocEnumTag extends JSDocTag, Declaration, LocalsContainer {
        readonly kind: SyntaxKind.JSDocEnumTag;
        readonly parent: JSDoc;
        readonly typeExpression: JSDocTypeExpression;
    }
    interface JSDocThisTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocThisTag;
        readonly typeExpression: JSDocTypeExpression;
    }
    interface JSDocTemplateTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocTemplateTag;
        readonly constraint: JSDocTypeExpression | undefined;
        readonly typeParameters: NodeArray<TypeParameterDeclaration>;
    }
    interface JSDocSeeTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocSeeTag;
        readonly name?: JSDocNameReference;
    }
    interface JSDocReturnTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocReturnTag;
        readonly typeExpression?: JSDocTypeExpression;
    }
    interface JSDocTypeTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocTypeTag;
        readonly typeExpression: JSDocTypeExpression;
    }
    interface JSDocTypedefTag extends JSDocTag, NamedDeclaration, LocalsContainer {
        readonly kind: SyntaxKind.JSDocTypedefTag;
        readonly parent: JSDoc;
        readonly fullName?: JSDocNamespaceDeclaration | Identifier;
        readonly name?: Identifier;
        readonly typeExpression?: JSDocTypeExpression | JSDocTypeLiteral;
    }
    interface JSDocCallbackTag extends JSDocTag, NamedDeclaration, LocalsContainer {
        readonly kind: SyntaxKind.JSDocCallbackTag;
        readonly parent: JSDoc;
        readonly fullName?: JSDocNamespaceDeclaration | Identifier;
        readonly name?: Identifier;
        readonly typeExpression: JSDocSignature;
    }
    interface JSDocOverloadTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocOverloadTag;
        readonly parent: JSDoc;
        readonly typeExpression: JSDocSignature;
    }
    interface JSDocThrowsTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocThrowsTag;
        readonly typeExpression?: JSDocTypeExpression;
    }
    interface JSDocSignature extends JSDocType, Declaration, JSDocContainer, LocalsContainer {
        readonly kind: SyntaxKind.JSDocSignature;
        readonly typeParameters?: readonly JSDocTemplateTag[];
        readonly parameters: readonly JSDocParameterTag[];
        readonly type: JSDocReturnTag | undefined;
    }
    interface JSDocPropertyLikeTag extends JSDocTag, Declaration {
        readonly parent: JSDoc;
        readonly name: EntityName;
        readonly typeExpression?: JSDocTypeExpression;
        /** Whether the property name came before the type -- non-standard for JSDoc, but Typescript-like */
        readonly isNameFirst: boolean;
        readonly isBracketed: boolean;
    }
    interface JSDocPropertyTag extends JSDocPropertyLikeTag {
        readonly kind: SyntaxKind.JSDocPropertyTag;
    }
    interface JSDocParameterTag extends JSDocPropertyLikeTag {
        readonly kind: SyntaxKind.JSDocParameterTag;
    }
    interface JSDocTypeLiteral extends JSDocType, Declaration {
        readonly kind: SyntaxKind.JSDocTypeLiteral;
        readonly jsDocPropertyTags?: readonly JSDocPropertyLikeTag[];
        /** If true, then this type literal represents an *array* of its type. */
        readonly isArrayType: boolean;
    }
    interface JSDocSatisfiesTag extends JSDocTag {
        readonly kind: SyntaxKind.JSDocSatisfiesTag;
        readonly typeExpression: JSDocTypeExpression;
    }
    enum FlowFlags {
        Unreachable = 1,
        Start = 2,
        BranchLabel = 4,
        LoopLabel = 8,
        Assignment = 16,
        TrueCondition = 32,
        FalseCondition = 64,
        SwitchClause = 128,
        ArrayMutation = 256,
        Call = 512,
        ReduceLabel = 1024,
        Referenced = 2048,
        Shared = 4096,
        Label = 12,
        Condition = 96
    }
    type FlowNode = FlowStart | FlowLabel | FlowAssignment | FlowCondition | FlowSwitchClause | FlowArrayMutation | FlowCall | FlowReduceLabel;
    interface FlowNodeBase {
        flags: FlowFlags;
        id?: number;
    }
    interface FlowStart extends FlowNodeBase {
        node?: FunctionExpression | ArrowFunction | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration;
    }
    interface FlowLabel extends FlowNodeBase {
        antecedents: FlowNode[] | undefined;
    }
    interface FlowAssignment extends FlowNodeBase {
        node: Expression | VariableDeclaration | BindingElement;
        antecedent: FlowNode;
    }
    interface FlowCall extends FlowNodeBase {
        node: CallExpression;
        antecedent: FlowNode;
    }
    interface FlowCondition extends FlowNodeBase {
        node: Expression;
        antecedent: FlowNode;
    }
    interface FlowSwitchClause extends FlowNodeBase {
        switchStatement: SwitchStatement;
        clauseStart: number;
        clauseEnd: number;
        antecedent: FlowNode;
    }
    interface FlowArrayMutation extends FlowNodeBase {
        node: CallExpression | BinaryExpression;
        antecedent: FlowNode;
    }
    interface FlowReduceLabel extends FlowNodeBase {
        target: FlowLabel;
        antecedents: FlowNode[];
        antecedent: FlowNode;
    }
    type FlowType = Type | IncompleteType;
    interface IncompleteType {
        flags: TypeFlags | 0;
        type: Type;
    }
    interface AmdDependency {
        path: string;
        name?: string;
    }
    /**
     * Subset of properties from SourceFile that are used in multiple utility functions
     */
    interface SourceFileLike {
        readonly text: string;
    }
    interface SourceFileLike {
        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
    }
    type ResolutionMode = ModuleKind.ESNext | ModuleKind.CommonJS | undefined;
    interface SourceFile extends Declaration, LocalsContainer {
        readonly kind: SyntaxKind.SourceFile;
        readonly statements: NodeArray<Statement>;
        readonly endOfFileToken: Token<SyntaxKind.EndOfFileToken>;
        fileName: string;
        text: string;
        amdDependencies: readonly AmdDependency[];
        moduleName?: string;
        referencedFiles: readonly FileReference[];
        typeReferenceDirectives: readonly FileReference[];
        libReferenceDirectives: readonly FileReference[];
        languageVariant: LanguageVariant;
        isDeclarationFile: boolean;
        /**
         * lib.d.ts should have a reference comment like
         *
         *  /// <reference no-default-lib="true"/>
         *
         * If any other file has this comment, it signals not to include lib.d.ts
         * because this containing file is intended to act as a default library.
         */
        hasNoDefaultLib: boolean;
        languageVersion: ScriptTarget;
        /**
         * When `module` is `Node16` or `NodeNext`, this field controls whether the
         * source file in question is an ESNext-output-format file, or a CommonJS-output-format
         * module. This is derived by the module resolver as it looks up the file, since
         * it is derived from either the file extension of the module, or the containing
         * `package.json` context, and affects both checking and emit.
         *
         * It is _public_ so that (pre)transformers can set this field,
         * since it switches the builtin `node` module transform. Generally speaking, if unset,
         * the field is treated as though it is `ModuleKind.CommonJS`.
         *
         * Note that this field is only set by the module resolution process when
         * `moduleResolution` is `Node16` or `NodeNext`, which is implied by the `module` setting
         * of `Node16` or `NodeNext`, respectively, but may be overriden (eg, by a `moduleResolution`
         * of `node`). If so, this field will be unset and source files will be considered to be
         * CommonJS-output-format by the node module transformer and type checker, regardless of extension or context.
         */
        impliedNodeFormat?: ResolutionMode;
    }
    interface SourceFile {
        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
        getLineEndOfPosition(pos: number): number;
        getLineStarts(): readonly number[];
        getPositionOfLineAndCharacter(line: number, character: number): number;
        update(newText: string, textChangeRange: TextChangeRange): SourceFile;
    }
    interface Bundle extends Node {
        readonly kind: SyntaxKind.Bundle;
        /** @deprecated */ readonly prepends: readonly (InputFiles | UnparsedSource)[];
        readonly sourceFiles: readonly SourceFile[];
    }
    /** @deprecated */
    interface InputFiles extends Node {
        readonly kind: SyntaxKind.InputFiles;
        javascriptPath?: string;
        javascriptText: string;
        javascriptMapPath?: string;
        javascriptMapText?: string;
        declarationPath?: string;
        declarationText: string;
        declarationMapPath?: string;
        declarationMapText?: string;
    }
    /** @deprecated */
    interface UnparsedSource extends Node {
        readonly kind: SyntaxKind.UnparsedSource;
        fileName: string;
        text: string;
        readonly prologues: readonly UnparsedPrologue[];
        helpers: readonly UnscopedEmitHelper[] | undefined;
        referencedFiles: readonly FileReference[];
        typeReferenceDirectives: readonly FileReference[] | undefined;
        libReferenceDirectives: readonly FileReference[];
        hasNoDefaultLib?: boolean;
        sourceMapPath?: string;
        sourceMapText?: string;
        readonly syntheticReferences?: readonly UnparsedSyntheticReference[];
        readonly texts: readonly UnparsedSourceText[];
    }
    /** @deprecated */
    type UnparsedSourceText = UnparsedPrepend | UnparsedTextLike;
    /** @deprecated */
    type UnparsedNode = UnparsedPrologue | UnparsedSourceText | UnparsedSyntheticReference;
    /** @deprecated */
    interface UnparsedSection extends Node {
        readonly kind: SyntaxKind;
        readonly parent: UnparsedSource;
        readonly data?: string;
    }
    /** @deprecated */
    interface UnparsedPrologue extends UnparsedSection {
        readonly kind: SyntaxKind.UnparsedPrologue;
        readonly parent: UnparsedSource;
        readonly data: string;
    }
    /** @deprecated */
    interface UnparsedPrepend extends UnparsedSection {
        readonly kind: SyntaxKind.UnparsedPrepend;
        readonly parent: UnparsedSource;
        readonly data: string;
        readonly texts: readonly UnparsedTextLike[];
    }
    /** @deprecated */
    interface UnparsedTextLike extends UnparsedSection {
        readonly kind: SyntaxKind.UnparsedText | SyntaxKind.UnparsedInternalText;
        readonly parent: UnparsedSource;
    }
    /** @deprecated */
    interface UnparsedSyntheticReference extends UnparsedSection {
        readonly kind: SyntaxKind.UnparsedSyntheticReference;
        readonly parent: UnparsedSource;
    }
    interface JsonSourceFile extends SourceFile {
        readonly statements: NodeArray<JsonObjectExpressionStatement>;
    }
    interface TsConfigSourceFile extends JsonSourceFile {
        extendedSourceFiles?: string[];
    }
    interface JsonMinusNumericLiteral extends PrefixUnaryExpression {
        readonly kind: SyntaxKind.PrefixUnaryExpression;
        readonly operator: SyntaxKind.MinusToken;
        readonly operand: NumericLiteral;
    }
    type JsonObjectExpression = ObjectLiteralExpression | ArrayLiteralExpression | JsonMinusNumericLiteral | NumericLiteral | StringLiteral | BooleanLiteral | NullLiteral;
    interface JsonObjectExpressionStatement extends ExpressionStatement {
        readonly expression: JsonObjectExpression;
    }
    interface ScriptReferenceHost {
        getCompilerOptions(): CompilerOptions;
        getSourceFile(fileName: string): SourceFile | undefined;
        getSourceFileByPath(path: Path): SourceFile | undefined;
        getCurrentDirectory(): string;
    }
    interface ParseConfigHost {
        useCaseSensitiveFileNames: boolean;
        readDirectory(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[], depth?: number): readonly string[];
        /**
         * Gets a value indicating whether the specified path exists and is a file.
         * @param path The path to test.
         */
        fileExists(path: string): boolean;
        readFile(path: string): string | undefined;
        trace?(s: string): void;
    }
    /**
     * Branded string for keeping track of when we've turned an ambiguous path
     * specified like "./blah" to an absolute path to an actual
     * tsconfig file, e.g. "/root/blah/tsconfig.json"
     */
    type ResolvedConfigFileName = string & {
        _isResolvedConfigFileName: never;
    };
    interface WriteFileCallbackData {
    }
    type WriteFileCallback = (fileName: string, text: string, writeByteOrderMark: boolean, onError?: (message: string) => void, sourceFiles?: readonly SourceFile[], data?: WriteFileCallbackData) => void;
    class OperationCanceledException {
    }
    interface CancellationToken {
        isCancellationRequested(): boolean;
        /** @throws OperationCanceledException if isCancellationRequested is true */
        throwIfCancellationRequested(): void;
    }
    interface Program extends ScriptReferenceHost {
        getCurrentDirectory(): string;
        /**
         * Get a list of root file names that were passed to a 'createProgram'
         */
        getRootFileNames(): readonly string[];
        /**
         * Get a list of files in the program
         */
        getSourceFiles(): readonly SourceFile[];
        /**
         * Emits the JavaScript and declaration files.  If targetSourceFile is not specified, then
         * the JavaScript and declaration files will be produced for all the files in this program.
         * If targetSourceFile is specified, then only the JavaScript and declaration for that
         * specific file will be generated.
         *
         * If writeFile is not specified then the writeFile callback from the compiler host will be
         * used for writing the JavaScript and declaration files.  Otherwise, the writeFile parameter
         * will be invoked when writing the JavaScript and declaration files.
         */
        emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;
        getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
        getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
        getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
        /** The first time this is called, it will return global diagnostics (no location). */
        getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
        getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
        getConfigFileParsingDiagnostics(): readonly Diagnostic[];
        /**
         * Gets a type checker that can be used to semantically analyze source files in the program.
         */
        getTypeChecker(): TypeChecker;
        getNodeCount(): number;
        getIdentifierCount(): number;
        getSymbolCount(): number;
        getTypeCount(): number;
        getInstantiationCount(): number;
        getRelationCacheSizes(): {
            assignable: number;
            identity: number;
            subtype: number;
            strictSubtype: number;
        };
        isSourceFileFromExternalLibrary(file: SourceFile): boolean;
        isSourceFileDefaultLibrary(file: SourceFile): boolean;
        getProjectReferences(): readonly ProjectReference[] | undefined;
        getResolvedProjectReferences(): readonly (ResolvedProjectReference | undefined)[] | undefined;
    }
    interface ResolvedProjectReference {
        commandLine: ParsedCommandLine;
        sourceFile: SourceFile;
        references?: readonly (ResolvedProjectReference | undefined)[];
    }
    type CustomTransformerFactory = (context: TransformationContext) => CustomTransformer;
    interface CustomTransformer {
        transformSourceFile(node: SourceFile): SourceFile;
        transformBundle(node: Bundle): Bundle;
    }
    interface CustomTransformers {
        /** Custom transformers to evaluate before built-in .js transformations. */
        before?: (TransformerFactory<SourceFile> | CustomTransformerFactory)[];
        /** Custom transformers to evaluate after built-in .js transformations. */
        after?: (TransformerFactory<SourceFile> | CustomTransformerFactory)[];
        /** Custom transformers to evaluate after built-in .d.ts transformations. */
        afterDeclarations?: (TransformerFactory<Bundle | SourceFile> | CustomTransformerFactory)[];
    }
    interface SourceMapSpan {
        /** Line number in the .js file. */
        emittedLine: number;
        /** Column number in the .js file. */
        emittedColumn: number;
        /** Line number in the .ts file. */
        sourceLine: number;
        /** Column number in the .ts file. */
        sourceColumn: number;
        /** Optional name (index into names array) associated with this span. */
        nameIndex?: number;
        /** .ts file (index into sources array) associated with this span */
        sourceIndex: number;
    }
    /** Return code used by getEmitOutput function to indicate status of the function */
    enum ExitStatus {
        Success = 0,
        DiagnosticsPresent_OutputsSkipped = 1,
        DiagnosticsPresent_OutputsGenerated = 2,
        InvalidProject_OutputsSkipped = 3,
        ProjectReferenceCycle_OutputsSkipped = 4
    }
    interface EmitResult {
        emitSkipped: boolean;
        /** Contains declaration emit diagnostics */
        diagnostics: readonly Diagnostic[];
        emittedFiles?: string[];
    }
    interface TypeChecker {
        getTypeOfSymbolAtLocation(symbol: Symbol, node: Node): Type;
        getTypeOfSymbol(symbol: Symbol): Type;
        getDeclaredTypeOfSymbol(symbol: Symbol): Type;
        getPropertiesOfType(type: Type): Symbol[];
        getPropertyOfType(type: Type, propertyName: string): Symbol | undefined;
        getPrivateIdentifierPropertyOfType(leftType: Type, name: string, location: Node): Symbol | undefined;
        getIndexInfoOfType(type: Type, kind: IndexKind): IndexInfo | undefined;
        getIndexInfosOfType(type: Type): readonly IndexInfo[];
        getIndexInfosOfIndexSymbol: (indexSymbol: Symbol) => IndexInfo[];
        getSignaturesOfType(type: Type, kind: SignatureKind): readonly Signature[];
        getIndexTypeOfType(type: Type, kind: IndexKind): Type | undefined;
        getBaseTypes(type: InterfaceType): BaseType[];
        getBaseTypeOfLiteralType(type: Type): Type;
        getWidenedType(type: Type): Type;
        getReturnTypeOfSignature(signature: Signature): Type;
        getNullableType(type: Type, flags: TypeFlags): Type;
        getNonNullableType(type: Type): Type;
        getTypeArguments(type: TypeReference): readonly Type[];
        /** Note that the resulting nodes cannot be checked. */
        typeToTypeNode(type: Type, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): TypeNode | undefined;
        /** Note that the resulting nodes cannot be checked. */
        signatureToSignatureDeclaration(signature: Signature, kind: SyntaxKind, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): SignatureDeclaration & {
            typeArguments?: NodeArray<TypeNode>;
        } | undefined;
        /** Note that the resulting nodes cannot be checked. */
        indexInfoToIndexSignatureDeclaration(indexInfo: IndexInfo, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): IndexSignatureDeclaration | undefined;
        /** Note that the resulting nodes cannot be checked. */
        symbolToEntityName(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): EntityName | undefined;
        /** Note that the resulting nodes cannot be checked. */
        symbolToExpression(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): Expression | undefined;
        /** Note that the resulting nodes cannot be checked. */
        symbolToTypeParameterDeclarations(symbol: Symbol, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): NodeArray<TypeParameterDeclaration> | undefined;
        /** Note that the resulting nodes cannot be checked. */
        symbolToParameterDeclaration(symbol: Symbol, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): ParameterDeclaration | undefined;
        /** Note that the resulting nodes cannot be checked. */
        typeParameterToDeclaration(parameter: TypeParameter, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): TypeParameterDeclaration | undefined;
        getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[];
        getSymbolAtLocation(node: Node): Symbol | undefined;
        getSymbolsOfParameterPropertyDeclaration(parameter: ParameterDeclaration, parameterName: string): Symbol[];
        /**
         * The function returns the value (local variable) symbol of an identifier in the short-hand property assignment.
         * This is necessary as an identifier in short-hand property assignment can contains two meaning: property name and property value.
         */
        getShorthandAssignmentValueSymbol(location: Node | undefined): Symbol | undefined;
        getExportSpecifierLocalTargetSymbol(location: ExportSpecifier | Identifier): Symbol | undefined;
        /**
         * If a symbol is a local symbol with an associated exported symbol, returns the exported symbol.
         * Otherwise returns its input.
         * For example, at `export type T = number;`:
         *     - `getSymbolAtLocation` at the location `T` will return the exported symbol for `T`.
         *     - But the result of `getSymbolsInScope` will contain the *local* symbol for `T`, not the exported symbol.
         *     - Calling `getExportSymbolOfSymbol` on that local symbol will return the exported symbol.
         */
        getExportSymbolOfSymbol(symbol: Symbol): Symbol;
        getPropertySymbolOfDestructuringAssignment(location: Identifier): Symbol | undefined;
        getTypeOfAssignmentPattern(pattern: AssignmentPattern): Type;
        getTypeAtLocation(node: Node): Type;
        getTypeFromTypeNode(node: TypeNode): Type;
        signatureToString(signature: Signature, enclosingDeclaration?: Node, flags?: TypeFormatFlags, kind?: SignatureKind): string;
        typeToString(type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;
        symbolToString(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags): string;
        typePredicateToString(predicate: TypePredicate, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;
        getFullyQualifiedName(symbol: Symbol): string;
        getAugmentedPropertiesOfType(type: Type): Symbol[];
        getRootSymbols(symbol: Symbol): readonly Symbol[];
        getSymbolOfExpando(node: Node, allowDeclaration: boolean): Symbol | undefined;
        getContextualType(node: Expression): Type | undefined;
        /**
         * returns unknownSignature in the case of an error.
         * returns undefined if the node is not valid.
         * @param argumentCount Apparent number of arguments, passed in case of a possibly incomplete call. This should come from an ArgumentListInfo. See `signatureHelp.ts`.
         */
        getResolvedSignature(node: CallLikeExpression, candidatesOutArray?: Signature[], argumentCount?: number): Signature | undefined;
        getSignatureFromDeclaration(declaration: SignatureDeclaration): Signature | undefined;
        isImplementationOfOverload(node: SignatureDeclaration): boolean | undefined;
        isUndefinedSymbol(symbol: Symbol): boolean;
        isArgumentsSymbol(symbol: Symbol): boolean;
        isUnknownSymbol(symbol: Symbol): boolean;
        getConstantValue(node: EnumMember | PropertyAccessExpression | ElementAccessExpression): string | number | undefined;
        isValidPropertyAccess(node: PropertyAccessExpression | QualifiedName | ImportTypeNode, propertyName: string): boolean;
        /** Follow all aliases to get the original symbol. */
        getAliasedSymbol(symbol: Symbol): Symbol;
        /** Follow a *single* alias to get the immediately aliased symbol. */
        getImmediateAliasedSymbol(symbol: Symbol): Symbol | undefined;
        getExportsOfModule(moduleSymbol: Symbol): Symbol[];
        getJsxIntrinsicTagNamesAt(location: Node): Symbol[];
        isOptionalParameter(node: ParameterDeclaration): boolean;
        getAmbientModules(): Symbol[];
        tryGetMemberInModuleExports(memberName: string, moduleSymbol: Symbol): Symbol | undefined;
        getApparentType(type: Type): Type;
        getBaseConstraintOfType(type: Type): Type | undefined;
        getDefaultFromTypeParameter(type: Type): Type | undefined;
        /**
         * True if this type is the `Array` or `ReadonlyArray` type from lib.d.ts.
         * This function will _not_ return true if passed a type which
         * extends `Array` (for example, the TypeScript AST's `NodeArray` type).
         */
        isArrayType(type: Type): boolean;
        /**
         * True if this type is a tuple type. This function will _not_ return true if
         * passed a type which extends from a tuple.
         */
        isTupleType(type: Type): boolean;
        /**
         * True if this type is assignable to `ReadonlyArray<any>`.
         */
        isArrayLikeType(type: Type): boolean;
        getTypePredicateOfSignature(signature: Signature): TypePredicate | undefined;
        /**
         * Depending on the operation performed, it may be appropriate to throw away the checker
         * if the cancellation token is triggered. Typically, if it is used for error checking
         * and the operation is cancelled, then it should be discarded, otherwise it is safe to keep.
         */
        runWithCancellationToken<T>(token: CancellationToken, cb: (checker: TypeChecker) => T): T;
    }
    enum NodeBuilderFlags {
        None = 0,
        NoTruncation = 1,
        WriteArrayAsGenericType = 2,
        GenerateNamesForShadowedTypeParams = 4,
        UseStructuralFallback = 8,
        ForbidIndexedAccessSymbolReferences = 16,
        WriteTypeArgumentsOfSignature = 32,
        UseFullyQualifiedType = 64,
        UseOnlyExternalAliasing = 128,
        SuppressAnyReturnType = 256,
        WriteTypeParametersInQualifiedName = 512,
        MultilineObjectLiterals = 1024,
        WriteClassExpressionAsTypeLiteral = 2048,
        UseTypeOfFunction = 4096,
        OmitParameterModifiers = 8192,
        UseAliasDefinedOutsideCurrentScope = 16384,
        UseSingleQuotesForStringLiteralType = 268435456,
        NoTypeReduction = 536870912,
        OmitThisParameter = 33554432,
        AllowThisInObjectLiteral = 32768,
        AllowQualifiedNameInPlaceOfIdentifier = 65536,
        AllowAnonymousIdentifier = 131072,
        AllowEmptyUnionOrIntersection = 262144,
        AllowEmptyTuple = 524288,
        AllowUniqueESSymbolType = 1048576,
        AllowEmptyIndexInfoType = 2097152,
        AllowNodeModulesRelativePaths = 67108864,
        IgnoreErrors = 70221824,
        InObjectTypeLiteral = 4194304,
        InTypeAlias = 8388608,
        InInitialEntityName = 16777216
    }
    enum TypeFormatFlags {
        None = 0,
        NoTruncation = 1,
        WriteArrayAsGenericType = 2,
        UseStructuralFallback = 8,
        WriteTypeArgumentsOfSignature = 32,
        UseFullyQualifiedType = 64,
        SuppressAnyReturnType = 256,
        MultilineObjectLiterals = 1024,
        WriteClassExpressionAsTypeLiteral = 2048,
        UseTypeOfFunction = 4096,
        OmitParameterModifiers = 8192,
        UseAliasDefinedOutsideCurrentScope = 16384,
        UseSingleQuotesForStringLiteralType = 268435456,
        NoTypeReduction = 536870912,
        OmitThisParameter = 33554432,
        AllowUniqueESSymbolType = 1048576,
        AddUndefined = 131072,
        WriteArrowStyleSignature = 262144,
        InArrayType = 524288,
        InElementType = 2097152,
        InFirstTypeArgument = 4194304,
        InTypeAlias = 8388608,
        NodeBuilderFlagsMask = 848330091
    }
    enum SymbolFormatFlags {
        None = 0,
        WriteTypeParametersOrArguments = 1,
        UseOnlyExternalAliasing = 2,
        AllowAnyNodeKind = 4,
        UseAliasDefinedOutsideCurrentScope = 8
    }
    enum TypePredicateKind {
        This = 0,
        Identifier = 1,
        AssertsThis = 2,
        AssertsIdentifier = 3
    }
    interface TypePredicateBase {
        kind: TypePredicateKind;
        type: Type | undefined;
    }
    interface ThisTypePredicate extends TypePredicateBase {
        kind: TypePredicateKind.This;
        parameterName: undefined;
        parameterIndex: undefined;
        type: Type;
    }
    interface IdentifierTypePredicate extends TypePredicateBase {
        kind: TypePredicateKind.Identifier;
        parameterName: string;
        parameterIndex: number;
        type: Type;
    }
    interface AssertsThisTypePredicate extends TypePredicateBase {
        kind: TypePredicateKind.AssertsThis;
        parameterName: undefined;
        parameterIndex: undefined;
        type: Type | undefined;
    }
    interface AssertsIdentifierTypePredicate extends TypePredicateBase {
        kind: TypePredicateKind.AssertsIdentifier;
        parameterName: string;
        parameterIndex: number;
        type: Type | undefined;
    }
    type TypePredicate = ThisTypePredicate | IdentifierTypePredicate | AssertsThisTypePredicate | AssertsIdentifierTypePredicate;
    enum SymbolFlags {
        None = 0,
        FunctionScopedVariable = 1,
        BlockScopedVariable = 2,
        Property = 4,
        EnumMember = 8,
        Function = 16,
        Class = 32,
        Interface = 64,
        ConstEnum = 128,
        RegularEnum = 256,
        ValueModule = 512,
        NamespaceModule = 1024,
        TypeLiteral = 2048,
        ObjectLiteral = 4096,
        Method = 8192,
        Constructor = 16384,
        GetAccessor = 32768,
        SetAccessor = 65536,
        Signature = 131072,
        TypeParameter = 262144,
        TypeAlias = 524288,
        ExportValue = 1048576,
        Alias = 2097152,
        Prototype = 4194304,
        ExportStar = 8388608,
        Optional = 16777216,
        Transient = 33554432,
        Assignment = 67108864,
        ModuleExports = 134217728,
        Enum = 384,
        Variable = 3,
        Value = 111551,
        Type = 788968,
        Namespace = 1920,
        Module = 1536,
        Accessor = 98304,
        FunctionScopedVariableExcludes = 111550,
        BlockScopedVariableExcludes = 111551,
        ParameterExcludes = 111551,
        PropertyExcludes = 0,
        EnumMemberExcludes = 900095,
        FunctionExcludes = 110991,
        ClassExcludes = 899503,
        InterfaceExcludes = 788872,
        RegularEnumExcludes = 899327,
        ConstEnumExcludes = 899967,
        ValueModuleExcludes = 110735,
        NamespaceModuleExcludes = 0,
        MethodExcludes = 103359,
        GetAccessorExcludes = 46015,
        SetAccessorExcludes = 78783,
        AccessorExcludes = 13247,
        TypeParameterExcludes = 526824,
        TypeAliasExcludes = 788968,
        AliasExcludes = 2097152,
        ModuleMember = 2623475,
        ExportHasLocal = 944,
        BlockScoped = 418,
        PropertyOrAccessor = 98308,
        ClassMember = 106500
    }
    interface Symbol {
        flags: SymbolFlags;
        escapedName: __String;
        declarations?: Declaration[];
        valueDeclaration?: Declaration;
        members?: SymbolTable;
        exports?: SymbolTable;
        globalExports?: SymbolTable;
    }
    interface Symbol {
        readonly name: string;
        getFlags(): SymbolFlags;
        getEscapedName(): __String;
        getName(): string;
        getDeclarations(): Declaration[] | undefined;
        getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];
        getJsDocTags(checker?: TypeChecker): JSDocTagInfo[];
    }
    enum InternalSymbolName {
        Call = "__call",
        Constructor = "__constructor",
        New = "__new",
        Index = "__index",
        ExportStar = "__export",
        Global = "__global",
        Missing = "__missing",
        Type = "__type",
        Object = "__object",
        JSXAttributes = "__jsxAttributes",
        Class = "__class",
        Function = "__function",
        Computed = "__computed",
        Resolving = "__resolving__",
        ExportEquals = "export=",
        Default = "default",
        This = "this"
    }
    /**
     * This represents a string whose leading underscore have been escaped by adding extra leading underscores.
     * The shape of this brand is rather unique compared to others we've used.
     * Instead of just an intersection of a string and an object, it is that union-ed
     * with an intersection of void and an object. This makes it wholly incompatible
     * with a normal string (which is good, it cannot be misused on assignment or on usage),
     * while still being comparable with a normal string via === (also good) and castable from a string.
     */
    type __String = (string & {
        __escapedIdentifier: void;
    }) | (void & {
        __escapedIdentifier: void;
    }) | InternalSymbolName;
    /** ReadonlyMap where keys are `__String`s. */
    interface ReadonlyUnderscoreEscapedMap<T> extends ReadonlyMap<__String, T> {
    }
    /** Map where keys are `__String`s. */
    interface UnderscoreEscapedMap<T> extends Map<__String, T> {
    }
    /** SymbolTable based on ES6 Map interface. */
    type SymbolTable = UnderscoreEscapedMap<Symbol>;
    enum TypeFlags {
        Any = 1,
        Unknown = 2,
        String = 4,
        Number = 8,
        Boolean = 16,
        Enum = 32,
        BigInt = 64,
        StringLiteral = 128,
        NumberLiteral = 256,
        BooleanLiteral = 512,
        EnumLiteral = 1024,
        BigIntLiteral = 2048,
        ESSymbol = 4096,
        UniqueESSymbol = 8192,
        Void = 16384,
        Undefined = 32768,
        Null = 65536,
        Never = 131072,
        TypeParameter = 262144,
        Object = 524288,
        Union = 1048576,
        Intersection = 2097152,
        Index = 4194304,
        IndexedAccess = 8388608,
        Conditional = 16777216,
        Substitution = 33554432,
        NonPrimitive = 67108864,
        TemplateLiteral = 134217728,
        StringMapping = 268435456,
        Literal = 2944,
        Unit = 109472,
        Freshable = 2976,
        StringOrNumberLiteral = 384,
        PossiblyFalsy = 117724,
        StringLike = 402653316,
        NumberLike = 296,
        BigIntLike = 2112,
        BooleanLike = 528,
        EnumLike = 1056,
        ESSymbolLike = 12288,
        VoidLike = 49152,
        UnionOrIntersection = 3145728,
        StructuredType = 3670016,
        TypeVariable = 8650752,
        InstantiableNonPrimitive = 58982400,
        InstantiablePrimitive = 406847488,
        Instantiable = 465829888,
        StructuredOrInstantiable = 469499904,
        Narrowable = 536624127
    }
    type DestructuringPattern = BindingPattern | ObjectLiteralExpression | ArrayLiteralExpression;
    interface Type {
        flags: TypeFlags;
        symbol: Symbol;
        pattern?: DestructuringPattern;
        aliasSymbol?: Symbol;
        aliasTypeArguments?: readonly Type[];
    }
    interface Type {
        getFlags(): TypeFlags;
        getSymbol(): Symbol | undefined;
        getProperties(): Symbol[];
        getProperty(propertyName: string): Symbol | undefined;
        getApparentProperties(): Symbol[];
        getCallSignatures(): readonly Signature[];
        getConstructSignatures(): readonly Signature[];
        getStringIndexType(): Type | undefined;
        getNumberIndexType(): Type | undefined;
        getBaseTypes(): BaseType[] | undefined;
        getNonNullableType(): Type;
        getConstraint(): Type | undefined;
        getDefault(): Type | undefined;
        isUnion(): this is UnionType;
        isIntersection(): this is IntersectionType;
        isUnionOrIntersection(): this is UnionOrIntersectionType;
        isLiteral(): this is LiteralType;
        isStringLiteral(): this is StringLiteralType;
        isNumberLiteral(): this is NumberLiteralType;
        isTypeParameter(): this is TypeParameter;
        isClassOrInterface(): this is InterfaceType;
        isClass(): this is InterfaceType;
        isIndexType(): this is IndexType;
    }
    interface FreshableType extends Type {
        freshType: FreshableType;
        regularType: FreshableType;
    }
    interface LiteralType extends FreshableType {
        value: string | number | PseudoBigInt;
    }
    interface UniqueESSymbolType extends Type {
        symbol: Symbol;
        escapedName: __String;
    }
    interface StringLiteralType extends LiteralType {
        value: string;
    }
    interface NumberLiteralType extends LiteralType {
        value: number;
    }
    interface BigIntLiteralType extends LiteralType {
        value: PseudoBigInt;
    }
    interface EnumType extends FreshableType {
    }
    enum ObjectFlags {
        None = 0,
        Class = 1,
        Interface = 2,
        Reference = 4,
        Tuple = 8,
        Anonymous = 16,
        Mapped = 32,
        Instantiated = 64,
        ObjectLiteral = 128,
        EvolvingArray = 256,
        ObjectLiteralPatternWithComputedProperties = 512,
        ReverseMapped = 1024,
        JsxAttributes = 2048,
        JSLiteral = 4096,
        FreshLiteral = 8192,
        ArrayLiteral = 16384,
        ClassOrInterface = 3,
        ContainsSpread = 2097152,
        ObjectRestType = 4194304,
        InstantiationExpressionType = 8388608
    }
    interface ObjectType extends Type {
        objectFlags: ObjectFlags;
    }
    /** Class and interface types (ObjectFlags.Class and ObjectFlags.Interface). */
    interface InterfaceType extends ObjectType {
        typeParameters: TypeParameter[] | undefined;
        outerTypeParameters: TypeParameter[] | undefined;
        localTypeParameters: TypeParameter[] | undefined;
        thisType: TypeParameter | undefined;
    }
    type BaseType = ObjectType | IntersectionType | TypeVariable;
    interface InterfaceTypeWithDeclaredMembers extends InterfaceType {
        declaredProperties: Symbol[];
        declaredCallSignatures: Signature[];
        declaredConstructSignatures: Signature[];
        declaredIndexInfos: IndexInfo[];
    }
    /**
     * Type references (ObjectFlags.Reference). When a class or interface has type parameters or
     * a "this" type, references to the class or interface are made using type references. The
     * typeArguments property specifies the types to substitute for the type parameters of the
     * class or interface and optionally includes an extra element that specifies the type to
     * substitute for "this" in the resulting instantiation. When no extra argument is present,
     * the type reference itself is substituted for "this". The typeArguments property is undefined
     * if the class or interface has no type parameters and the reference isn't specifying an
     * explicit "this" argument.
     */
    interface TypeReference extends ObjectType {
        target: GenericType;
        node?: TypeReferenceNode | ArrayTypeNode | TupleTypeNode;
    }
    interface TypeReference {
        typeArguments?: readonly Type[];
    }
    interface DeferredTypeReference extends TypeReference {
    }
    interface GenericType extends InterfaceType, TypeReference {
    }
    enum ElementFlags {
        Required = 1,
        Optional = 2,
        Rest = 4,
        Variadic = 8,
        Fixed = 3,
        Variable = 12,
        NonRequired = 14,
        NonRest = 11
    }
    interface TupleType extends GenericType {
        elementFlags: readonly ElementFlags[];
        /** Number of required or variadic elements */
        minLength: number;
        /** Number of initial required or optional elements */
        fixedLength: number;
        /** True if tuple has any rest or variadic elements */
        hasRestElement: boolean;
        combinedFlags: ElementFlags;
        readonly: boolean;
        labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration)[];
    }
    interface TupleTypeReference extends TypeReference {
        target: TupleType;
    }
    interface UnionOrIntersectionType extends Type {
        types: Type[];
    }
    interface UnionType extends UnionOrIntersectionType {
    }
    interface IntersectionType extends UnionOrIntersectionType {
    }
    type StructuredType = ObjectType | UnionType | IntersectionType;
    interface EvolvingArrayType extends ObjectType {
        elementType: Type;
        finalArrayType?: Type;
    }
    interface InstantiableType extends Type {
    }
    interface TypeParameter extends InstantiableType {
    }
    interface IndexedAccessType extends InstantiableType {
        objectType: Type;
        indexType: Type;
        constraint?: Type;
        simplifiedForReading?: Type;
        simplifiedForWriting?: Type;
    }
    type TypeVariable = TypeParameter | IndexedAccessType;
    interface IndexType extends InstantiableType {
        type: InstantiableType | UnionOrIntersectionType;
    }
    interface ConditionalRoot {
        node: ConditionalTypeNode;
        checkType: Type;
        extendsType: Type;
        isDistributive: boolean;
        inferTypeParameters?: TypeParameter[];
        outerTypeParameters?: TypeParameter[];
        instantiations?: Map<string, Type>;
        aliasSymbol?: Symbol;
        aliasTypeArguments?: Type[];
    }
    interface ConditionalType extends InstantiableType {
        root: ConditionalRoot;
        checkType: Type;
        extendsType: Type;
        resolvedTrueType?: Type;
        resolvedFalseType?: Type;
    }
    interface TemplateLiteralType extends InstantiableType {
        texts: readonly string[];
        types: readonly Type[];
    }
    interface StringMappingType extends InstantiableType {
        symbol: Symbol;
        type: Type;
    }
    interface SubstitutionType extends InstantiableType {
        objectFlags: ObjectFlags;
        baseType: Type;
        constraint: Type;
    }
    enum SignatureKind {
        Call = 0,
        Construct = 1
    }
    interface Signature {
        declaration?: SignatureDeclaration | JSDocSignature;
        typeParameters?: readonly TypeParameter[];
        parameters: readonly Symbol[];
    }
    interface Signature {
        getDeclaration(): SignatureDeclaration;
        getTypeParameters(): TypeParameter[] | undefined;
        getParameters(): Symbol[];
        getTypeParameterAtPosition(pos: number): Type;
        getReturnType(): Type;
        getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];
        getJsDocTags(): JSDocTagInfo[];
    }
    enum IndexKind {
        String = 0,
        Number = 1
    }
    interface IndexInfo {
        keyType: Type;
        type: Type;
        isReadonly: boolean;
        declaration?: IndexSignatureDeclaration;
    }
    enum InferencePriority {
        None = 0,
        NakedTypeVariable = 1,
        SpeculativeTuple = 2,
        SubstituteSource = 4,
        HomomorphicMappedType = 8,
        PartialHomomorphicMappedType = 16,
        MappedTypeConstraint = 32,
        ContravariantConditional = 64,
        ReturnType = 128,
        LiteralKeyof = 256,
        NoConstraints = 512,
        AlwaysStrict = 1024,
        MaxValue = 2048,
        PriorityImpliesCombination = 416,
        Circularity = -1
    }
    interface FileExtensionInfo {
        extension: string;
        isMixedContent: boolean;
        scriptKind?: ScriptKind;
    }
    interface DiagnosticMessage {
        key: string;
        category: DiagnosticCategory;
        code: number;
        message: string;
        reportsUnnecessary?: {};
        reportsDeprecated?: {};
    }
    /**
     * A linked list of formatted diagnostic messages to be used as part of a multiline message.
     * It is built from the bottom up, leaving the head to be the "main" diagnostic.
     * While it seems that DiagnosticMessageChain is structurally similar to DiagnosticMessage,
     * the difference is that messages are all preformatted in DMC.
     */
    interface DiagnosticMessageChain {
        messageText: string;
        category: DiagnosticCategory;
        code: number;
        next?: DiagnosticMessageChain[];
    }
    interface Diagnostic extends DiagnosticRelatedInformation {
        /** May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic. */
        reportsUnnecessary?: {};
        reportsDeprecated?: {};
        source?: string;
        relatedInformation?: DiagnosticRelatedInformation[];
    }
    interface DiagnosticRelatedInformation {
        category: DiagnosticCategory;
        code: number;
        file: SourceFile | undefined;
        start: number | undefined;
        length: number | undefined;
        messageText: string | DiagnosticMessageChain;
    }
    interface DiagnosticWithLocation extends Diagnostic {
        file: SourceFile;
        start: number;
        length: number;
    }
    enum DiagnosticCategory {
        Warning = 0,
        Error = 1,
        Suggestion = 2,
        Message = 3
    }
    enum ModuleResolutionKind {
        Classic = 1,
        /**
         * @deprecated
         * `NodeJs` was renamed to `Node10` to better reflect the version of Node that it targets.
         * Use the new name or consider switching to a modern module resolution target.
         */
        NodeJs = 2,
        Node10 = 2,
        Node16 = 3,
        NodeNext = 99,
        Bundler = 100
    }
    enum ModuleDetectionKind {
        /**
         * Files with imports, exports and/or import.meta are considered modules
         */
        Legacy = 1,
        /**
         * Legacy, but also files with jsx under react-jsx or react-jsxdev and esm mode files under moduleResolution: node16+
         */
        Auto = 2,
        /**
         * Consider all non-declaration files modules, regardless of present syntax
         */
        Force = 3
    }
    interface PluginImport {
        name: string;
    }
    interface ProjectReference {
        /** A normalized path on disk */
        path: string;
        /** The path as the user originally wrote it */
        originalPath?: string;
        /** True if the output of this reference should be prepended to the output of this project. Only valid for --outFile compilations */
        prepend?: boolean;
        /** True if it is intended that this reference form a circularity */
        circular?: boolean;
    }
    enum WatchFileKind {
        FixedPollingInterval = 0,
        PriorityPollingInterval = 1,
        DynamicPriorityPolling = 2,
        FixedChunkSizePolling = 3,
        UseFsEvents = 4,
        UseFsEventsOnParentDirectory = 5
    }
    enum WatchDirectoryKind {
        UseFsEvents = 0,
        FixedPollingInterval = 1,
        DynamicPriorityPolling = 2,
        FixedChunkSizePolling = 3
    }
    enum PollingWatchKind {
        FixedInterval = 0,
        PriorityInterval = 1,
        DynamicPriority = 2,
        FixedChunkSize = 3
    }
    type CompilerOptionsValue = string | number | boolean | (string | number)[] | string[] | MapLike<string[]> | PluginImport[] | ProjectReference[] | null | undefined;
    interface CompilerOptions {
        allowImportingTsExtensions?: boolean;
        allowJs?: boolean;
        allowArbitraryExtensions?: boolean;
        allowSyntheticDefaultImports?: boolean;
        allowUmdGlobalAccess?: boolean;
        allowUnreachableCode?: boolean;
        allowUnusedLabels?: boolean;
        alwaysStrict?: boolean;
        baseUrl?: string;
        charset?: string;
        checkJs?: boolean;
        customConditions?: string[];
        declaration?: boolean;
        declarationMap?: boolean;
        emitDeclarationOnly?: boolean;
        declarationDir?: string;
        disableSizeLimit?: boolean;
        disableSourceOfProjectReferenceRedirect?: boolean;
        disableSolutionSearching?: boolean;
        disableReferencedProjectLoad?: boolean;
        downlevelIteration?: boolean;
        emitBOM?: boolean;
        emitDecoratorMetadata?: boolean;
        exactOptionalPropertyTypes?: boolean;
        experimentalDecorators?: boolean;
        forceConsistentCasingInFileNames?: boolean;
        ignoreDeprecations?: string;
        importHelpers?: boolean;
        importsNotUsedAsValues?: ImportsNotUsedAsValues;
        inlineSourceMap?: boolean;
        inlineSources?: boolean;
        isolatedModules?: boolean;
        jsx?: JsxEmit;
        keyofStringsOnly?: boolean;
        lib?: string[];
        locale?: string;
        mapRoot?: string;
        maxNodeModuleJsDepth?: number;
        module?: ModuleKind;
        moduleResolution?: ModuleResolutionKind;
        moduleSuffixes?: string[];
        moduleDetection?: ModuleDetectionKind;
        newLine?: NewLineKind;
        noEmit?: boolean;
        noEmitHelpers?: boolean;
        noEmitOnError?: boolean;
        noErrorTruncation?: boolean;
        noFallthroughCasesInSwitch?: boolean;
        noImplicitAny?: boolean;
        noImplicitReturns?: boolean;
        noImplicitThis?: boolean;
        noStrictGenericChecks?: boolean;
        noUnusedLocals?: boolean;
        noUnusedParameters?: boolean;
        noImplicitUseStrict?: boolean;
        noPropertyAccessFromIndexSignature?: boolean;
        assumeChangesOnlyAffectDirectDependencies?: boolean;
        noLib?: boolean;
        noResolve?: boolean;
        noUncheckedIndexedAccess?: boolean;
        out?: string;
        outDir?: string;
        outFile?: string;
        paths?: MapLike<string[]>;
        preserveConstEnums?: boolean;
        noImplicitOverride?: boolean;
        preserveSymlinks?: boolean;
        preserveValueImports?: boolean;
        project?: string;
        reactNamespace?: string;
        jsxFactory?: string;
        jsxFragmentFactory?: string;
        jsxImportSource?: string;
        composite?: boolean;
        incremental?: boolean;
        tsBuildInfoFile?: string;
        removeComments?: boolean;
        resolvePackageJsonExports?: boolean;
        resolvePackageJsonImports?: boolean;
        rootDir?: string;
        rootDirs?: string[];
        skipLibCheck?: boolean;
        skipDefaultLibCheck?: boolean;
        sourceMap?: boolean;
        sourceRoot?: string;
        strict?: boolean;
        strictFunctionTypes?: boolean;
        strictBindCallApply?: boolean;
        strictNullChecks?: boolean;
        strictPropertyInitialization?: boolean;
        stripInternal?: boolean;
        suppressExcessPropertyErrors?: boolean;
        suppressImplicitAnyIndexErrors?: boolean;
        target?: ScriptTarget;
        traceResolution?: boolean;
        useUnknownInCatchVariables?: boolean;
        resolveJsonModule?: boolean;
        types?: string[];
        /** Paths used to compute primary types search locations */
        typeRoots?: string[];
        verbatimModuleSyntax?: boolean;
        esModuleInterop?: boolean;
        useDefineForClassFields?: boolean;
        [option: string]: CompilerOptionsValue | TsConfigSourceFile | undefined;
    }
    interface WatchOptions {
        watchFile?: WatchFileKind;
        watchDirectory?: WatchDirectoryKind;
        fallbackPolling?: PollingWatchKind;
        synchronousWatchDirectory?: boolean;
        excludeDirectories?: string[];
        excludeFiles?: string[];
        [option: string]: CompilerOptionsValue | undefined;
    }
    interface TypeAcquisition {
        enable?: boolean;
        include?: string[];
        exclude?: string[];
        disableFilenameBasedTypeAcquisition?: boolean;
        [option: string]: CompilerOptionsValue | undefined;
    }
    enum ModuleKind {
        None = 0,
        CommonJS = 1,
        AMD = 2,
        UMD = 3,
        System = 4,
        ES2015 = 5,
        ES2020 = 6,
        ES2022 = 7,
        ESNext = 99,
        Node16 = 100,
        NodeNext = 199
    }
    enum JsxEmit {
        None = 0,
        Preserve = 1,
        React = 2,
        ReactNative = 3,
        ReactJSX = 4,
        ReactJSXDev = 5
    }
    enum ImportsNotUsedAsValues {
        Remove = 0,
        Preserve = 1,
        Error = 2
    }
    enum NewLineKind {
        CarriageReturnLineFeed = 0,
        LineFeed = 1
    }
    interface LineAndCharacter {
        /** 0-based. */
        line: number;
        character: number;
    }
    enum ScriptKind {
        Unknown = 0,
        JS = 1,
        JSX = 2,
        TS = 3,
        TSX = 4,
        External = 5,
        JSON = 6,
        /**
         * Used on extensions that doesn't define the ScriptKind but the content defines it.
         * Deferred extensions are going to be included in all project contexts.
         */
        Deferred = 7
    }
    enum ScriptTarget {
        ES3 = 0,
        ES5 = 1,
        ES2015 = 2,
        ES2016 = 3,
        ES2017 = 4,
        ES2018 = 5,
        ES2019 = 6,
        ES2020 = 7,
        ES2021 = 8,
        ES2022 = 9,
        ESNext = 99,
        JSON = 100,
        Latest = 99
    }
    enum LanguageVariant {
        Standard = 0,
        JSX = 1
    }
    /** Either a parsed command line or a parsed tsconfig.json */
    interface ParsedCommandLine {
        options: CompilerOptions;
        typeAcquisition?: TypeAcquisition;
        fileNames: string[];
        projectReferences?: readonly ProjectReference[];
        watchOptions?: WatchOptions;
        raw?: any;
        errors: Diagnostic[];
        wildcardDirectories?: MapLike<WatchDirectoryFlags>;
        compileOnSave?: boolean;
    }
    enum WatchDirectoryFlags {
        None = 0,
        Recursive = 1
    }
    interface CreateProgramOptions {
        rootNames: readonly string[];
        options: CompilerOptions;
        projectReferences?: readonly ProjectReference[];
        host?: CompilerHost;
        oldProgram?: Program;
        configFileParsingDiagnostics?: readonly Diagnostic[];
    }
    interface ModuleResolutionHost {
        fileExists(fileName: string): boolean;
        readFile(fileName: string): string | undefined;
        trace?(s: string): void;
        directoryExists?(directoryName: string): boolean;
        /**
         * Resolve a symbolic link.
         * @see https://nodejs.org/api/fs.html#fs_fs_realpathsync_path_options
         */
        realpath?(path: string): string;
        getCurrentDirectory?(): string;
        getDirectories?(path: string): string[];
        useCaseSensitiveFileNames?: boolean | (() => boolean) | undefined;
    }
    /**
     * Used by services to specify the minimum host area required to set up source files under any compilation settings
     */
    interface MinimalResolutionCacheHost extends ModuleResolutionHost {
        getCompilationSettings(): CompilerOptions;
        getCompilerHost?(): CompilerHost | undefined;
    }
    /**
     * Represents the result of module resolution.
     * Module resolution will pick up tsx/jsx/js files even if '--jsx' and '--allowJs' are turned off.
     * The Program will then filter results based on these flags.
     *
     * Prefer to return a `ResolvedModuleFull` so that the file type does not have to be inferred.
     */
    interface ResolvedModule {
        /** Path of the file the module was resolved to. */
        resolvedFileName: string;
        /** True if `resolvedFileName` comes from `node_modules`. */
        isExternalLibraryImport?: boolean;
        /**
         * True if the original module reference used a .ts extension to refer directly to a .ts file,
         * which should produce an error during checking if emit is enabled.
         */
        resolvedUsingTsExtension?: boolean;
    }
    /**
     * ResolvedModule with an explicitly provided `extension` property.
     * Prefer this over `ResolvedModule`.
     * If changing this, remember to change `moduleResolutionIsEqualTo`.
     */
    interface ResolvedModuleFull extends ResolvedModule {
        /**
         * Extension of resolvedFileName. This must match what's at the end of resolvedFileName.
         * This is optional for backwards-compatibility, but will be added if not provided.
         */
        extension: string;
        packageId?: PackageId;
    }
    /**
     * Unique identifier with a package name and version.
     * If changing this, remember to change `packageIdIsEqual`.
     */
    interface PackageId {
        /**
         * Name of the package.
         * Should not include `@types`.
         * If accessing a non-index file, this should include its name e.g. "foo/bar".
         */
        name: string;
        /**
         * Name of a submodule within this package.
         * May be "".
         */
        subModuleName: string;
        /** Version of the package, e.g. "1.2.3" */
        version: string;
    }
    enum Extension {
        Ts = ".ts",
        Tsx = ".tsx",
        Dts = ".d.ts",
        Js = ".js",
        Jsx = ".jsx",
        Json = ".json",
        TsBuildInfo = ".tsbuildinfo",
        Mjs = ".mjs",
        Mts = ".mts",
        Dmts = ".d.mts",
        Cjs = ".cjs",
        Cts = ".cts",
        Dcts = ".d.cts"
    }
    interface ResolvedModuleWithFailedLookupLocations {
        readonly resolvedModule: ResolvedModuleFull | undefined;
    }
    interface ResolvedTypeReferenceDirective {
        primary: boolean;
        resolvedFileName: string | undefined;
        packageId?: PackageId;
        /** True if `resolvedFileName` comes from `node_modules`. */
        isExternalLibraryImport?: boolean;
    }
    interface ResolvedTypeReferenceDirectiveWithFailedLookupLocations {
        readonly resolvedTypeReferenceDirective: ResolvedTypeReferenceDirective | undefined;
    }
    interface CompilerHost extends ModuleResolutionHost {
        getSourceFile(fileName: string, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;
        getSourceFileByPath?(fileName: string, path: Path, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;
        getCancellationToken?(): CancellationToken;
        getDefaultLibFileName(options: CompilerOptions): string;
        getDefaultLibLocation?(): string;
        writeFile: WriteFileCallback;
        getCurrentDirectory(): string;
        getCanonicalFileName(fileName: string): string;
        useCaseSensitiveFileNames(): boolean;
        getNewLine(): string;
        readDirectory?(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[], depth?: number): string[];
        /** @deprecated supply resolveModuleNameLiterals instead for resolution that can handle newer resolution modes like nodenext */
        resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];
        /**
         * Returns the module resolution cache used by a provided `resolveModuleNames` implementation so that any non-name module resolution operations (eg, package.json lookup) can reuse it
         */
        getModuleResolutionCache?(): ModuleResolutionCache | undefined;
        /**
         * @deprecated supply resolveTypeReferenceDirectiveReferences instead for resolution that can handle newer resolution modes like nodenext
         *
         * This method is a companion for 'resolveModuleNames' and is used to resolve 'types' references to actual type declaration files
         */
        resolveTypeReferenceDirectives?(typeReferenceDirectiveNames: string[] | readonly FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: ResolutionMode): (ResolvedTypeReferenceDirective | undefined)[];
        resolveModuleNameLiterals?(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[];
        resolveTypeReferenceDirectiveReferences?<T extends FileReference | string>(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[];
        getEnvironmentVariable?(name: string): string | undefined;
        /** If provided along with custom resolveModuleNames or resolveTypeReferenceDirectives, used to determine if unchanged file path needs to re-resolve modules/type reference directives */
        hasInvalidatedResolutions?(filePath: Path): boolean;
        createHash?(data: string): string;
        getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
    }
    interface SourceMapRange extends TextRange {
        source?: SourceMapSource;
    }
    interface SourceMapSource {
        fileName: string;
        text: string;
        skipTrivia?: (pos: number) => number;
    }
    interface SourceMapSource {
        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
    }
    enum EmitFlags {
        None = 0,
        SingleLine = 1,
        MultiLine = 2,
        AdviseOnEmitNode = 4,
        NoSubstitution = 8,
        CapturesThis = 16,
        NoLeadingSourceMap = 32,
        NoTrailingSourceMap = 64,
        NoSourceMap = 96,
        NoNestedSourceMaps = 128,
        NoTokenLeadingSourceMaps = 256,
        NoTokenTrailingSourceMaps = 512,
        NoTokenSourceMaps = 768,
        NoLeadingComments = 1024,
        NoTrailingComments = 2048,
        NoComments = 3072,
        NoNestedComments = 4096,
        HelperName = 8192,
        ExportName = 16384,
        LocalName = 32768,
        InternalName = 65536,
        Indented = 131072,
        NoIndentation = 262144,
        AsyncFunctionBody = 524288,
        ReuseTempVariableScope = 1048576,
        CustomPrologue = 2097152,
        NoHoisting = 4194304,
        HasEndOfDeclarationMarker = 8388608,
        Iterator = 16777216,
        NoAsciiEscaping = 33554432
    }
    interface EmitHelperBase {
        readonly name: string;
        readonly scoped: boolean;
        readonly text: string | ((node: EmitHelperUniqueNameCallback) => string);
        readonly priority?: number;
        readonly dependencies?: EmitHelper[];
    }
    interface ScopedEmitHelper extends EmitHelperBase {
        readonly scoped: true;
    }
    interface UnscopedEmitHelper extends EmitHelperBase {
        readonly scoped: false;
        readonly text: string;
    }
    type EmitHelper = ScopedEmitHelper | UnscopedEmitHelper;
    type EmitHelperUniqueNameCallback = (name: string) => string;
    enum EmitHint {
        SourceFile = 0,
        Expression = 1,
        IdentifierName = 2,
        MappedTypeParameter = 3,
        Unspecified = 4,
        EmbeddedStatement = 5,
        JsxAttributeValue = 6
    }
    enum OuterExpressionKinds {
        Parentheses = 1,
        TypeAssertions = 2,
        NonNullAssertions = 4,
        PartiallyEmittedExpressions = 8,
        Assertions = 6,
        All = 15,
        ExcludeJSDocTypeAssertion = 16
    }
    type TypeOfTag = "undefined" | "number" | "bigint" | "boolean" | "string" | "symbol" | "object" | "function";
    interface NodeFactory {
        createNodeArray<T extends Node>(elements?: readonly T[], hasTrailingComma?: boolean): NodeArray<T>;
        createNumericLiteral(value: string | number, numericLiteralFlags?: TokenFlags): NumericLiteral;
        createBigIntLiteral(value: string | PseudoBigInt): BigIntLiteral;
        createStringLiteral(text: string, isSingleQuote?: boolean): StringLiteral;
        createStringLiteralFromNode(sourceNode: PropertyNameLiteral | PrivateIdentifier, isSingleQuote?: boolean): StringLiteral;
        createRegularExpressionLiteral(text: string): RegularExpressionLiteral;
        createIdentifier(text: string): Identifier;
        /**
         * Create a unique temporary variable.
         * @param recordTempVariable An optional callback used to record the temporary variable name. This
         * should usually be a reference to `hoistVariableDeclaration` from a `TransformationContext`, but
         * can be `undefined` if you plan to record the temporary variable manually.
         * @param reservedInNestedScopes When `true`, reserves the temporary variable name in all nested scopes
         * during emit so that the variable can be referenced in a nested function body. This is an alternative to
         * setting `EmitFlags.ReuseTempVariableScope` on the nested function itself.
         */
        createTempVariable(recordTempVariable: ((node: Identifier) => void) | undefined, reservedInNestedScopes?: boolean): Identifier;
        /**
         * Create a unique temporary variable for use in a loop.
         * @param reservedInNestedScopes When `true`, reserves the temporary variable name in all nested scopes
         * during emit so that the variable can be referenced in a nested function body. This is an alternative to
         * setting `EmitFlags.ReuseTempVariableScope` on the nested function itself.
         */
        createLoopVariable(reservedInNestedScopes?: boolean): Identifier;
        /** Create a unique name based on the supplied text. */
        createUniqueName(text: string, flags?: GeneratedIdentifierFlags): Identifier;
        /** Create a unique name generated for a node. */
        getGeneratedNameForNode(node: Node | undefined, flags?: GeneratedIdentifierFlags): Identifier;
        createPrivateIdentifier(text: string): PrivateIdentifier;
        createUniquePrivateName(text?: string): PrivateIdentifier;
        getGeneratedPrivateNameForNode(node: Node): PrivateIdentifier;
        createToken(token: SyntaxKind.SuperKeyword): SuperExpression;
        createToken(token: SyntaxKind.ThisKeyword): ThisExpression;
        createToken(token: SyntaxKind.NullKeyword): NullLiteral;
        createToken(token: SyntaxKind.TrueKeyword): TrueLiteral;
        createToken(token: SyntaxKind.FalseKeyword): FalseLiteral;
        createToken(token: SyntaxKind.EndOfFileToken): EndOfFileToken;
        createToken(token: SyntaxKind.Unknown): Token<SyntaxKind.Unknown>;
        createToken<TKind extends PunctuationSyntaxKind>(token: TKind): PunctuationToken<TKind>;
        createToken<TKind extends KeywordTypeSyntaxKind>(token: TKind): KeywordTypeNode<TKind>;
        createToken<TKind extends ModifierSyntaxKind>(token: TKind): ModifierToken<TKind>;
        createToken<TKind extends KeywordSyntaxKind>(token: TKind): KeywordToken<TKind>;
        createSuper(): SuperExpression;
        createThis(): ThisExpression;
        createNull(): NullLiteral;
        createTrue(): TrueLiteral;
        createFalse(): FalseLiteral;
        createModifier<T extends ModifierSyntaxKind>(kind: T): ModifierToken<T>;
        createModifiersFromModifierFlags(flags: ModifierFlags): Modifier[] | undefined;
        createQualifiedName(left: EntityName, right: string | Identifier): QualifiedName;
        updateQualifiedName(node: QualifiedName, left: EntityName, right: Identifier): QualifiedName;
        createComputedPropertyName(expression: Expression): ComputedPropertyName;
        updateComputedPropertyName(node: ComputedPropertyName, expression: Expression): ComputedPropertyName;
        createTypeParameterDeclaration(modifiers: readonly Modifier[] | undefined, name: string | Identifier, constraint?: TypeNode, defaultType?: TypeNode): TypeParameterDeclaration;
        updateTypeParameterDeclaration(node: TypeParameterDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined): TypeParameterDeclaration;
        createParameterDeclaration(modifiers: readonly ModifierLike[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken, type?: TypeNode, initializer?: Expression): ParameterDeclaration;
        updateParameterDeclaration(node: ParameterDeclaration, modifiers: readonly ModifierLike[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): ParameterDeclaration;
        createDecorator(expression: Expression): Decorator;
        updateDecorator(node: Decorator, expression: Expression): Decorator;
        createPropertySignature(modifiers: readonly Modifier[] | undefined, name: PropertyName | string, questionToken: QuestionToken | undefined, type: TypeNode | undefined): PropertySignature;
        updatePropertySignature(node: PropertySignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, type: TypeNode | undefined): PropertySignature;
        createPropertyDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
        updatePropertyDeclaration(node: PropertyDeclaration, modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
        createMethodSignature(modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): MethodSignature;
        updateMethodSignature(node: MethodSignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): MethodSignature;
        createMethodDeclaration(modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
        updateMethodDeclaration(node: MethodDeclaration, modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
        createConstructorDeclaration(modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
        updateConstructorDeclaration(node: ConstructorDeclaration, modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
        createGetAccessorDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
        updateGetAccessorDeclaration(node: GetAccessorDeclaration, modifiers: readonly ModifierLike[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
        createSetAccessorDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
        updateSetAccessorDeclaration(node: SetAccessorDeclaration, modifiers: readonly ModifierLike[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
        createCallSignature(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): CallSignatureDeclaration;
        updateCallSignature(node: CallSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): CallSignatureDeclaration;
        createConstructSignature(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): ConstructSignatureDeclaration;
        updateConstructSignature(node: ConstructSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): ConstructSignatureDeclaration;
        createIndexSignature(modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
        updateIndexSignature(node: IndexSignatureDeclaration, modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
        createTemplateLiteralTypeSpan(type: TypeNode, literal: TemplateMiddle | TemplateTail): TemplateLiteralTypeSpan;
        updateTemplateLiteralTypeSpan(node: TemplateLiteralTypeSpan, type: TypeNode, literal: TemplateMiddle | TemplateTail): TemplateLiteralTypeSpan;
        createClassStaticBlockDeclaration(body: Block): ClassStaticBlockDeclaration;
        updateClassStaticBlockDeclaration(node: ClassStaticBlockDeclaration, body: Block): ClassStaticBlockDeclaration;
        createKeywordTypeNode<TKind extends KeywordTypeSyntaxKind>(kind: TKind): KeywordTypeNode<TKind>;
        createTypePredicateNode(assertsModifier: AssertsKeyword | undefined, parameterName: Identifier | ThisTypeNode | string, type: TypeNode | undefined): TypePredicateNode;
        updateTypePredicateNode(node: TypePredicateNode, assertsModifier: AssertsKeyword | undefined, parameterName: Identifier | ThisTypeNode, type: TypeNode | undefined): TypePredicateNode;
        createTypeReferenceNode(typeName: string | EntityName, typeArguments?: readonly TypeNode[]): TypeReferenceNode;
        updateTypeReferenceNode(node: TypeReferenceNode, typeName: EntityName, typeArguments: NodeArray<TypeNode> | undefined): TypeReferenceNode;
        createFunctionTypeNode(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): FunctionTypeNode;
        updateFunctionTypeNode(node: FunctionTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode): FunctionTypeNode;
        createConstructorTypeNode(modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): ConstructorTypeNode;
        updateConstructorTypeNode(node: ConstructorTypeNode, modifiers: readonly Modifier[] | undefined, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode): ConstructorTypeNode;
        createTypeQueryNode(exprName: EntityName, typeArguments?: readonly TypeNode[]): TypeQueryNode;
        updateTypeQueryNode(node: TypeQueryNode, exprName: EntityName, typeArguments?: readonly TypeNode[]): TypeQueryNode;
        createTypeLiteralNode(members: readonly TypeElement[] | undefined): TypeLiteralNode;
        updateTypeLiteralNode(node: TypeLiteralNode, members: NodeArray<TypeElement>): TypeLiteralNode;
        createArrayTypeNode(elementType: TypeNode): ArrayTypeNode;
        updateArrayTypeNode(node: ArrayTypeNode, elementType: TypeNode): ArrayTypeNode;
        createTupleTypeNode(elements: readonly (TypeNode | NamedTupleMember)[]): TupleTypeNode;
        updateTupleTypeNode(node: TupleTypeNode, elements: readonly (TypeNode | NamedTupleMember)[]): TupleTypeNode;
        createNamedTupleMember(dotDotDotToken: DotDotDotToken | undefined, name: Identifier, questionToken: QuestionToken | undefined, type: TypeNode): NamedTupleMember;
        updateNamedTupleMember(node: NamedTupleMember, dotDotDotToken: DotDotDotToken | undefined, name: Identifier, questionToken: QuestionToken | undefined, type: TypeNode): NamedTupleMember;
        createOptionalTypeNode(type: TypeNode): OptionalTypeNode;
        updateOptionalTypeNode(node: OptionalTypeNode, type: TypeNode): OptionalTypeNode;
        createRestTypeNode(type: TypeNode): RestTypeNode;
        updateRestTypeNode(node: RestTypeNode, type: TypeNode): RestTypeNode;
        createUnionTypeNode(types: readonly TypeNode[]): UnionTypeNode;
        updateUnionTypeNode(node: UnionTypeNode, types: NodeArray<TypeNode>): UnionTypeNode;
        createIntersectionTypeNode(types: readonly TypeNode[]): IntersectionTypeNode;
        updateIntersectionTypeNode(node: IntersectionTypeNode, types: NodeArray<TypeNode>): IntersectionTypeNode;
        createConditionalTypeNode(checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode): ConditionalTypeNode;
        updateConditionalTypeNode(node: ConditionalTypeNode, checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode): ConditionalTypeNode;
        createInferTypeNode(typeParameter: TypeParameterDeclaration): InferTypeNode;
        updateInferTypeNode(node: InferTypeNode, typeParameter: TypeParameterDeclaration): InferTypeNode;
        createImportTypeNode(argument: TypeNode, assertions?: ImportTypeAssertionContainer, qualifier?: EntityName, typeArguments?: readonly TypeNode[], isTypeOf?: boolean): ImportTypeNode;
        updateImportTypeNode(node: ImportTypeNode, argument: TypeNode, assertions: ImportTypeAssertionContainer | undefined, qualifier: EntityName | undefined, typeArguments: readonly TypeNode[] | undefined, isTypeOf?: boolean): ImportTypeNode;
        createParenthesizedType(type: TypeNode): ParenthesizedTypeNode;
        updateParenthesizedType(node: ParenthesizedTypeNode, type: TypeNode): ParenthesizedTypeNode;
        createThisTypeNode(): ThisTypeNode;
        createTypeOperatorNode(operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword, type: TypeNode): TypeOperatorNode;
        updateTypeOperatorNode(node: TypeOperatorNode, type: TypeNode): TypeOperatorNode;
        createIndexedAccessTypeNode(objectType: TypeNode, indexType: TypeNode): IndexedAccessTypeNode;
        updateIndexedAccessTypeNode(node: IndexedAccessTypeNode, objectType: TypeNode, indexType: TypeNode): IndexedAccessTypeNode;
        createMappedTypeNode(readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined): MappedTypeNode;
        updateMappedTypeNode(node: MappedTypeNode, readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined): MappedTypeNode;
        createLiteralTypeNode(literal: LiteralTypeNode["literal"]): LiteralTypeNode;
        updateLiteralTypeNode(node: LiteralTypeNode, literal: LiteralTypeNode["literal"]): LiteralTypeNode;
        createTemplateLiteralType(head: TemplateHead, templateSpans: readonly TemplateLiteralTypeSpan[]): TemplateLiteralTypeNode;
        updateTemplateLiteralType(node: TemplateLiteralTypeNode, head: TemplateHead, templateSpans: readonly TemplateLiteralTypeSpan[]): TemplateLiteralTypeNode;
        createObjectBindingPattern(elements: readonly BindingElement[]): ObjectBindingPattern;
        updateObjectBindingPattern(node: ObjectBindingPattern, elements: readonly BindingElement[]): ObjectBindingPattern;
        createArrayBindingPattern(elements: readonly ArrayBindingElement[]): ArrayBindingPattern;
        updateArrayBindingPattern(node: ArrayBindingPattern, elements: readonly ArrayBindingElement[]): ArrayBindingPattern;
        createBindingElement(dotDotDotToken: DotDotDotToken | undefined, propertyName: string | PropertyName | undefined, name: string | BindingName, initializer?: Expression): BindingElement;
        updateBindingElement(node: BindingElement, dotDotDotToken: DotDotDotToken | undefined, propertyName: PropertyName | undefined, name: BindingName, initializer: Expression | undefined): BindingElement;
        createArrayLiteralExpression(elements?: readonly Expression[], multiLine?: boolean): ArrayLiteralExpression;
        updateArrayLiteralExpression(node: ArrayLiteralExpression, elements: readonly Expression[]): ArrayLiteralExpression;
        createObjectLiteralExpression(properties?: readonly ObjectLiteralElementLike[], multiLine?: boolean): ObjectLiteralExpression;
        updateObjectLiteralExpression(node: ObjectLiteralExpression, properties: readonly ObjectLiteralElementLike[]): ObjectLiteralExpression;
        createPropertyAccessExpression(expression: Expression, name: string | MemberName): PropertyAccessExpression;
        updatePropertyAccessExpression(node: PropertyAccessExpression, expression: Expression, name: MemberName): PropertyAccessExpression;
        createPropertyAccessChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, name: string | MemberName): PropertyAccessChain;
        updatePropertyAccessChain(node: PropertyAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, name: MemberName): PropertyAccessChain;
        createElementAccessExpression(expression: Expression, index: number | Expression): ElementAccessExpression;
        updateElementAccessExpression(node: ElementAccessExpression, expression: Expression, argumentExpression: Expression): ElementAccessExpression;
        createElementAccessChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, index: number | Expression): ElementAccessChain;
        updateElementAccessChain(node: ElementAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, argumentExpression: Expression): ElementAccessChain;
        createCallExpression(expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): CallExpression;
        updateCallExpression(node: CallExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]): CallExpression;
        createCallChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): CallChain;
        updateCallChain(node: CallChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]): CallChain;
        createNewExpression(expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): NewExpression;
        updateNewExpression(node: NewExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): NewExpression;
        createTaggedTemplateExpression(tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;
        updateTaggedTemplateExpression(node: TaggedTemplateExpression, tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;
        createTypeAssertion(type: TypeNode, expression: Expression): TypeAssertion;
        updateTypeAssertion(node: TypeAssertion, type: TypeNode, expression: Expression): TypeAssertion;
        createParenthesizedExpression(expression: Expression): ParenthesizedExpression;
        updateParenthesizedExpression(node: ParenthesizedExpression, expression: Expression): ParenthesizedExpression;
        createFunctionExpression(modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[] | undefined, type: TypeNode | undefined, body: Block): FunctionExpression;
        updateFunctionExpression(node: FunctionExpression, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block): FunctionExpression;
        createArrowFunction(modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken | undefined, body: ConciseBody): ArrowFunction;
        updateArrowFunction(node: ArrowFunction, modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken, body: ConciseBody): ArrowFunction;
        createDeleteExpression(expression: Expression): DeleteExpression;
        updateDeleteExpression(node: DeleteExpression, expression: Expression): DeleteExpression;
        createTypeOfExpression(expression: Expression): TypeOfExpression;
        updateTypeOfExpression(node: TypeOfExpression, expression: Expression): TypeOfExpression;
        createVoidExpression(expression: Expression): VoidExpression;
        updateVoidExpression(node: VoidExpression, expression: Expression): VoidExpression;
        createAwaitExpression(expression: Expression): AwaitExpression;
        updateAwaitExpression(node: AwaitExpression, expression: Expression): AwaitExpression;
        createPrefixUnaryExpression(operator: PrefixUnaryOperator, operand: Expression): PrefixUnaryExpression;
        updatePrefixUnaryExpression(node: PrefixUnaryExpression, operand: Expression): PrefixUnaryExpression;
        createPostfixUnaryExpression(operand: Expression, operator: PostfixUnaryOperator): PostfixUnaryExpression;
        updatePostfixUnaryExpression(node: PostfixUnaryExpression, operand: Expression): PostfixUnaryExpression;
        createBinaryExpression(left: Expression, operator: BinaryOperator | BinaryOperatorToken, right: Expression): BinaryExpression;
        updateBinaryExpression(node: BinaryExpression, left: Expression, operator: BinaryOperator | BinaryOperatorToken, right: Expression): BinaryExpression;
        createConditionalExpression(condition: Expression, questionToken: QuestionToken | undefined, whenTrue: Expression, colonToken: ColonToken | undefined, whenFalse: Expression): ConditionalExpression;
        updateConditionalExpression(node: ConditionalExpression, condition: Expression, questionToken: QuestionToken, whenTrue: Expression, colonToken: ColonToken, whenFalse: Expression): ConditionalExpression;
        createTemplateExpression(head: TemplateHead, templateSpans: readonly TemplateSpan[]): TemplateExpression;
        updateTemplateExpression(node: TemplateExpression, head: TemplateHead, templateSpans: readonly TemplateSpan[]): TemplateExpression;
        createTemplateHead(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateHead;
        createTemplateHead(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateHead;
        createTemplateMiddle(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateMiddle;
        createTemplateMiddle(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateMiddle;
        createTemplateTail(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateTail;
        createTemplateTail(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateTail;
        createNoSubstitutionTemplateLiteral(text: string, rawText?: string): NoSubstitutionTemplateLiteral;
        createNoSubstitutionTemplateLiteral(text: string | undefined, rawText: string): NoSubstitutionTemplateLiteral;
        createYieldExpression(asteriskToken: AsteriskToken, expression: Expression): YieldExpression;
        createYieldExpression(asteriskToken: undefined, expression: Expression | undefined): YieldExpression;
        updateYieldExpression(node: YieldExpression, asteriskToken: AsteriskToken | undefined, expression: Expression | undefined): YieldExpression;
        createSpreadElement(expression: Expression): SpreadElement;
        updateSpreadElement(node: SpreadElement, expression: Expression): SpreadElement;
        createClassExpression(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;
        updateClassExpression(node: ClassExpression, modifiers: readonly ModifierLike[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;
        createOmittedExpression(): OmittedExpression;
        createExpressionWithTypeArguments(expression: Expression, typeArguments: readonly TypeNode[] | undefined): ExpressionWithTypeArguments;
        updateExpressionWithTypeArguments(node: ExpressionWithTypeArguments, expression: Expression, typeArguments: readonly TypeNode[] | undefined): ExpressionWithTypeArguments;
        createAsExpression(expression: Expression, type: TypeNode): AsExpression;
        updateAsExpression(node: AsExpression, expression: Expression, type: TypeNode): AsExpression;
        createNonNullExpression(expression: Expression): NonNullExpression;
        updateNonNullExpression(node: NonNullExpression, expression: Expression): NonNullExpression;
        createNonNullChain(expression: Expression): NonNullChain;
        updateNonNullChain(node: NonNullChain, expression: Expression): NonNullChain;
        createMetaProperty(keywordToken: MetaProperty["keywordToken"], name: Identifier): MetaProperty;
        updateMetaProperty(node: MetaProperty, name: Identifier): MetaProperty;
        createSatisfiesExpression(expression: Expression, type: TypeNode): SatisfiesExpression;
        updateSatisfiesExpression(node: SatisfiesExpression, expression: Expression, type: TypeNode): SatisfiesExpression;
        createTemplateSpan(expression: Expression, literal: TemplateMiddle | TemplateTail): TemplateSpan;
        updateTemplateSpan(node: TemplateSpan, expression: Expression, literal: TemplateMiddle | TemplateTail): TemplateSpan;
        createSemicolonClassElement(): SemicolonClassElement;
        createBlock(statements: readonly Statement[], multiLine?: boolean): Block;
        updateBlock(node: Block, statements: readonly Statement[]): Block;
        createVariableStatement(modifiers: readonly ModifierLike[] | undefined, declarationList: VariableDeclarationList | readonly VariableDeclaration[]): VariableStatement;
        updateVariableStatement(node: VariableStatement, modifiers: readonly ModifierLike[] | undefined, declarationList: VariableDeclarationList): VariableStatement;
        createEmptyStatement(): EmptyStatement;
        createExpressionStatement(expression: Expression): ExpressionStatement;
        updateExpressionStatement(node: ExpressionStatement, expression: Expression): ExpressionStatement;
        createIfStatement(expression: Expression, thenStatement: Statement, elseStatement?: Statement): IfStatement;
        updateIfStatement(node: IfStatement, expression: Expression, thenStatement: Statement, elseStatement: Statement | undefined): IfStatement;
        createDoStatement(statement: Statement, expression: Expression): DoStatement;
        updateDoStatement(node: DoStatement, statement: Statement, expression: Expression): DoStatement;
        createWhileStatement(expression: Expression, statement: Statement): WhileStatement;
        updateWhileStatement(node: WhileStatement, expression: Expression, statement: Statement): WhileStatement;
        createForStatement(initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement): ForStatement;
        updateForStatement(node: ForStatement, initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement): ForStatement;
        createForInStatement(initializer: ForInitializer, expression: Expression, statement: Statement): ForInStatement;
        updateForInStatement(node: ForInStatement, initializer: ForInitializer, expression: Expression, statement: Statement): ForInStatement;
        createForOfStatement(awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement): ForOfStatement;
        updateForOfStatement(node: ForOfStatement, awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement): ForOfStatement;
        createContinueStatement(label?: string | Identifier): ContinueStatement;
        updateContinueStatement(node: ContinueStatement, label: Identifier | undefined): ContinueStatement;
        createBreakStatement(label?: string | Identifier): BreakStatement;
        updateBreakStatement(node: BreakStatement, label: Identifier | undefined): BreakStatement;
        createReturnStatement(expression?: Expression): ReturnStatement;
        updateReturnStatement(node: ReturnStatement, expression: Expression | undefined): ReturnStatement;
        createWithStatement(expression: Expression, statement: Statement): WithStatement;
        updateWithStatement(node: WithStatement, expression: Expression, statement: Statement): WithStatement;
        createSwitchStatement(expression: Expression, caseBlock: CaseBlock): SwitchStatement;
        updateSwitchStatement(node: SwitchStatement, expression: Expression, caseBlock: CaseBlock): SwitchStatement;
        createLabeledStatement(label: string | Identifier, statement: Statement): LabeledStatement;
        updateLabeledStatement(node: LabeledStatement, label: Identifier, statement: Statement): LabeledStatement;
        createThrowStatement(expression: Expression): ThrowStatement;
        updateThrowStatement(node: ThrowStatement, expression: Expression): ThrowStatement;
        createTryStatement(tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined): TryStatement;
        updateTryStatement(node: TryStatement, tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined): TryStatement;
        createDebuggerStatement(): DebuggerStatement;
        createVariableDeclaration(name: string | BindingName, exclamationToken?: ExclamationToken, type?: TypeNode, initializer?: Expression): VariableDeclaration;
        updateVariableDeclaration(node: VariableDeclaration, name: BindingName, exclamationToken: ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;
        createVariableDeclarationList(declarations: readonly VariableDeclaration[], flags?: NodeFlags): VariableDeclarationList;
        updateVariableDeclarationList(node: VariableDeclarationList, declarations: readonly VariableDeclaration[]): VariableDeclarationList;
        createFunctionDeclaration(modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
        updateFunctionDeclaration(node: FunctionDeclaration, modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
        createClassDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
        updateClassDeclaration(node: ClassDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
        createInterfaceDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
        updateInterfaceDeclaration(node: InterfaceDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
        createTypeAliasDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
        updateTypeAliasDeclaration(node: TypeAliasDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
        createEnumDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier, members: readonly EnumMember[]): EnumDeclaration;
        updateEnumDeclaration(node: EnumDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier, members: readonly EnumMember[]): EnumDeclaration;
        createModuleDeclaration(modifiers: readonly ModifierLike[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags): ModuleDeclaration;
        updateModuleDeclaration(node: ModuleDeclaration, modifiers: readonly ModifierLike[] | undefined, name: ModuleName, body: ModuleBody | undefined): ModuleDeclaration;
        createModuleBlock(statements: readonly Statement[]): ModuleBlock;
        updateModuleBlock(node: ModuleBlock, statements: readonly Statement[]): ModuleBlock;
        createCaseBlock(clauses: readonly CaseOrDefaultClause[]): CaseBlock;
        updateCaseBlock(node: CaseBlock, clauses: readonly CaseOrDefaultClause[]): CaseBlock;
        createNamespaceExportDeclaration(name: string | Identifier): NamespaceExportDeclaration;
        updateNamespaceExportDeclaration(node: NamespaceExportDeclaration, name: Identifier): NamespaceExportDeclaration;
        createImportEqualsDeclaration(modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, name: string | Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
        updateImportEqualsDeclaration(node: ImportEqualsDeclaration, modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, name: Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
        createImportDeclaration(modifiers: readonly ModifierLike[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause?: AssertClause): ImportDeclaration;
        updateImportDeclaration(node: ImportDeclaration, modifiers: readonly ModifierLike[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration;
        createImportClause(isTypeOnly: boolean, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined): ImportClause;
        updateImportClause(node: ImportClause, isTypeOnly: boolean, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined): ImportClause;
        createAssertClause(elements: NodeArray<AssertEntry>, multiLine?: boolean): AssertClause;
        updateAssertClause(node: AssertClause, elements: NodeArray<AssertEntry>, multiLine?: boolean): AssertClause;
        createAssertEntry(name: AssertionKey, value: Expression): AssertEntry;
        updateAssertEntry(node: AssertEntry, name: AssertionKey, value: Expression): AssertEntry;
        createImportTypeAssertionContainer(clause: AssertClause, multiLine?: boolean): ImportTypeAssertionContainer;
        updateImportTypeAssertionContainer(node: ImportTypeAssertionContainer, clause: AssertClause, multiLine?: boolean): ImportTypeAssertionContainer;
        createNamespaceImport(name: Identifier): NamespaceImport;
        updateNamespaceImport(node: NamespaceImport, name: Identifier): NamespaceImport;
        createNamespaceExport(name: Identifier): NamespaceExport;
        updateNamespaceExport(node: NamespaceExport, name: Identifier): NamespaceExport;
        createNamedImports(elements: readonly ImportSpecifier[]): NamedImports;
        updateNamedImports(node: NamedImports, elements: readonly ImportSpecifier[]): NamedImports;
        createImportSpecifier(isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier): ImportSpecifier;
        updateImportSpecifier(node: ImportSpecifier, isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier): ImportSpecifier;
        createExportAssignment(modifiers: readonly ModifierLike[] | undefined, isExportEquals: boolean | undefined, expression: Expression): ExportAssignment;
        updateExportAssignment(node: ExportAssignment, modifiers: readonly ModifierLike[] | undefined, expression: Expression): ExportAssignment;
        createExportDeclaration(modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier?: Expression, assertClause?: AssertClause): ExportDeclaration;
        updateExportDeclaration(node: ExportDeclaration, modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier: Expression | undefined, assertClause: AssertClause | undefined): ExportDeclaration;
        createNamedExports(elements: readonly ExportSpecifier[]): NamedExports;
        updateNamedExports(node: NamedExports, elements: readonly ExportSpecifier[]): NamedExports;
        createExportSpecifier(isTypeOnly: boolean, propertyName: string | Identifier | undefined, name: string | Identifier): ExportSpecifier;
        updateExportSpecifier(node: ExportSpecifier, isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier): ExportSpecifier;
        createExternalModuleReference(expression: Expression): ExternalModuleReference;
        updateExternalModuleReference(node: ExternalModuleReference, expression: Expression): ExternalModuleReference;
        createJSDocAllType(): JSDocAllType;
        createJSDocUnknownType(): JSDocUnknownType;
        createJSDocNonNullableType(type: TypeNode, postfix?: boolean): JSDocNonNullableType;
        updateJSDocNonNullableType(node: JSDocNonNullableType, type: TypeNode): JSDocNonNullableType;
        createJSDocNullableType(type: TypeNode, postfix?: boolean): JSDocNullableType;
        updateJSDocNullableType(node: JSDocNullableType, type: TypeNode): JSDocNullableType;
        createJSDocOptionalType(type: TypeNode): JSDocOptionalType;
        updateJSDocOptionalType(node: JSDocOptionalType, type: TypeNode): JSDocOptionalType;
        createJSDocFunctionType(parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): JSDocFunctionType;
        updateJSDocFunctionType(node: JSDocFunctionType, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): JSDocFunctionType;
        createJSDocVariadicType(type: TypeNode): JSDocVariadicType;
        updateJSDocVariadicType(node: JSDocVariadicType, type: TypeNode): JSDocVariadicType;
        createJSDocNamepathType(type: TypeNode): JSDocNamepathType;
        updateJSDocNamepathType(node: JSDocNamepathType, type: TypeNode): JSDocNamepathType;
        createJSDocTypeExpression(type: TypeNode): JSDocTypeExpression;
        updateJSDocTypeExpression(node: JSDocTypeExpression, type: TypeNode): JSDocTypeExpression;
        createJSDocNameReference(name: EntityName | JSDocMemberName): JSDocNameReference;
        updateJSDocNameReference(node: JSDocNameReference, name: EntityName | JSDocMemberName): JSDocNameReference;
        createJSDocMemberName(left: EntityName | JSDocMemberName, right: Identifier): JSDocMemberName;
        updateJSDocMemberName(node: JSDocMemberName, left: EntityName | JSDocMemberName, right: Identifier): JSDocMemberName;
        createJSDocLink(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLink;
        updateJSDocLink(node: JSDocLink, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLink;
        createJSDocLinkCode(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkCode;
        updateJSDocLinkCode(node: JSDocLinkCode, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkCode;
        createJSDocLinkPlain(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkPlain;
        updateJSDocLinkPlain(node: JSDocLinkPlain, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkPlain;
        createJSDocTypeLiteral(jsDocPropertyTags?: readonly JSDocPropertyLikeTag[], isArrayType?: boolean): JSDocTypeLiteral;
        updateJSDocTypeLiteral(node: JSDocTypeLiteral, jsDocPropertyTags: readonly JSDocPropertyLikeTag[] | undefined, isArrayType: boolean | undefined): JSDocTypeLiteral;
        createJSDocSignature(typeParameters: readonly JSDocTemplateTag[] | undefined, parameters: readonly JSDocParameterTag[], type?: JSDocReturnTag): JSDocSignature;
        updateJSDocSignature(node: JSDocSignature, typeParameters: readonly JSDocTemplateTag[] | undefined, parameters: readonly JSDocParameterTag[], type: JSDocReturnTag | undefined): JSDocSignature;
        createJSDocTemplateTag(tagName: Identifier | undefined, constraint: JSDocTypeExpression | undefined, typeParameters: readonly TypeParameterDeclaration[], comment?: string | NodeArray<JSDocComment>): JSDocTemplateTag;
        updateJSDocTemplateTag(node: JSDocTemplateTag, tagName: Identifier | undefined, constraint: JSDocTypeExpression | undefined, typeParameters: readonly TypeParameterDeclaration[], comment: string | NodeArray<JSDocComment> | undefined): JSDocTemplateTag;
        createJSDocTypedefTag(tagName: Identifier | undefined, typeExpression?: JSDocTypeExpression | JSDocTypeLiteral, fullName?: Identifier | JSDocNamespaceDeclaration, comment?: string | NodeArray<JSDocComment>): JSDocTypedefTag;
        updateJSDocTypedefTag(node: JSDocTypedefTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | JSDocTypeLiteral | undefined, fullName: Identifier | JSDocNamespaceDeclaration | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocTypedefTag;
        createJSDocParameterTag(tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression, isNameFirst?: boolean, comment?: string | NodeArray<JSDocComment>): JSDocParameterTag;
        updateJSDocParameterTag(node: JSDocParameterTag, tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression: JSDocTypeExpression | undefined, isNameFirst: boolean, comment: string | NodeArray<JSDocComment> | undefined): JSDocParameterTag;
        createJSDocPropertyTag(tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression, isNameFirst?: boolean, comment?: string | NodeArray<JSDocComment>): JSDocPropertyTag;
        updateJSDocPropertyTag(node: JSDocPropertyTag, tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression: JSDocTypeExpression | undefined, isNameFirst: boolean, comment: string | NodeArray<JSDocComment> | undefined): JSDocPropertyTag;
        createJSDocTypeTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocTypeTag;
        updateJSDocTypeTag(node: JSDocTypeTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment: string | NodeArray<JSDocComment> | undefined): JSDocTypeTag;
        createJSDocSeeTag(tagName: Identifier | undefined, nameExpression: JSDocNameReference | undefined, comment?: string | NodeArray<JSDocComment>): JSDocSeeTag;
        updateJSDocSeeTag(node: JSDocSeeTag, tagName: Identifier | undefined, nameExpression: JSDocNameReference | undefined, comment?: string | NodeArray<JSDocComment>): JSDocSeeTag;
        createJSDocReturnTag(tagName: Identifier | undefined, typeExpression?: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocReturnTag;
        updateJSDocReturnTag(node: JSDocReturnTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocReturnTag;
        createJSDocThisTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocThisTag;
        updateJSDocThisTag(node: JSDocThisTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocThisTag;
        createJSDocEnumTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocEnumTag;
        updateJSDocEnumTag(node: JSDocEnumTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment: string | NodeArray<JSDocComment> | undefined): JSDocEnumTag;
        createJSDocCallbackTag(tagName: Identifier | undefined, typeExpression: JSDocSignature, fullName?: Identifier | JSDocNamespaceDeclaration, comment?: string | NodeArray<JSDocComment>): JSDocCallbackTag;
        updateJSDocCallbackTag(node: JSDocCallbackTag, tagName: Identifier | undefined, typeExpression: JSDocSignature, fullName: Identifier | JSDocNamespaceDeclaration | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocCallbackTag;
        createJSDocOverloadTag(tagName: Identifier | undefined, typeExpression: JSDocSignature, comment?: string | NodeArray<JSDocComment>): JSDocOverloadTag;
        updateJSDocOverloadTag(node: JSDocOverloadTag, tagName: Identifier | undefined, typeExpression: JSDocSignature, comment: string | NodeArray<JSDocComment> | undefined): JSDocOverloadTag;
        createJSDocAugmentsTag(tagName: Identifier | undefined, className: JSDocAugmentsTag["class"], comment?: string | NodeArray<JSDocComment>): JSDocAugmentsTag;
        updateJSDocAugmentsTag(node: JSDocAugmentsTag, tagName: Identifier | undefined, className: JSDocAugmentsTag["class"], comment: string | NodeArray<JSDocComment> | undefined): JSDocAugmentsTag;
        createJSDocImplementsTag(tagName: Identifier | undefined, className: JSDocImplementsTag["class"], comment?: string | NodeArray<JSDocComment>): JSDocImplementsTag;
        updateJSDocImplementsTag(node: JSDocImplementsTag, tagName: Identifier | undefined, className: JSDocImplementsTag["class"], comment: string | NodeArray<JSDocComment> | undefined): JSDocImplementsTag;
        createJSDocAuthorTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocAuthorTag;
        updateJSDocAuthorTag(node: JSDocAuthorTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocAuthorTag;
        createJSDocClassTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocClassTag;
        updateJSDocClassTag(node: JSDocClassTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocClassTag;
        createJSDocPublicTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocPublicTag;
        updateJSDocPublicTag(node: JSDocPublicTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocPublicTag;
        createJSDocPrivateTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocPrivateTag;
        updateJSDocPrivateTag(node: JSDocPrivateTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocPrivateTag;
        createJSDocProtectedTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocProtectedTag;
        updateJSDocProtectedTag(node: JSDocProtectedTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocProtectedTag;
        createJSDocReadonlyTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocReadonlyTag;
        updateJSDocReadonlyTag(node: JSDocReadonlyTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocReadonlyTag;
        createJSDocUnknownTag(tagName: Identifier, comment?: string | NodeArray<JSDocComment>): JSDocUnknownTag;
        updateJSDocUnknownTag(node: JSDocUnknownTag, tagName: Identifier, comment: string | NodeArray<JSDocComment> | undefined): JSDocUnknownTag;
        createJSDocDeprecatedTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocDeprecatedTag;
        updateJSDocDeprecatedTag(node: JSDocDeprecatedTag, tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocDeprecatedTag;
        createJSDocOverrideTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocOverrideTag;
        updateJSDocOverrideTag(node: JSDocOverrideTag, tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocOverrideTag;
        createJSDocThrowsTag(tagName: Identifier, typeExpression: JSDocTypeExpression | undefined, comment?: string | NodeArray<JSDocComment>): JSDocThrowsTag;
        updateJSDocThrowsTag(node: JSDocThrowsTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | undefined, comment?: string | NodeArray<JSDocComment> | undefined): JSDocThrowsTag;
        createJSDocSatisfiesTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocSatisfiesTag;
        updateJSDocSatisfiesTag(node: JSDocSatisfiesTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment: string | NodeArray<JSDocComment> | undefined): JSDocSatisfiesTag;
        createJSDocText(text: string): JSDocText;
        updateJSDocText(node: JSDocText, text: string): JSDocText;
        createJSDocComment(comment?: string | NodeArray<JSDocComment> | undefined, tags?: readonly JSDocTag[] | undefined): JSDoc;
        updateJSDocComment(node: JSDoc, comment: string | NodeArray<JSDocComment> | undefined, tags: readonly JSDocTag[] | undefined): JSDoc;
        createJsxElement(openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement): JsxElement;
        updateJsxElement(node: JsxElement, openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement): JsxElement;
        createJsxSelfClosingElement(tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxSelfClosingElement;
        updateJsxSelfClosingElement(node: JsxSelfClosingElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxSelfClosingElement;
        createJsxOpeningElement(tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxOpeningElement;
        updateJsxOpeningElement(node: JsxOpeningElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxOpeningElement;
        createJsxClosingElement(tagName: JsxTagNameExpression): JsxClosingElement;
        updateJsxClosingElement(node: JsxClosingElement, tagName: JsxTagNameExpression): JsxClosingElement;
        createJsxFragment(openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment): JsxFragment;
        createJsxText(text: string, containsOnlyTriviaWhiteSpaces?: boolean): JsxText;
        updateJsxText(node: JsxText, text: string, containsOnlyTriviaWhiteSpaces?: boolean): JsxText;
        createJsxOpeningFragment(): JsxOpeningFragment;
        createJsxJsxClosingFragment(): JsxClosingFragment;
        updateJsxFragment(node: JsxFragment, openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment): JsxFragment;
        createJsxAttribute(name: Identifier, initializer: JsxAttributeValue | undefined): JsxAttribute;
        updateJsxAttribute(node: JsxAttribute, name: Identifier, initializer: JsxAttributeValue | undefined): JsxAttribute;
        createJsxAttributes(properties: readonly JsxAttributeLike[]): JsxAttributes;
        updateJsxAttributes(node: JsxAttributes, properties: readonly JsxAttributeLike[]): JsxAttributes;
        createJsxSpreadAttribute(expression: Expression): JsxSpreadAttribute;
        updateJsxSpreadAttribute(node: JsxSpreadAttribute, expression: Expression): JsxSpreadAttribute;
        createJsxExpression(dotDotDotToken: DotDotDotToken | undefined, expression: Expression | undefined): JsxExpression;
        updateJsxExpression(node: JsxExpression, expression: Expression | undefined): JsxExpression;
        createCaseClause(expression: Expression, statements: readonly Statement[]): CaseClause;
        updateCaseClause(node: CaseClause, expression: Expression, statements: readonly Statement[]): CaseClause;
        createDefaultClause(statements: readonly Statement[]): DefaultClause;
        updateDefaultClause(node: DefaultClause, statements: readonly Statement[]): DefaultClause;
        createHeritageClause(token: HeritageClause["token"], types: readonly ExpressionWithTypeArguments[]): HeritageClause;
        updateHeritageClause(node: HeritageClause, types: readonly ExpressionWithTypeArguments[]): HeritageClause;
        createCatchClause(variableDeclaration: string | BindingName | VariableDeclaration | undefined, block: Block): CatchClause;
        updateCatchClause(node: CatchClause, variableDeclaration: VariableDeclaration | undefined, block: Block): CatchClause;
        createPropertyAssignment(name: string | PropertyName, initializer: Expression): PropertyAssignment;
        updatePropertyAssignment(node: PropertyAssignment, name: PropertyName, initializer: Expression): PropertyAssignment;
        createShorthandPropertyAssignment(name: string | Identifier, objectAssignmentInitializer?: Expression): ShorthandPropertyAssignment;
        updateShorthandPropertyAssignment(node: ShorthandPropertyAssignment, name: Identifier, objectAssignmentInitializer: Expression | undefined): ShorthandPropertyAssignment;
        createSpreadAssignment(expression: Expression): SpreadAssignment;
        updateSpreadAssignment(node: SpreadAssignment, expression: Expression): SpreadAssignment;
        createEnumMember(name: string | PropertyName, initializer?: Expression): EnumMember;
        updateEnumMember(node: EnumMember, name: PropertyName, initializer: Expression | undefined): EnumMember;
        createSourceFile(statements: readonly Statement[], endOfFileToken: EndOfFileToken, flags: NodeFlags): SourceFile;
        updateSourceFile(node: SourceFile, statements: readonly Statement[], isDeclarationFile?: boolean, referencedFiles?: readonly FileReference[], typeReferences?: readonly FileReference[], hasNoDefaultLib?: boolean, libReferences?: readonly FileReference[]): SourceFile;
        createNotEmittedStatement(original: Node): NotEmittedStatement;
        createPartiallyEmittedExpression(expression: Expression, original?: Node): PartiallyEmittedExpression;
        updatePartiallyEmittedExpression(node: PartiallyEmittedExpression, expression: Expression): PartiallyEmittedExpression;
        createCommaListExpression(elements: readonly Expression[]): CommaListExpression;
        updateCommaListExpression(node: CommaListExpression, elements: readonly Expression[]): CommaListExpression;
        createBundle(sourceFiles: readonly SourceFile[]): Bundle;
        /** @deprecated*/ createBundle(sourceFiles: readonly SourceFile[], prepends?: readonly (UnparsedSource | InputFiles)[]): Bundle;
        updateBundle(node: Bundle, sourceFiles: readonly SourceFile[]): Bundle;
        /** @deprecated*/ updateBundle(node: Bundle, sourceFiles: readonly SourceFile[], prepends?: readonly (UnparsedSource | InputFiles)[]): Bundle;
        createComma(left: Expression, right: Expression): BinaryExpression;
        createAssignment(left: ObjectLiteralExpression | ArrayLiteralExpression, right: Expression): DestructuringAssignment;
        createAssignment(left: Expression, right: Expression): AssignmentExpression<EqualsToken>;
        createLogicalOr(left: Expression, right: Expression): BinaryExpression;
        createLogicalAnd(left: Expression, right: Expression): BinaryExpression;
        createBitwiseOr(left: Expression, right: Expression): BinaryExpression;
        createBitwiseXor(left: Expression, right: Expression): BinaryExpression;
        createBitwiseAnd(left: Expression, right: Expression): BinaryExpression;
        createStrictEquality(left: Expression, right: Expression): BinaryExpression;
        createStrictInequality(left: Expression, right: Expression): BinaryExpression;
        createEquality(left: Expression, right: Expression): BinaryExpression;
        createInequality(left: Expression, right: Expression): BinaryExpression;
        createLessThan(left: Expression, right: Expression): BinaryExpression;
        createLessThanEquals(left: Expression, right: Expression): BinaryExpression;
        createGreaterThan(left: Expression, right: Expression): BinaryExpression;
        createGreaterThanEquals(left: Expression, right: Expression): BinaryExpression;
        createLeftShift(left: Expression, right: Expression): BinaryExpression;
        createRightShift(left: Expression, right: Expression): BinaryExpression;
        createUnsignedRightShift(left: Expression, right: Expression): BinaryExpression;
        createAdd(left: Expression, right: Expression): BinaryExpression;
        createSubtract(left: Expression, right: Expression): BinaryExpression;
        createMultiply(left: Expression, right: Expression): BinaryExpression;
        createDivide(left: Expression, right: Expression): BinaryExpression;
        createModulo(left: Expression, right: Expression): BinaryExpression;
        createExponent(left: Expression, right: Expression): BinaryExpression;
        createPrefixPlus(operand: Expression): PrefixUnaryExpression;
        createPrefixMinus(operand: Expression): PrefixUnaryExpression;
        createPrefixIncrement(operand: Expression): PrefixUnaryExpression;
        createPrefixDecrement(operand: Expression): PrefixUnaryExpression;
        createBitwiseNot(operand: Expression): PrefixUnaryExpression;
        createLogicalNot(operand: Expression): PrefixUnaryExpression;
        createPostfixIncrement(operand: Expression): PostfixUnaryExpression;
        createPostfixDecrement(operand: Expression): PostfixUnaryExpression;
        createImmediatelyInvokedFunctionExpression(statements: readonly Statement[]): CallExpression;
        createImmediatelyInvokedFunctionExpression(statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;
        createImmediatelyInvokedArrowFunction(statements: readonly Statement[]): CallExpression;
        createImmediatelyInvokedArrowFunction(statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;
        createVoidZero(): VoidExpression;
        createExportDefault(expression: Expression): ExportAssignment;
        createExternalModuleExport(exportName: Identifier): ExportDeclaration;
        restoreOuterExpressions(outerExpression: Expression | undefined, innerExpression: Expression, kinds?: OuterExpressionKinds): Expression;
    }
    interface CoreTransformationContext {
        readonly factory: NodeFactory;
        /** Gets the compiler options supplied to the transformer. */
        getCompilerOptions(): CompilerOptions;
        /** Starts a new lexical environment. */
        startLexicalEnvironment(): void;
        /** Suspends the current lexical environment, usually after visiting a parameter list. */
        suspendLexicalEnvironment(): void;
        /** Resumes a suspended lexical environment, usually before visiting a function body. */
        resumeLexicalEnvironment(): void;
        /** Ends a lexical environment, returning any declarations. */
        endLexicalEnvironment(): Statement[] | undefined;
        /** Hoists a function declaration to the containing scope. */
        hoistFunctionDeclaration(node: FunctionDeclaration): void;
        /** Hoists a variable declaration to the containing scope. */
        hoistVariableDeclaration(node: Identifier): void;
    }
    interface TransformationContext extends CoreTransformationContext {
        /** Records a request for a non-scoped emit helper in the current context. */
        requestEmitHelper(helper: EmitHelper): void;
        /** Gets and resets the requested non-scoped emit helpers. */
        readEmitHelpers(): EmitHelper[] | undefined;
        /** Enables expression substitutions in the pretty printer for the provided SyntaxKind. */
        enableSubstitution(kind: SyntaxKind): void;
        /** Determines whether expression substitutions are enabled for the provided node. */
        isSubstitutionEnabled(node: Node): boolean;
        /**
         * Hook used by transformers to substitute expressions just before they
         * are emitted by the pretty printer.
         *
         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,
         * before returning the `NodeTransformer` callback.
         */
        onSubstituteNode: (hint: EmitHint, node: Node) => Node;
        /**
         * Enables before/after emit notifications in the pretty printer for the provided
         * SyntaxKind.
         */
        enableEmitNotification(kind: SyntaxKind): void;
        /**
         * Determines whether before/after emit notifications should be raised in the pretty
         * printer when it emits a node.
         */
        isEmitNotificationEnabled(node: Node): boolean;
        /**
         * Hook used to allow transformers to capture state before or after
         * the printer emits a node.
         *
         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,
         * before returning the `NodeTransformer` callback.
         */
        onEmitNode: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;
    }
    interface TransformationResult<T extends Node> {
        /** Gets the transformed source files. */
        transformed: T[];
        /** Gets diagnostics for the transformation. */
        diagnostics?: DiagnosticWithLocation[];
        /**
         * Gets a substitute for a node, if one is available; otherwise, returns the original node.
         *
         * @param hint A hint as to the intended usage of the node.
         * @param node The node to substitute.
         */
        substituteNode(hint: EmitHint, node: Node): Node;
        /**
         * Emits a node with possible notification.
         *
         * @param hint A hint as to the intended usage of the node.
         * @param node The node to emit.
         * @param emitCallback A callback used to emit the node.
         */
        emitNodeWithNotification(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;
        /**
         * Indicates if a given node needs an emit notification
         *
         * @param node The node to emit.
         */
        isEmitNotificationEnabled?(node: Node): boolean;
        /**
         * Clean up EmitNode entries on any parse-tree nodes.
         */
        dispose(): void;
    }
    /**
     * A function that is used to initialize and return a `Transformer` callback, which in turn
     * will be used to transform one or more nodes.
     */
    type TransformerFactory<T extends Node> = (context: TransformationContext) => Transformer<T>;
    /**
     * A function that transforms a node.
     */
    type Transformer<T extends Node> = (node: T) => T;
    /**
     * A function that accepts and possibly transforms a node.
     */
    type Visitor<TIn extends Node = Node, TOut extends Node | undefined = TIn | undefined> = (node: TIn) => VisitResult<TOut>;
    /**
     * A function that walks a node using the given visitor, lifting node arrays into single nodes,
     * returning an node which satisfies the test.
     *
     * - If the input node is undefined, then the output is undefined.
     * - If the visitor returns undefined, then the output is undefined.
     * - If the output node is not undefined, then it will satisfy the test function.
     * - In order to obtain a return type that is more specific than `Node`, a test
     *   function _must_ be provided, and that function must be a type predicate.
     *
     * For the canonical implementation of this type, @see {visitNode}.
     */
    interface NodeVisitor {
        <TIn extends Node | undefined, TVisited extends Node | undefined, TOut extends Node>(node: TIn, visitor: Visitor<NonNullable<TIn>, TVisited>, test: (node: Node) => node is TOut, lift?: (node: readonly Node[]) => Node): TOut | (TIn & undefined) | (TVisited & undefined);
        <TIn extends Node | undefined, TVisited extends Node | undefined>(node: TIn, visitor: Visitor<NonNullable<TIn>, TVisited>, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => Node): Node | (TIn & undefined) | (TVisited & undefined);
    }
    /**
     * A function that walks a node array using the given visitor, returning an array whose contents satisfy the test.
     *
     * - If the input node array is undefined, the output is undefined.
     * - If the visitor can return undefined, the node it visits in the array will be reused.
     * - If the output node array is not undefined, then its contents will satisfy the test.
     * - In order to obtain a return type that is more specific than `NodeArray<Node>`, a test
     *   function _must_ be provided, and that function must be a type predicate.
     *
     * For the canonical implementation of this type, @see {visitNodes}.
     */
    interface NodesVisitor {
        <TIn extends Node, TInArray extends NodeArray<TIn> | undefined, TOut extends Node>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test: (node: Node) => node is TOut, start?: number, count?: number): NodeArray<TOut> | (TInArray & undefined);
        <TIn extends Node, TInArray extends NodeArray<TIn> | undefined>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<Node> | (TInArray & undefined);
    }
    type VisitResult<T extends Node | undefined> = T | readonly Node[];
    interface Printer {
        /**
         * Print a node and its subtree as-is, without any emit transformations.
         * @param hint A value indicating the purpose of a node. This is primarily used to
         * distinguish between an `Identifier` used in an expression position, versus an
         * `Identifier` used as an `IdentifierName` as part of a declaration. For most nodes you
         * should just pass `Unspecified`.
         * @param node The node to print. The node and its subtree are printed as-is, without any
         * emit transformations.
         * @param sourceFile A source file that provides context for the node. The source text of
         * the file is used to emit the original source content for literals and identifiers, while
         * the identifiers of the source file are used when generating unique names to avoid
         * collisions.
         */
        printNode(hint: EmitHint, node: Node, sourceFile: SourceFile): string;
        /**
         * Prints a list of nodes using the given format flags
         */
        printList<T extends Node>(format: ListFormat, list: NodeArray<T>, sourceFile: SourceFile): string;
        /**
         * Prints a source file as-is, without any emit transformations.
         */
        printFile(sourceFile: SourceFile): string;
        /**
         * Prints a bundle of source files as-is, without any emit transformations.
         */
        printBundle(bundle: Bundle): string;
    }
    interface PrintHandlers {
        /**
         * A hook used by the Printer when generating unique names to avoid collisions with
         * globally defined names that exist outside of the current source file.
         */
        hasGlobalName?(name: string): boolean;
        /**
         * A hook used by the Printer to provide notifications prior to emitting a node. A
         * compatible implementation **must** invoke `emitCallback` with the provided `hint` and
         * `node` values.
         * @param hint A hint indicating the intended purpose of the node.
         * @param node The node to emit.
         * @param emitCallback A callback that, when invoked, will emit the node.
         * @example
         * ```ts
         * var printer = createPrinter(printerOptions, {
         *   onEmitNode(hint, node, emitCallback) {
         *     // set up or track state prior to emitting the node...
         *     emitCallback(hint, node);
         *     // restore state after emitting the node...
         *   }
         * });
         * ```
         */
        onEmitNode?(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;
        /**
         * A hook used to check if an emit notification is required for a node.
         * @param node The node to emit.
         */
        isEmitNotificationEnabled?(node: Node): boolean;
        /**
         * A hook used by the Printer to perform just-in-time substitution of a node. This is
         * primarily used by node transformations that need to substitute one node for another,
         * such as replacing `myExportedVar` with `exports.myExportedVar`.
         * @param hint A hint indicating the intended purpose of the node.
         * @param node The node to emit.
         * @example
         * ```ts
         * var printer = createPrinter(printerOptions, {
         *   substituteNode(hint, node) {
         *     // perform substitution if necessary...
         *     return node;
         *   }
         * });
         * ```
         */
        substituteNode?(hint: EmitHint, node: Node): Node;
    }
    interface PrinterOptions {
        removeComments?: boolean;
        newLine?: NewLineKind;
        omitTrailingSemicolon?: boolean;
        noEmitHelpers?: boolean;
    }
    interface GetEffectiveTypeRootsHost {
        directoryExists?(directoryName: string): boolean;
        getCurrentDirectory?(): string;
    }
    interface TextSpan {
        start: number;
        length: number;
    }
    interface TextChangeRange {
        span: TextSpan;
        newLength: number;
    }
    interface SyntaxList extends Node {
        kind: SyntaxKind.SyntaxList;
        _children: Node[];
    }
    enum ListFormat {
        None = 0,
        SingleLine = 0,
        MultiLine = 1,
        PreserveLines = 2,
        LinesMask = 3,
        NotDelimited = 0,
        BarDelimited = 4,
        AmpersandDelimited = 8,
        CommaDelimited = 16,
        AsteriskDelimited = 32,
        DelimitersMask = 60,
        AllowTrailingComma = 64,
        Indented = 128,
        SpaceBetweenBraces = 256,
        SpaceBetweenSiblings = 512,
        Braces = 1024,
        Parenthesis = 2048,
        AngleBrackets = 4096,
        SquareBrackets = 8192,
        BracketsMask = 15360,
        OptionalIfUndefined = 16384,
        OptionalIfEmpty = 32768,
        Optional = 49152,
        PreferNewLine = 65536,
        NoTrailingNewLine = 131072,
        NoInterveningComments = 262144,
        NoSpaceIfEmpty = 524288,
        SingleElement = 1048576,
        SpaceAfterList = 2097152,
        Modifiers = 2359808,
        HeritageClauses = 512,
        SingleLineTypeLiteralMembers = 768,
        MultiLineTypeLiteralMembers = 32897,
        SingleLineTupleTypeElements = 528,
        MultiLineTupleTypeElements = 657,
        UnionTypeConstituents = 516,
        IntersectionTypeConstituents = 520,
        ObjectBindingPatternElements = 525136,
        ArrayBindingPatternElements = 524880,
        ObjectLiteralExpressionProperties = 526226,
        ImportClauseEntries = 526226,
        ArrayLiteralExpressionElements = 8914,
        CommaListElements = 528,
        CallExpressionArguments = 2576,
        NewExpressionArguments = 18960,
        TemplateExpressionSpans = 262144,
        SingleLineBlockStatements = 768,
        MultiLineBlockStatements = 129,
        VariableDeclarationList = 528,
        SingleLineFunctionBodyStatements = 768,
        MultiLineFunctionBodyStatements = 1,
        ClassHeritageClauses = 0,
        ClassMembers = 129,
        InterfaceMembers = 129,
        EnumMembers = 145,
        CaseBlockClauses = 129,
        NamedImportsOrExportsElements = 525136,
        JsxElementOrFragmentChildren = 262144,
        JsxElementAttributes = 262656,
        CaseOrDefaultClauseStatements = 163969,
        HeritageClauseTypes = 528,
        SourceFileStatements = 131073,
        Decorators = 2146305,
        TypeArguments = 53776,
        TypeParameters = 53776,
        Parameters = 2576,
        IndexSignatureParameters = 8848,
        JSDocComment = 33
    }
    interface UserPreferences {
        readonly disableSuggestions?: boolean;
        readonly quotePreference?: "auto" | "double" | "single";
        readonly includeCompletionsForModuleExports?: boolean;
        readonly includeCompletionsForImportStatements?: boolean;
        readonly includeCompletionsWithSnippetText?: boolean;
        readonly includeAutomaticOptionalChainCompletions?: boolean;
        readonly includeCompletionsWithInsertText?: boolean;
        readonly includeCompletionsWithClassMemberSnippets?: boolean;
        readonly includeCompletionsWithObjectLiteralMethodSnippets?: boolean;
        readonly useLabelDetailsInCompletionEntries?: boolean;
        readonly allowIncompleteCompletions?: boolean;
        readonly importModuleSpecifierPreference?: "shortest" | "project-relative" | "relative" | "non-relative";
        /** Determines whether we import `foo/index.ts` as "foo", "foo/index", or "foo/index.js" */
        readonly importModuleSpecifierEnding?: "auto" | "minimal" | "index" | "js";
        readonly allowTextChangesInNewFiles?: boolean;
        readonly providePrefixAndSuffixTextForRename?: boolean;
        readonly includePackageJsonAutoImports?: "auto" | "on" | "off";
        readonly provideRefactorNotApplicableReason?: boolean;
        readonly jsxAttributeCompletionStyle?: "auto" | "braces" | "none";
        readonly includeInlayParameterNameHints?: "none" | "literals" | "all";
        readonly includeInlayParameterNameHintsWhenArgumentMatchesName?: boolean;
        readonly includeInlayFunctionParameterTypeHints?: boolean;
        readonly includeInlayVariableTypeHints?: boolean;
        readonly includeInlayVariableTypeHintsWhenTypeMatchesName?: boolean;
        readonly includeInlayPropertyDeclarationTypeHints?: boolean;
        readonly includeInlayFunctionLikeReturnTypeHints?: boolean;
        readonly includeInlayEnumMemberValueHints?: boolean;
        readonly allowRenameOfImportPath?: boolean;
        readonly autoImportFileExcludePatterns?: string[];
        readonly organizeImportsIgnoreCase?: "auto" | boolean;
        readonly organizeImportsCollation?: "ordinal" | "unicode";
        readonly organizeImportsLocale?: string;
        readonly organizeImportsNumericCollation?: boolean;
        readonly organizeImportsAccentCollation?: boolean;
        readonly organizeImportsCaseFirst?: "upper" | "lower" | false;
    }
    /** Represents a bigint literal value without requiring bigint support */
    interface PseudoBigInt {
        negative: boolean;
        base10Value: string;
    }
    enum FileWatcherEventKind {
        Created = 0,
        Changed = 1,
        Deleted = 2
    }
    type FileWatcherCallback = (fileName: string, eventKind: FileWatcherEventKind, modifiedTime?: Date) => void;
    type DirectoryWatcherCallback = (fileName: string) => void;
    type BufferEncoding = "ascii" | "utf8" | "utf-8" | "utf16le" | "ucs2" | "ucs-2" | "base64" | "latin1" | "binary" | "hex";
    interface System {
        args: string[];
        newLine: string;
        useCaseSensitiveFileNames: boolean;
        write(s: string): void;
        writeOutputIsTTY?(): boolean;
        getWidthOfTerminal?(): number;
        readFile(path: string, encoding?: string): string | undefined;
        getFileSize?(path: string): number;
        writeFile(path: string, data: string, writeByteOrderMark?: boolean): void;
        /**
         * @pollingInterval - this parameter is used in polling-based watchers and ignored in watchers that
         * use native OS file watching
         */
        watchFile?(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;
        watchDirectory?(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;
        resolvePath(path: string): string;
        fileExists(path: string): boolean;
        directoryExists(path: string): boolean;
        createDirectory(path: string): void;
        getExecutingFilePath(): string;
        getCurrentDirectory(): string;
        getDirectories(path: string): string[];
        readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
        getModifiedTime?(path: string): Date | undefined;
        setModifiedTime?(path: string, time: Date): void;
        deleteFile?(path: string): void;
        /**
         * A good implementation is node.js' `crypto.createHash`. (https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm)
         */
        createHash?(data: string): string;
        /** This must be cryptographically secure. Only implement this method using `crypto.createHash("sha256")`. */
        createSHA256Hash?(data: string): string;
        getMemoryUsage?(): number;
        exit(exitCode?: number): void;
        realpath?(path: string): string;
        setTimeout?(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;
        clearTimeout?(timeoutId: any): void;
        clearScreen?(): void;
        base64decode?(input: string): string;
        base64encode?(input: string): string;
    }
    interface FileWatcher {
        close(): void;
    }
    let sys: System;
    function tokenToString(t: SyntaxKind): string | undefined;
    function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number): number;
    function getLineAndCharacterOfPosition(sourceFile: SourceFileLike, position: number): LineAndCharacter;
    function isWhiteSpaceLike(ch: number): boolean;
    /** Does not include line breaks. For that, see isWhiteSpaceLike. */
    function isWhiteSpaceSingleLine(ch: number): boolean;
    function isLineBreak(ch: number): boolean;
    function couldStartTrivia(text: string, pos: number): boolean;
    function forEachLeadingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;
    function forEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;
    function forEachTrailingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;
    function forEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;
    function reduceEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T, initial: U): U | undefined;
    function reduceEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T, initial: U): U | undefined;
    function getLeadingCommentRanges(text: string, pos: number): CommentRange[] | undefined;
    function getTrailingCommentRanges(text: string, pos: number): CommentRange[] | undefined;
    /** Optionally, get the shebang */
    function getShebang(text: string): string | undefined;
    function isIdentifierStart(ch: number, languageVersion: ScriptTarget | undefined): boolean;
    function isIdentifierPart(ch: number, languageVersion: ScriptTarget | undefined, identifierVariant?: LanguageVariant): boolean;
    function createScanner(languageVersion: ScriptTarget, skipTrivia: boolean, languageVariant?: LanguageVariant, textInitial?: string, onError?: ErrorCallback, start?: number, length?: number): Scanner;
    type ErrorCallback = (message: DiagnosticMessage, length: number) => void;
    interface Scanner {
        getStartPos(): number;
        getToken(): SyntaxKind;
        getTextPos(): number;
        getTokenPos(): number;
        getTokenText(): string;
        getTokenValue(): string;
        hasUnicodeEscape(): boolean;
        hasExtendedUnicodeEscape(): boolean;
        hasPrecedingLineBreak(): boolean;
        isIdentifier(): boolean;
        isReservedWord(): boolean;
        isUnterminated(): boolean;
        reScanGreaterToken(): SyntaxKind;
        reScanSlashToken(): SyntaxKind;
        reScanAsteriskEqualsToken(): SyntaxKind;
        reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind;
        reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind;
        scanJsxIdentifier(): SyntaxKind;
        scanJsxAttributeValue(): SyntaxKind;
        reScanJsxAttributeValue(): SyntaxKind;
        reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind;
        reScanLessThanToken(): SyntaxKind;
        reScanHashToken(): SyntaxKind;
        reScanQuestionToken(): SyntaxKind;
        reScanInvalidIdentifier(): SyntaxKind;
        scanJsxToken(): JsxTokenSyntaxKind;
        scanJsDocToken(): JSDocSyntaxKind;
        scan(): SyntaxKind;
        getText(): string;
        setText(text: string | undefined, start?: number, length?: number): void;
        setOnError(onError: ErrorCallback | undefined): void;
        setScriptTarget(scriptTarget: ScriptTarget): void;
        setLanguageVariant(variant: LanguageVariant): void;
        setTextPos(textPos: number): void;
        lookAhead<T>(callback: () => T): T;
        scanRange<T>(start: number, length: number, callback: () => T): T;
        tryScan<T>(callback: () => T): T;
    }
    function isExternalModuleNameRelative(moduleName: string): boolean;
    function sortAndDeduplicateDiagnostics<T extends Diagnostic>(diagnostics: readonly T[]): SortedReadonlyArray<T>;
    function getDefaultLibFileName(options: CompilerOptions): string;
    function textSpanEnd(span: TextSpan): number;
    function textSpanIsEmpty(span: TextSpan): boolean;
    function textSpanContainsPosition(span: TextSpan, position: number): boolean;
    function textSpanContainsTextSpan(span: TextSpan, other: TextSpan): boolean;
    function textSpanOverlapsWith(span: TextSpan, other: TextSpan): boolean;
    function textSpanOverlap(span1: TextSpan, span2: TextSpan): TextSpan | undefined;
    function textSpanIntersectsWithTextSpan(span: TextSpan, other: TextSpan): boolean;
    function textSpanIntersectsWith(span: TextSpan, start: number, length: number): boolean;
    function decodedTextSpanIntersectsWith(start1: number, length1: number, start2: number, length2: number): boolean;
    function textSpanIntersectsWithPosition(span: TextSpan, position: number): boolean;
    function textSpanIntersection(span1: TextSpan, span2: TextSpan): TextSpan | undefined;
    function createTextSpan(start: number, length: number): TextSpan;
    function createTextSpanFromBounds(start: number, end: number): TextSpan;
    function textChangeRangeNewSpan(range: TextChangeRange): TextSpan;
    function textChangeRangeIsUnchanged(range: TextChangeRange): boolean;
    function createTextChangeRange(span: TextSpan, newLength: number): TextChangeRange;
    /**
     * Called to merge all the changes that occurred across several versions of a script snapshot
     * into a single change.  i.e. if a user keeps making successive edits to a script we will
     * have a text change from V1 to V2, V2 to V3, ..., Vn.
     *
     * This function will then merge those changes into a single change range valid between V1 and
     * Vn.
     */
    function collapseTextChangeRangesAcrossMultipleVersions(changes: readonly TextChangeRange[]): TextChangeRange;
    function getTypeParameterOwner(d: Declaration): Declaration | undefined;
    function isParameterPropertyDeclaration(node: Node, parent: Node): node is ParameterPropertyDeclaration;
    function isEmptyBindingPattern(node: BindingName): node is BindingPattern;
    function isEmptyBindingElement(node: BindingElement | ArrayBindingElement): boolean;
    function walkUpBindingElementsAndPatterns(binding: BindingElement): VariableDeclaration | ParameterDeclaration;
    function getCombinedModifierFlags(node: Declaration): ModifierFlags;
    function getCombinedNodeFlags(node: Node): NodeFlags;
    /**
     * Checks to see if the locale is in the appropriate format,
     * and if it is, attempts to set the appropriate language.
     */
    function validateLocaleAndSetLanguage(locale: string, sys: {
        getExecutingFilePath(): string;
        resolvePath(path: string): string;
        fileExists(fileName: string): boolean;
        readFile(fileName: string): string | undefined;
    }, errors?: Diagnostic[]): void;
    function getOriginalNode(node: Node): Node;
    function getOriginalNode<T extends Node>(node: Node, nodeTest: (node: Node) => node is T): T;
    function getOriginalNode(node: Node | undefined): Node | undefined;
    function getOriginalNode<T extends Node>(node: Node | undefined, nodeTest: (node: Node) => node is T): T | undefined;
    /**
     * Iterates through the parent chain of a node and performs the callback on each parent until the callback
     * returns a truthy value, then returns that value.
     * If no such value is found, it applies the callback until the parent pointer is undefined or the callback returns "quit"
     * At that point findAncestor returns undefined.
     */
    function findAncestor<T extends Node>(node: Node | undefined, callback: (element: Node) => element is T): T | undefined;
    function findAncestor(node: Node | undefined, callback: (element: Node) => boolean | "quit"): Node | undefined;
    /**
     * Gets a value indicating whether a node originated in the parse tree.
     *
     * @param node The node to test.
     */
    function isParseTreeNode(node: Node): boolean;
    /**
     * Gets the original parse tree node for a node.
     *
     * @param node The original node.
     * @returns The original parse tree node if found; otherwise, undefined.
     */
    function getParseTreeNode(node: Node | undefined): Node | undefined;
    /**
     * Gets the original parse tree node for a node.
     *
     * @param node The original node.
     * @param nodeTest A callback used to ensure the correct type of parse tree node is returned.
     * @returns The original parse tree node if found; otherwise, undefined.
     */
    function getParseTreeNode<T extends Node>(node: T | undefined, nodeTest?: (node: Node) => node is T): T | undefined;
    /** Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__' */
    function escapeLeadingUnderscores(identifier: string): __String;
    /**
     * Remove extra underscore from escaped identifier text content.
     *
     * @param identifier The escaped identifier text.
     * @returns The unescaped identifier text.
     */
    function unescapeLeadingUnderscores(identifier: __String): string;
    function idText(identifierOrPrivateName: Identifier | PrivateIdentifier): string;
    /**
     * If the text of an Identifier matches a keyword (including contextual and TypeScript-specific keywords), returns the
     * SyntaxKind for the matching keyword.
     */
    function identifierToKeywordKind(node: Identifier): KeywordSyntaxKind | undefined;
    function symbolName(symbol: Symbol): string;
    function getNameOfJSDocTypedef(declaration: JSDocTypedefTag): Identifier | PrivateIdentifier | undefined;
    function getNameOfDeclaration(declaration: Declaration | Expression | undefined): DeclarationName | undefined;
    function getDecorators(node: HasDecorators): readonly Decorator[] | undefined;
    function getModifiers(node: HasModifiers): readonly Modifier[] | undefined;
    /**
     * Gets the JSDoc parameter tags for the node if present.
     *
     * @remarks Returns any JSDoc param tag whose name matches the provided
     * parameter, whether a param tag on a containing function
     * expression, or a param tag on a variable declaration whose
     * initializer is the containing function. The tags closest to the
     * node are returned first, so in the previous example, the param
     * tag on the containing function expression would be first.
     *
     * For binding patterns, parameter tags are matched by position.
     */
    function getJSDocParameterTags(param: ParameterDeclaration): readonly JSDocParameterTag[];
    /**
     * Gets the JSDoc type parameter tags for the node if present.
     *
     * @remarks Returns any JSDoc template tag whose names match the provided
     * parameter, whether a template tag on a containing function
     * expression, or a template tag on a variable declaration whose
     * initializer is the containing function. The tags closest to the
     * node are returned first, so in the previous example, the template
     * tag on the containing function expression would be first.
     */
    function getJSDocTypeParameterTags(param: TypeParameterDeclaration): readonly JSDocTemplateTag[];
    /**
     * Return true if the node has JSDoc parameter tags.
     *
     * @remarks Includes parameter tags that are not directly on the node,
     * for example on a variable declaration whose initializer is a function expression.
     */
    function hasJSDocParameterTags(node: FunctionLikeDeclaration | SignatureDeclaration): boolean;
    /** Gets the JSDoc augments tag for the node if present */
    function getJSDocAugmentsTag(node: Node): JSDocAugmentsTag | undefined;
    /** Gets the JSDoc implements tags for the node if present */
    function getJSDocImplementsTags(node: Node): readonly JSDocImplementsTag[];
    /** Gets the JSDoc class tag for the node if present */
    function getJSDocClassTag(node: Node): JSDocClassTag | undefined;
    /** Gets the JSDoc public tag for the node if present */
    function getJSDocPublicTag(node: Node): JSDocPublicTag | undefined;
    /** Gets the JSDoc private tag for the node if present */
    function getJSDocPrivateTag(node: Node): JSDocPrivateTag | undefined;
    /** Gets the JSDoc protected tag for the node if present */
    function getJSDocProtectedTag(node: Node): JSDocProtectedTag | undefined;
    /** Gets the JSDoc protected tag for the node if present */
    function getJSDocReadonlyTag(node: Node): JSDocReadonlyTag | undefined;
    function getJSDocOverrideTagNoCache(node: Node): JSDocOverrideTag | undefined;
    /** Gets the JSDoc deprecated tag for the node if present */
    function getJSDocDeprecatedTag(node: Node): JSDocDeprecatedTag | undefined;
    /** Gets the JSDoc enum tag for the node if present */
    function getJSDocEnumTag(node: Node): JSDocEnumTag | undefined;
    /** Gets the JSDoc this tag for the node if present */
    function getJSDocThisTag(node: Node): JSDocThisTag | undefined;
    /** Gets the JSDoc return tag for the node if present */
    function getJSDocReturnTag(node: Node): JSDocReturnTag | undefined;
    /** Gets the JSDoc template tag for the node if present */
    function getJSDocTemplateTag(node: Node): JSDocTemplateTag | undefined;
    function getJSDocSatisfiesTag(node: Node): JSDocSatisfiesTag | undefined;
    /** Gets the JSDoc type tag for the node if present and valid */
    function getJSDocTypeTag(node: Node): JSDocTypeTag | undefined;
    /**
     * Gets the type node for the node if provided via JSDoc.
     *
     * @remarks The search includes any JSDoc param tag that relates
     * to the provided parameter, for example a type tag on the
     * parameter itself, or a param tag on a containing function
     * expression, or a param tag on a variable declaration whose
     * initializer is the containing function. The tags closest to the
     * node are examined first, so in the previous example, the type
     * tag directly on the node would be returned.
     */
    function getJSDocType(node: Node): TypeNode | undefined;
    /**
     * Gets the return type node for the node if provided via JSDoc return tag or type tag.
     *
     * @remarks `getJSDocReturnTag` just gets the whole JSDoc tag. This function
     * gets the type from inside the braces, after the fat arrow, etc.
     */
    function getJSDocReturnType(node: Node): TypeNode | undefined;
    /** Get all JSDoc tags related to a node, including those on parent nodes. */
    function getJSDocTags(node: Node): readonly JSDocTag[];
    /** Gets all JSDoc tags that match a specified predicate */
    function getAllJSDocTags<T extends JSDocTag>(node: Node, predicate: (tag: JSDocTag) => tag is T): readonly T[];
    /** Gets all JSDoc tags of a specified kind */
    function getAllJSDocTagsOfKind(node: Node, kind: SyntaxKind): readonly JSDocTag[];
    /** Gets the text of a jsdoc comment, flattening links to their text. */
    function getTextOfJSDocComment(comment?: string | NodeArray<JSDocComment>): string | undefined;
    /**
     * Gets the effective type parameters. If the node was parsed in a
     * JavaScript file, gets the type parameters from the `@template` tag from JSDoc.
     *
     * This does *not* return type parameters from a jsdoc reference to a generic type, eg
     *
     * type Id = <T>(x: T) => T
     * /** @type {Id} /
     * function id(x) { return x }
     */
    function getEffectiveTypeParameterDeclarations(node: DeclarationWithTypeParameters): readonly TypeParameterDeclaration[];
    function getEffectiveConstraintOfTypeParameter(node: TypeParameterDeclaration): TypeNode | undefined;
    function isMemberName(node: Node): node is MemberName;
    function isPropertyAccessChain(node: Node): node is PropertyAccessChain;
    function isElementAccessChain(node: Node): node is ElementAccessChain;
    function isCallChain(node: Node): node is CallChain;
    function isOptionalChain(node: Node): node is PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;
    function isNullishCoalesce(node: Node): boolean;
    function isConstTypeReference(node: Node): boolean;
    function skipPartiallyEmittedExpressions(node: Expression): Expression;
    function skipPartiallyEmittedExpressions(node: Node): Node;
    function isNonNullChain(node: Node): node is NonNullChain;
    function isBreakOrContinueStatement(node: Node): node is BreakOrContinueStatement;
    function isNamedExportBindings(node: Node): node is NamedExportBindings;
    /** @deprecated */
    function isUnparsedTextLike(node: Node): node is UnparsedTextLike;
    /** @deprecated */
    function isUnparsedNode(node: Node): node is UnparsedNode;
    function isJSDocPropertyLikeTag(node: Node): node is JSDocPropertyLikeTag;
    /**
     * True if kind is of some token syntax kind.
     * For example, this is true for an IfKeyword but not for an IfStatement.
     * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.
     */
    function isTokenKind(kind: SyntaxKind): boolean;
    /**
     * True if node is of some token syntax kind.
     * For example, this is true for an IfKeyword but not for an IfStatement.
     * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.
     */
    function isToken(n: Node): boolean;
    function isLiteralExpression(node: Node): node is LiteralExpression;
    function isTemplateLiteralToken(node: Node): node is TemplateLiteralToken;
    function isTemplateMiddleOrTemplateTail(node: Node): node is TemplateMiddle | TemplateTail;
    function isImportOrExportSpecifier(node: Node): node is ImportSpecifier | ExportSpecifier;
    function isTypeOnlyImportDeclaration(node: Node): node is TypeOnlyImportDeclaration;
    function isTypeOnlyExportDeclaration(node: Node): node is TypeOnlyExportDeclaration;
    function isTypeOnlyImportOrExportDeclaration(node: Node): node is TypeOnlyAliasDeclaration;
    function isAssertionKey(node: Node): node is AssertionKey;
    function isStringTextContainingNode(node: Node): node is StringLiteral | TemplateLiteralToken;
    function isModifier(node: Node): node is Modifier;
    function isEntityName(node: Node): node is EntityName;
    function isPropertyName(node: Node): node is PropertyName;
    function isBindingName(node: Node): node is BindingName;
    function isFunctionLike(node: Node | undefined): node is SignatureDeclaration;
    function isClassElement(node: Node): node is ClassElement;
    function isClassLike(node: Node): node is ClassLikeDeclaration;
    function isAccessor(node: Node): node is AccessorDeclaration;
    function isAutoAccessorPropertyDeclaration(node: Node): node is AutoAccessorPropertyDeclaration;
    function isModifierLike(node: Node): node is ModifierLike;
    function isTypeElement(node: Node): node is TypeElement;
    function isClassOrTypeElement(node: Node): node is ClassElement | TypeElement;
    function isObjectLiteralElementLike(node: Node): node is ObjectLiteralElementLike;
    /**
     * Node test that determines whether a node is a valid type node.
     * This differs from the `isPartOfTypeNode` function which determines whether a node is *part*
     * of a TypeNode.
     */
    function isTypeNode(node: Node): node is TypeNode;
    function isFunctionOrConstructorTypeNode(node: Node): node is FunctionTypeNode | ConstructorTypeNode;
    function isArrayBindingElement(node: Node): node is ArrayBindingElement;
    function isPropertyAccessOrQualifiedName(node: Node): node is PropertyAccessExpression | QualifiedName;
    function isCallLikeExpression(node: Node): node is CallLikeExpression;
    function isCallOrNewExpression(node: Node): node is CallExpression | NewExpression;
    function isTemplateLiteral(node: Node): node is TemplateLiteral;
    function isLeftHandSideExpression(node: Node): node is LeftHandSideExpression;
    function isLiteralTypeLiteral(node: Node): node is NullLiteral | BooleanLiteral | LiteralExpression | PrefixUnaryExpression;
    /**
     * Determines whether a node is an expression based only on its kind.
     */
    function isExpression(node: Node): node is Expression;
    function isAssertionExpression(node: Node): node is AssertionExpression;
    function isIterationStatement(node: Node, lookInLabeledStatements: false): node is IterationStatement;
    function isIterationStatement(node: Node, lookInLabeledStatements: boolean): node is IterationStatement | LabeledStatement;
    function isConciseBody(node: Node): node is ConciseBody;
    function isForInitializer(node: Node): node is ForInitializer;
    function isModuleBody(node: Node): node is ModuleBody;
    function isNamedImportBindings(node: Node): node is NamedImportBindings;
    function isStatement(node: Node): node is Statement;
    function isModuleReference(node: Node): node is ModuleReference;
    function isJsxTagNameExpression(node: Node): node is JsxTagNameExpression;
    function isJsxChild(node: Node): node is JsxChild;
    function isJsxAttributeLike(node: Node): node is JsxAttributeLike;
    function isStringLiteralOrJsxExpression(node: Node): node is StringLiteral | JsxExpression;
    function isJsxOpeningLikeElement(node: Node): node is JsxOpeningLikeElement;
    function isCaseOrDefaultClause(node: Node): node is CaseOrDefaultClause;
    /** True if node is of a kind that may contain comment text. */
    function isJSDocCommentContainingNode(node: Node): boolean;
    function isSetAccessor(node: Node): node is SetAccessorDeclaration;
    function isGetAccessor(node: Node): node is GetAccessorDeclaration;
    /** True if has initializer node attached to it. */
    function hasOnlyExpressionInitializer(node: Node): node is HasExpressionInitializer;
    function isObjectLiteralElement(node: Node): node is ObjectLiteralElement;
    function isStringLiteralLike(node: Node | FileReference): node is StringLiteralLike;
    function isJSDocLinkLike(node: Node): node is JSDocLink | JSDocLinkCode | JSDocLinkPlain;
    function hasRestParameter(s: SignatureDeclaration | JSDocSignature): boolean;
    function isRestParameter(node: ParameterDeclaration | JSDocParameterTag): boolean;
    let unchangedTextChangeRange: TextChangeRange;
    type ParameterPropertyDeclaration = ParameterDeclaration & {
        parent: ConstructorDeclaration;
        name: Identifier;
    };
    /** @deprecated */
    function createUnparsedSourceFile(text: string): UnparsedSource;
    /** @deprecated */
    function createUnparsedSourceFile(inputFile: InputFiles, type: "js" | "dts", stripInternal?: boolean): UnparsedSource;
    /** @deprecated */
    function createUnparsedSourceFile(text: string, mapPath: string | undefined, map: string | undefined): UnparsedSource;
    /** @deprecated */
    function createInputFiles(javascriptText: string, declarationText: string): InputFiles;
    /** @deprecated */
    function createInputFiles(javascriptText: string, declarationText: string, javascriptMapPath: string | undefined, javascriptMapText: string | undefined, declarationMapPath: string | undefined, declarationMapText: string | undefined): InputFiles;
    /** @deprecated */
    function createInputFiles(readFileText: (path: string) => string | undefined, javascriptPath: string, javascriptMapPath: string | undefined, declarationPath: string, declarationMapPath: string | undefined, buildInfoPath: string | undefined): InputFiles;
    /**
     * Create an external source map source file reference
     */
    function createSourceMapSource(fileName: string, text: string, skipTrivia?: (pos: number) => number): SourceMapSource;
    function setOriginalNode<T extends Node>(node: T, original: Node | undefined): T;
    const factory: NodeFactory;
    /**
     * Clears any `EmitNode` entries from parse-tree nodes.
     * @param sourceFile A source file.
     */
    function disposeEmitNodes(sourceFile: SourceFile | undefined): void;
    /**
     * Sets flags that control emit behavior of a node.
     */
    function setEmitFlags<T extends Node>(node: T, emitFlags: EmitFlags): T;
    /**
     * Gets a custom text range to use when emitting source maps.
     */
    function getSourceMapRange(node: Node): SourceMapRange;
    /**
     * Sets a custom text range to use when emitting source maps.
     */
    function setSourceMapRange<T extends Node>(node: T, range: SourceMapRange | undefined): T;
    /**
     * Gets the TextRange to use for source maps for a token of a node.
     */
    function getTokenSourceMapRange(node: Node, token: SyntaxKind): SourceMapRange | undefined;
    /**
     * Sets the TextRange to use for source maps for a token of a node.
     */
    function setTokenSourceMapRange<T extends Node>(node: T, token: SyntaxKind, range: SourceMapRange | undefined): T;
    /**
     * Gets a custom text range to use when emitting comments.
     */
    function getCommentRange(node: Node): TextRange;
    /**
     * Sets a custom text range to use when emitting comments.
     */
    function setCommentRange<T extends Node>(node: T, range: TextRange): T;
    function getSyntheticLeadingComments(node: Node): SynthesizedComment[] | undefined;
    function setSyntheticLeadingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;
    function addSyntheticLeadingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;
    function getSyntheticTrailingComments(node: Node): SynthesizedComment[] | undefined;
    function setSyntheticTrailingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;
    function addSyntheticTrailingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;
    function moveSyntheticComments<T extends Node>(node: T, original: Node): T;
    /**
     * Gets the constant value to emit for an expression representing an enum.
     */
    function getConstantValue(node: AccessExpression): string | number | undefined;
    /**
     * Sets the constant value to emit for an expression.
     */
    function setConstantValue(node: AccessExpression, value: string | number): AccessExpression;
    /**
     * Adds an EmitHelper to a node.
     */
    function addEmitHelper<T extends Node>(node: T, helper: EmitHelper): T;
    /**
     * Add EmitHelpers to a node.
     */
    function addEmitHelpers<T extends Node>(node: T, helpers: EmitHelper[] | undefined): T;
    /**
     * Removes an EmitHelper from a node.
     */
    function removeEmitHelper(node: Node, helper: EmitHelper): boolean;
    /**
     * Gets the EmitHelpers of a node.
     */
    function getEmitHelpers(node: Node): EmitHelper[] | undefined;
    /**
     * Moves matching emit helpers from a source node to a target node.
     */
    function moveEmitHelpers(source: Node, target: Node, predicate: (helper: EmitHelper) => boolean): void;
    function isNumericLiteral(node: Node): node is NumericLiteral;
    function isBigIntLiteral(node: Node): node is BigIntLiteral;
    function isStringLiteral(node: Node): node is StringLiteral;
    function isJsxText(node: Node): node is JsxText;
    function isRegularExpressionLiteral(node: Node): node is RegularExpressionLiteral;
    function isNoSubstitutionTemplateLiteral(node: Node): node is NoSubstitutionTemplateLiteral;
    function isTemplateHead(node: Node): node is TemplateHead;
    function isTemplateMiddle(node: Node): node is TemplateMiddle;
    function isTemplateTail(node: Node): node is TemplateTail;
    function isDotDotDotToken(node: Node): node is DotDotDotToken;
    function isPlusToken(node: Node): node is PlusToken;
    function isMinusToken(node: Node): node is MinusToken;
    function isAsteriskToken(node: Node): node is AsteriskToken;
    function isExclamationToken(node: Node): node is ExclamationToken;
    function isQuestionToken(node: Node): node is QuestionToken;
    function isColonToken(node: Node): node is ColonToken;
    function isQuestionDotToken(node: Node): node is QuestionDotToken;
    function isEqualsGreaterThanToken(node: Node): node is EqualsGreaterThanToken;
    function isIdentifier(node: Node): node is Identifier;
    function isPrivateIdentifier(node: Node): node is PrivateIdentifier;
    function isAssertsKeyword(node: Node): node is AssertsKeyword;
    function isAwaitKeyword(node: Node): node is AwaitKeyword;
    function isQualifiedName(node: Node): node is QualifiedName;
    function isComputedPropertyName(node: Node): node is ComputedPropertyName;
    function isTypeParameterDeclaration(node: Node): node is TypeParameterDeclaration;
    function isParameter(node: Node): node is ParameterDeclaration;
    function isDecorator(node: Node): node is Decorator;
    function isPropertySignature(node: Node): node is PropertySignature;
    function isPropertyDeclaration(node: Node): node is PropertyDeclaration;
    function isMethodSignature(node: Node): node is MethodSignature;
    function isMethodDeclaration(node: Node): node is MethodDeclaration;
    function isClassStaticBlockDeclaration(node: Node): node is ClassStaticBlockDeclaration;
    function isConstructorDeclaration(node: Node): node is ConstructorDeclaration;
    function isGetAccessorDeclaration(node: Node): node is GetAccessorDeclaration;
    function isSetAccessorDeclaration(node: Node): node is SetAccessorDeclaration;
    function isCallSignatureDeclaration(node: Node): node is CallSignatureDeclaration;
    function isConstructSignatureDeclaration(node: Node): node is ConstructSignatureDeclaration;
    function isIndexSignatureDeclaration(node: Node): node is IndexSignatureDeclaration;
    function isTypePredicateNode(node: Node): node is TypePredicateNode;
    function isTypeReferenceNode(node: Node): node is TypeReferenceNode;
    function isFunctionTypeNode(node: Node): node is FunctionTypeNode;
    function isConstructorTypeNode(node: Node): node is ConstructorTypeNode;
    function isTypeQueryNode(node: Node): node is TypeQueryNode;
    function isTypeLiteralNode(node: Node): node is TypeLiteralNode;
    function isArrayTypeNode(node: Node): node is ArrayTypeNode;
    function isTupleTypeNode(node: Node): node is TupleTypeNode;
    function isNamedTupleMember(node: Node): node is NamedTupleMember;
    function isOptionalTypeNode(node: Node): node is OptionalTypeNode;
    function isRestTypeNode(node: Node): node is RestTypeNode;
    function isUnionTypeNode(node: Node): node is UnionTypeNode;
    function isIntersectionTypeNode(node: Node): node is IntersectionTypeNode;
    function isConditionalTypeNode(node: Node): node is ConditionalTypeNode;
    function isInferTypeNode(node: Node): node is InferTypeNode;
    function isParenthesizedTypeNode(node: Node): node is ParenthesizedTypeNode;
    function isThisTypeNode(node: Node): node is ThisTypeNode;
    function isTypeOperatorNode(node: Node): node is TypeOperatorNode;
    function isIndexedAccessTypeNode(node: Node): node is IndexedAccessTypeNode;
    function isMappedTypeNode(node: Node): node is MappedTypeNode;
    function isLiteralTypeNode(node: Node): node is LiteralTypeNode;
    function isImportTypeNode(node: Node): node is ImportTypeNode;
    function isTemplateLiteralTypeSpan(node: Node): node is TemplateLiteralTypeSpan;
    function isTemplateLiteralTypeNode(node: Node): node is TemplateLiteralTypeNode;
    function isObjectBindingPattern(node: Node): node is ObjectBindingPattern;
    function isArrayBindingPattern(node: Node): node is ArrayBindingPattern;
    function isBindingElement(node: Node): node is BindingElement;
    function isArrayLiteralExpression(node: Node): node is ArrayLiteralExpression;
    function isObjectLiteralExpression(node: Node): node is ObjectLiteralExpression;
    function isPropertyAccessExpression(node: Node): node is PropertyAccessExpression;
    function isElementAccessExpression(node: Node): node is ElementAccessExpression;
    function isCallExpression(node: Node): node is CallExpression;
    function isNewExpression(node: Node): node is NewExpression;
    function isTaggedTemplateExpression(node: Node): node is TaggedTemplateExpression;
    function isTypeAssertionExpression(node: Node): node is TypeAssertion;
    function isParenthesizedExpression(node: Node): node is ParenthesizedExpression;
    function isFunctionExpression(node: Node): node is FunctionExpression;
    function isArrowFunction(node: Node): node is ArrowFunction;
    function isDeleteExpression(node: Node): node is DeleteExpression;
    function isTypeOfExpression(node: Node): node is TypeOfExpression;
    function isVoidExpression(node: Node): node is VoidExpression;
    function isAwaitExpression(node: Node): node is AwaitExpression;
    function isPrefixUnaryExpression(node: Node): node is PrefixUnaryExpression;
    function isPostfixUnaryExpression(node: Node): node is PostfixUnaryExpression;
    function isBinaryExpression(node: Node): node is BinaryExpression;
    function isConditionalExpression(node: Node): node is ConditionalExpression;
    function isTemplateExpression(node: Node): node is TemplateExpression;
    function isYieldExpression(node: Node): node is YieldExpression;
    function isSpreadElement(node: Node): node is SpreadElement;
    function isClassExpression(node: Node): node is ClassExpression;
    function isOmittedExpression(node: Node): node is OmittedExpression;
    function isExpressionWithTypeArguments(node: Node): node is ExpressionWithTypeArguments;
    function isAsExpression(node: Node): node is AsExpression;
    function isSatisfiesExpression(node: Node): node is SatisfiesExpression;
    function isNonNullExpression(node: Node): node is NonNullExpression;
    function isMetaProperty(node: Node): node is MetaProperty;
    function isSyntheticExpression(node: Node): node is SyntheticExpression;
    function isPartiallyEmittedExpression(node: Node): node is PartiallyEmittedExpression;
    function isCommaListExpression(node: Node): node is CommaListExpression;
    function isTemplateSpan(node: Node): node is TemplateSpan;
    function isSemicolonClassElement(node: Node): node is SemicolonClassElement;
    function isBlock(node: Node): node is Block;
    function isVariableStatement(node: Node): node is VariableStatement;
    function isEmptyStatement(node: Node): node is EmptyStatement;
    function isExpressionStatement(node: Node): node is ExpressionStatement;
    function isIfStatement(node: Node): node is IfStatement;
    function isDoStatement(node: Node): node is DoStatement;
    function isWhileStatement(node: Node): node is WhileStatement;
    function isForStatement(node: Node): node is ForStatement;
    function isForInStatement(node: Node): node is ForInStatement;
    function isForOfStatement(node: Node): node is ForOfStatement;
    function isContinueStatement(node: Node): node is ContinueStatement;
    function isBreakStatement(node: Node): node is BreakStatement;
    function isReturnStatement(node: Node): node is ReturnStatement;
    function isWithStatement(node: Node): node is WithStatement;
    function isSwitchStatement(node: Node): node is SwitchStatement;
    function isLabeledStatement(node: Node): node is LabeledStatement;
    function isThrowStatement(node: Node): node is ThrowStatement;
    function isTryStatement(node: Node): node is TryStatement;
    function isDebuggerStatement(node: Node): node is DebuggerStatement;
    function isVariableDeclaration(node: Node): node is VariableDeclaration;
    function isVariableDeclarationList(node: Node): node is VariableDeclarationList;
    function isFunctionDeclaration(node: Node): node is FunctionDeclaration;
    function isClassDeclaration(node: Node): node is ClassDeclaration;
    function isInterfaceDeclaration(node: Node): node is InterfaceDeclaration;
    function isTypeAliasDeclaration(node: Node): node is TypeAliasDeclaration;
    function isEnumDeclaration(node: Node): node is EnumDeclaration;
    function isModuleDeclaration(node: Node): node is ModuleDeclaration;
    function isModuleBlock(node: Node): node is ModuleBlock;
    function isCaseBlock(node: Node): node is CaseBlock;
    function isNamespaceExportDeclaration(node: Node): node is NamespaceExportDeclaration;
    function isImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration;
    function isImportDeclaration(node: Node): node is ImportDeclaration;
    function isImportClause(node: Node): node is ImportClause;
    function isImportTypeAssertionContainer(node: Node): node is ImportTypeAssertionContainer;
    function isAssertClause(node: Node): node is AssertClause;
    function isAssertEntry(node: Node): node is AssertEntry;
    function isNamespaceImport(node: Node): node is NamespaceImport;
    function isNamespaceExport(node: Node): node is NamespaceExport;
    function isNamedImports(node: Node): node is NamedImports;
    function isImportSpecifier(node: Node): node is ImportSpecifier;
    function isExportAssignment(node: Node): node is ExportAssignment;
    function isExportDeclaration(node: Node): node is ExportDeclaration;
    function isNamedExports(node: Node): node is NamedExports;
    function isExportSpecifier(node: Node): node is ExportSpecifier;
    function isMissingDeclaration(node: Node): node is MissingDeclaration;
    function isNotEmittedStatement(node: Node): node is NotEmittedStatement;
    function isExternalModuleReference(node: Node): node is ExternalModuleReference;
    function isJsxElement(node: Node): node is JsxElement;
    function isJsxSelfClosingElement(node: Node): node is JsxSelfClosingElement;
    function isJsxOpeningElement(node: Node): node is JsxOpeningElement;
    function isJsxClosingElement(node: Node): node is JsxClosingElement;
    function isJsxFragment(node: Node): node is JsxFragment;
    function isJsxOpeningFragment(node: Node): node is JsxOpeningFragment;
    function isJsxClosingFragment(node: Node): node is JsxClosingFragment;
    function isJsxAttribute(node: Node): node is JsxAttribute;
    function isJsxAttributes(node: Node): node is JsxAttributes;
    function isJsxSpreadAttribute(node: Node): node is JsxSpreadAttribute;
    function isJsxExpression(node: Node): node is JsxExpression;
    function isCaseClause(node: Node): node is CaseClause;
    function isDefaultClause(node: Node): node is DefaultClause;
    function isHeritageClause(node: Node): node is HeritageClause;
    function isCatchClause(node: Node): node is CatchClause;
    function isPropertyAssignment(node: Node): node is PropertyAssignment;
    function isShorthandPropertyAssignment(node: Node): node is ShorthandPropertyAssignment;
    function isSpreadAssignment(node: Node): node is SpreadAssignment;
    function isEnumMember(node: Node): node is EnumMember;
    /** @deprecated */
    function isUnparsedPrepend(node: Node): node is UnparsedPrepend;
    function isSourceFile(node: Node): node is SourceFile;
    function isBundle(node: Node): node is Bundle;
    /** @deprecated */
    function isUnparsedSource(node: Node): node is UnparsedSource;
    function isJSDocTypeExpression(node: Node): node is JSDocTypeExpression;
    function isJSDocNameReference(node: Node): node is JSDocNameReference;
    function isJSDocMemberName(node: Node): node is JSDocMemberName;
    function isJSDocLink(node: Node): node is JSDocLink;
    function isJSDocLinkCode(node: Node): node is JSDocLinkCode;
    function isJSDocLinkPlain(node: Node): node is JSDocLinkPlain;
    function isJSDocAllType(node: Node): node is JSDocAllType;
    function isJSDocUnknownType(node: Node): node is JSDocUnknownType;
    function isJSDocNullableType(node: Node): node is JSDocNullableType;
    function isJSDocNonNullableType(node: Node): node is JSDocNonNullableType;
    function isJSDocOptionalType(node: Node): node is JSDocOptionalType;
    function isJSDocFunctionType(node: Node): node is JSDocFunctionType;
    function isJSDocVariadicType(node: Node): node is JSDocVariadicType;
    function isJSDocNamepathType(node: Node): node is JSDocNamepathType;
    function isJSDoc(node: Node): node is JSDoc;
    function isJSDocTypeLiteral(node: Node): node is JSDocTypeLiteral;
    function isJSDocSignature(node: Node): node is JSDocSignature;
    function isJSDocAugmentsTag(node: Node): node is JSDocAugmentsTag;
    function isJSDocAuthorTag(node: Node): node is JSDocAuthorTag;
    function isJSDocClassTag(node: Node): node is JSDocClassTag;
    function isJSDocCallbackTag(node: Node): node is JSDocCallbackTag;
    function isJSDocPublicTag(node: Node): node is JSDocPublicTag;
    function isJSDocPrivateTag(node: Node): node is JSDocPrivateTag;
    function isJSDocProtectedTag(node: Node): node is JSDocProtectedTag;
    function isJSDocReadonlyTag(node: Node): node is JSDocReadonlyTag;
    function isJSDocOverrideTag(node: Node): node is JSDocOverrideTag;
    function isJSDocOverloadTag(node: Node): node is JSDocOverloadTag;
    function isJSDocDeprecatedTag(node: Node): node is JSDocDeprecatedTag;
    function isJSDocSeeTag(node: Node): node is JSDocSeeTag;
    function isJSDocEnumTag(node: Node): node is JSDocEnumTag;
    function isJSDocParameterTag(node: Node): node is JSDocParameterTag;
    function isJSDocReturnTag(node: Node): node is JSDocReturnTag;
    function isJSDocThisTag(node: Node): node is JSDocThisTag;
    function isJSDocTypeTag(node: Node): node is JSDocTypeTag;
    function isJSDocTemplateTag(node: Node): node is JSDocTemplateTag;
    function isJSDocTypedefTag(node: Node): node is JSDocTypedefTag;
    function isJSDocUnknownTag(node: Node): node is JSDocUnknownTag;
    function isJSDocPropertyTag(node: Node): node is JSDocPropertyTag;
    function isJSDocImplementsTag(node: Node): node is JSDocImplementsTag;
    function isJSDocSatisfiesTag(node: Node): node is JSDocSatisfiesTag;
    function isJSDocThrowsTag(node: Node): node is JSDocThrowsTag;
    function isQuestionOrExclamationToken(node: Node): node is QuestionToken | ExclamationToken;
    function isIdentifierOrThisTypeNode(node: Node): node is Identifier | ThisTypeNode;
    function isReadonlyKeywordOrPlusOrMinusToken(node: Node): node is ReadonlyKeyword | PlusToken | MinusToken;
    function isQuestionOrPlusOrMinusToken(node: Node): node is QuestionToken | PlusToken | MinusToken;
    function isModuleName(node: Node): node is ModuleName;
    function isBinaryOperatorToken(node: Node): node is BinaryOperatorToken;
    function setTextRange<T extends TextRange>(range: T, location: TextRange | undefined): T;
    function canHaveModifiers(node: Node): node is HasModifiers;
    function canHaveDecorators(node: Node): node is HasDecorators;
    /**
     * Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes
     * stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,
     * embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns
     * a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.
     *
     * @param node a given node to visit its children
     * @param cbNode a callback to be invoked for all child nodes
     * @param cbNodes a callback to be invoked for embedded array
     *
     * @remarks `forEachChild` must visit the children of a node in the order
     * that they appear in the source code. The language service depends on this property to locate nodes by position.
     */
    function forEachChild<T>(node: Node, cbNode: (node: Node) => T | undefined, cbNodes?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;
    function createSourceFile(fileName: string, sourceText: string, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, setParentNodes?: boolean, scriptKind?: ScriptKind): SourceFile;
    function parseIsolatedEntityName(text: string, languageVersion: ScriptTarget): EntityName | undefined;
    /**
     * Parse json text into SyntaxTree and return node and parse errors if any
     * @param fileName
     * @param sourceText
     */
    function parseJsonText(fileName: string, sourceText: string): JsonSourceFile;
    function isExternalModule(file: SourceFile): boolean;
    function updateSourceFile(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks?: boolean): SourceFile;
    interface CreateSourceFileOptions {
        languageVersion: ScriptTarget;
        /**
         * Controls the format the file is detected as - this can be derived from only the path
         * and files on disk, but needs to be done with a module resolution cache in scope to be performant.
         * This is usually `undefined` for compilations that do not have `moduleResolution` values of `node16` or `nodenext`.
         */
        impliedNodeFormat?: ResolutionMode;
        /**
         * Controls how module-y-ness is set for the given file. Usually the result of calling
         * `getSetExternalModuleIndicator` on a valid `CompilerOptions` object. If not present, the default
         * check specified by `isFileProbablyExternalModule` will be used to set the field.
         */
        setExternalModuleIndicator?: (file: SourceFile) => void;
    }
    function parseCommandLine(commandLine: readonly string[], readFile?: (path: string) => string | undefined): ParsedCommandLine;
    /**
     * Reads the config file, reports errors if any and exits if the config file cannot be found
     */
    function getParsedCommandLineOfConfigFile(configFileName: string, optionsToExtend: CompilerOptions | undefined, host: ParseConfigFileHost, extendedConfigCache?: Map<string, ExtendedConfigCacheEntry>, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): ParsedCommandLine | undefined;
    /**
     * Read tsconfig.json file
     * @param fileName The path to the config file
     */
    function readConfigFile(fileName: string, readFile: (path: string) => string | undefined): {
        config?: any;
        error?: Diagnostic;
    };
    /**
     * Parse the text of the tsconfig.json file
     * @param fileName The path to the config file
     * @param jsonText The text of the config file
     */
    function parseConfigFileTextToJson(fileName: string, jsonText: string): {
        config?: any;
        error?: Diagnostic;
    };
    /**
     * Read tsconfig.json file
     * @param fileName The path to the config file
     */
    function readJsonConfigFile(fileName: string, readFile: (path: string) => string | undefined): TsConfigSourceFile;
    /**
     * Convert the json syntax tree into the json value
     */
    function convertToObject(sourceFile: JsonSourceFile, errors: Diagnostic[]): any;
    /**
     * Parse the contents of a config file (tsconfig.json).
     * @param json The contents of the config file to parse
     * @param host Instance of ParseConfigHost used to enumerate files in folder.
     * @param basePath A root directory to resolve relative path entries in the config
     *    file to. e.g. outDir
     */
    function parseJsonConfigFileContent(json: any, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: readonly FileExtensionInfo[], extendedConfigCache?: Map<string, ExtendedConfigCacheEntry>, existingWatchOptions?: WatchOptions): ParsedCommandLine;
    /**
     * Parse the contents of a config file (tsconfig.json).
     * @param jsonNode The contents of the config file to parse
     * @param host Instance of ParseConfigHost used to enumerate files in folder.
     * @param basePath A root directory to resolve relative path entries in the config
     *    file to. e.g. outDir
     */
    function parseJsonSourceFileConfigFileContent(sourceFile: TsConfigSourceFile, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: readonly FileExtensionInfo[], extendedConfigCache?: Map<string, ExtendedConfigCacheEntry>, existingWatchOptions?: WatchOptions): ParsedCommandLine;
    function convertCompilerOptionsFromJson(jsonOptions: any, basePath: string, configFileName?: string): {
        options: CompilerOptions;
        errors: Diagnostic[];
    };
    function convertTypeAcquisitionFromJson(jsonOptions: any, basePath: string, configFileName?: string): {
        options: TypeAcquisition;
        errors: Diagnostic[];
    };
    type DiagnosticReporter = (diagnostic: Diagnostic) => void;
    /**
     * Reports config file diagnostics
     */
    interface ConfigFileDiagnosticsReporter {
        /**
         * Reports unrecoverable error when parsing config file
         */
        onUnRecoverableConfigFileDiagnostic: DiagnosticReporter;
    }
    /**
     * Interface extending ParseConfigHost to support ParseConfigFile that reads config file and reports errors
     */
    interface ParseConfigFileHost extends ParseConfigHost, ConfigFileDiagnosticsReporter {
        getCurrentDirectory(): string;
    }
    interface ParsedTsconfig {
        raw: any;
        options?: CompilerOptions;
        watchOptions?: WatchOptions;
        typeAcquisition?: TypeAcquisition;
        /**
         * Note that the case of the config path has not yet been normalized, as no files have been imported into the project yet
         */
        extendedConfigPath?: string | string[];
    }
    interface ExtendedConfigCacheEntry {
        extendedResult: TsConfigSourceFile;
        extendedConfig: ParsedTsconfig | undefined;
    }
    function getEffectiveTypeRoots(options: CompilerOptions, host: GetEffectiveTypeRootsHost): string[] | undefined;
    /**
     * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.
     * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups
     * is assumed to be the same as root directory of the project.
     */
    function resolveTypeReferenceDirective(typeReferenceDirectiveName: string, containingFile: string | undefined, options: CompilerOptions, host: ModuleResolutionHost, redirectedReference?: ResolvedProjectReference, cache?: TypeReferenceDirectiveResolutionCache, resolutionMode?: ResolutionMode): ResolvedTypeReferenceDirectiveWithFailedLookupLocations;
    /**
     * Given a set of options, returns the set of type directive names
     *   that should be included for this program automatically.
     * This list could either come from the config file,
     *   or from enumerating the types root + initial secondary types lookup location.
     * More type directives might appear in the program later as a result of loading actual source files;
     *   this list is only the set of defaults that are implicitly included.
     */
    function getAutomaticTypeDirectiveNames(options: CompilerOptions, host: ModuleResolutionHost): string[];
    function createModuleResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions): ModuleResolutionCache;
    function createTypeReferenceDirectiveResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions, packageJsonInfoCache?: PackageJsonInfoCache): TypeReferenceDirectiveResolutionCache;
    function resolveModuleNameFromCache(moduleName: string, containingFile: string, cache: ModuleResolutionCache, mode?: ResolutionMode): ResolvedModuleWithFailedLookupLocations | undefined;
    function resolveModuleName(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference, resolutionMode?: ResolutionMode): ResolvedModuleWithFailedLookupLocations;
    function bundlerModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
    function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
    function classicNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
    interface TypeReferenceDirectiveResolutionCache extends PerDirectoryResolutionCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, NonRelativeNameResolutionCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, PackageJsonInfoCache {
    }
    interface ModeAwareCache<T> {
        get(key: string, mode: ResolutionMode): T | undefined;
        set(key: string, mode: ResolutionMode, value: T): this;
        delete(key: string, mode: ResolutionMode): this;
        has(key: string, mode: ResolutionMode): boolean;
        forEach(cb: (elem: T, key: string, mode: ResolutionMode) => void): void;
        size(): number;
    }
    /**
     * Cached resolutions per containing directory.
     * This assumes that any module id will have the same resolution for sibling files located in the same folder.
     */
    interface PerDirectoryResolutionCache<T> {
        getFromDirectoryCache(name: string, mode: ResolutionMode, directoryName: string, redirectedReference: ResolvedProjectReference | undefined): T | undefined;
        getOrCreateCacheForDirectory(directoryName: string, redirectedReference?: ResolvedProjectReference): ModeAwareCache<T>;
        clear(): void;
        /**
         *  Updates with the current compilerOptions the cache will operate with.
         *  This updates the redirects map as well if needed so module resolutions are cached if they can across the projects
         */
        update(options: CompilerOptions): void;
    }
    interface NonRelativeNameResolutionCache<T> {
        getFromNonRelativeNameCache(nonRelativeName: string, mode: ResolutionMode, directoryName: string, redirectedReference: ResolvedProjectReference | undefined): T | undefined;
        getOrCreateCacheForNonRelativeName(nonRelativeName: string, mode: ResolutionMode, redirectedReference?: ResolvedProjectReference): PerNonRelativeNameCache<T>;
        clear(): void;
        /**
         *  Updates with the current compilerOptions the cache will operate with.
         *  This updates the redirects map as well if needed so module resolutions are cached if they can across the projects
         */
        update(options: CompilerOptions): void;
    }
    interface PerNonRelativeNameCache<T> {
        get(directory: string): T | undefined;
        set(directory: string, result: T): void;
    }
    interface ModuleResolutionCache extends PerDirectoryResolutionCache<ResolvedModuleWithFailedLookupLocations>, NonRelativeModuleNameResolutionCache, PackageJsonInfoCache {
        getPackageJsonInfoCache(): PackageJsonInfoCache;
    }
    /**
     * Stored map from non-relative module name to a table: directory -> result of module lookup in this directory
     * We support only non-relative module names because resolution of relative module names is usually more deterministic and thus less expensive.
     */
    interface NonRelativeModuleNameResolutionCache extends NonRelativeNameResolutionCache<ResolvedModuleWithFailedLookupLocations>, PackageJsonInfoCache {
        /** @deprecated Use getOrCreateCacheForNonRelativeName */
        getOrCreateCacheForModuleName(nonRelativeModuleName: string, mode: ResolutionMode, redirectedReference?: ResolvedProjectReference): PerModuleNameCache;
    }
    interface PackageJsonInfoCache {
        clear(): void;
    }
    type PerModuleNameCache = PerNonRelativeNameCache<ResolvedModuleWithFailedLookupLocations>;
    /**
     * Visits a Node using the supplied visitor, possibly returning a new Node in its place.
     *
     * - If the input node is undefined, then the output is undefined.
     * - If the visitor returns undefined, then the output is undefined.
     * - If the output node is not undefined, then it will satisfy the test function.
     * - In order to obtain a return type that is more specific than `Node`, a test
     *   function _must_ be provided, and that function must be a type predicate.
     *
     * @param node The Node to visit.
     * @param visitor The callback used to visit the Node.
     * @param test A callback to execute to verify the Node is valid.
     * @param lift An optional callback to execute to lift a NodeArray into a valid Node.
     */
    function visitNode<TIn extends Node | undefined, TVisited extends Node | undefined, TOut extends Node>(node: TIn, visitor: Visitor<NonNullable<TIn>, TVisited>, test: (node: Node) => node is TOut, lift?: (node: readonly Node[]) => Node): TOut | (TIn & undefined) | (TVisited & undefined);
    /**
     * Visits a Node using the supplied visitor, possibly returning a new Node in its place.
     *
     * - If the input node is undefined, then the output is undefined.
     * - If the visitor returns undefined, then the output is undefined.
     * - If the output node is not undefined, then it will satisfy the test function.
     * - In order to obtain a return type that is more specific than `Node`, a test
     *   function _must_ be provided, and that function must be a type predicate.
     *
     * @param node The Node to visit.
     * @param visitor The callback used to visit the Node.
     * @param test A callback to execute to verify the Node is valid.
     * @param lift An optional callback to execute to lift a NodeArray into a valid Node.
     */
    function visitNode<TIn extends Node | undefined, TVisited extends Node | undefined>(node: TIn, visitor: Visitor<NonNullable<TIn>, TVisited>, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => Node): Node | (TIn & undefined) | (TVisited & undefined);
    /**
     * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.
     *
     * - If the input node array is undefined, the output is undefined.
     * - If the visitor can return undefined, the node it visits in the array will be reused.
     * - If the output node array is not undefined, then its contents will satisfy the test.
     * - In order to obtain a return type that is more specific than `NodeArray<Node>`, a test
     *   function _must_ be provided, and that function must be a type predicate.
     *
     * @param nodes The NodeArray to visit.
     * @param visitor The callback used to visit a Node.
     * @param test A node test to execute for each node.
     * @param start An optional value indicating the starting offset at which to start visiting.
     * @param count An optional value indicating the maximum number of nodes to visit.
     */
    function visitNodes<TIn extends Node, TInArray extends NodeArray<TIn> | undefined, TOut extends Node>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test: (node: Node) => node is TOut, start?: number, count?: number): NodeArray<TOut> | (TInArray & undefined);
    /**
     * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.
     *
     * - If the input node array is undefined, the output is undefined.
     * - If the visitor can return undefined, the node it visits in the array will be reused.
     * - If the output node array is not undefined, then its contents will satisfy the test.
     * - In order to obtain a return type that is more specific than `NodeArray<Node>`, a test
     *   function _must_ be provided, and that function must be a type predicate.
     *
     * @param nodes The NodeArray to visit.
     * @param visitor The callback used to visit a Node.
     * @param test A node test to execute for each node.
     * @param start An optional value indicating the starting offset at which to start visiting.
     * @param count An optional value indicating the maximum number of nodes to visit.
     */
    function visitNodes<TIn extends Node, TInArray extends NodeArray<TIn> | undefined>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<Node> | (TInArray & undefined);
    /**
     * Starts a new lexical environment and visits a statement list, ending the lexical environment
     * and merging hoisted declarations upon completion.
     */
    function visitLexicalEnvironment(statements: NodeArray<Statement>, visitor: Visitor, context: TransformationContext, start?: number, ensureUseStrict?: boolean, nodesVisitor?: NodesVisitor): NodeArray<Statement>;
    /**
     * Starts a new lexical environment and visits a parameter list, suspending the lexical
     * environment upon completion.
     */
    function visitParameterList(nodes: NodeArray<ParameterDeclaration>, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration>;
    function visitParameterList(nodes: NodeArray<ParameterDeclaration> | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration> | undefined;
    /**
     * Resumes a suspended lexical environment and visits a function body, ending the lexical
     * environment and merging hoisted declarations upon completion.
     */
    function visitFunctionBody(node: FunctionBody, visitor: Visitor, context: TransformationContext): FunctionBody;
    /**
     * Resumes a suspended lexical environment and visits a function body, ending the lexical
     * environment and merging hoisted declarations upon completion.
     */
    function visitFunctionBody(node: FunctionBody | undefined, visitor: Visitor, context: TransformationContext): FunctionBody | undefined;
    /**
     * Resumes a suspended lexical environment and visits a concise body, ending the lexical
     * environment and merging hoisted declarations upon completion.
     */
    function visitFunctionBody(node: ConciseBody, visitor: Visitor, context: TransformationContext): ConciseBody;
    /**
     * Visits an iteration body, adding any block-scoped variables required by the transformation.
     */
    function visitIterationBody(body: Statement, visitor: Visitor, context: TransformationContext): Statement;
    /**
     * Visits the elements of a {@link CommaListExpression}.
     * @param visitor The visitor to use when visiting expressions whose result will not be discarded at runtime.
     * @param discardVisitor The visitor to use when visiting expressions whose result will be discarded at runtime. Defaults to {@link visitor}.
     */
    function visitCommaListElements(elements: NodeArray<Expression>, visitor: Visitor, discardVisitor?: Visitor): NodeArray<Expression>;
    /**
     * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.
     *
     * @param node The Node whose children will be visited.
     * @param visitor The callback used to visit each child.
     * @param context A lexical environment context for the visitor.
     */
    function visitEachChild<T extends Node>(node: T, visitor: Visitor, context: TransformationContext): T;
    /**
     * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.
     *
     * @param node The Node whose children will be visited.
     * @param visitor The callback used to visit each child.
     * @param context A lexical environment context for the visitor.
     */
    function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: typeof visitNodes, tokenVisitor?: Visitor): T | undefined;
    function getTsBuildInfoEmitOutputFilePath(options: CompilerOptions): string | undefined;
    function getOutputFileNames(commandLine: ParsedCommandLine, inputFileName: string, ignoreCase: boolean): readonly string[];
    function createPrinter(printerOptions?: PrinterOptions, handlers?: PrintHandlers): Printer;
    function findConfigFile(searchPath: string, fileExists: (fileName: string) => boolean, configName?: string): string | undefined;
    function resolveTripleslashReference(moduleName: string, containingFile: string): string;
    function createCompilerHost(options: CompilerOptions, setParentNodes?: boolean): CompilerHost;
    function getPreEmitDiagnostics(program: Program, sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
    function formatDiagnostics(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;
    function formatDiagnostic(diagnostic: Diagnostic, host: FormatDiagnosticsHost): string;
    function formatDiagnosticsWithColorAndContext(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;
    function flattenDiagnosticMessageText(diag: string | DiagnosticMessageChain | undefined, newLine: string, indent?: number): string;
    /**
     * Calculates the resulting resolution mode for some reference in some file - this is generally the explicitly
     * provided resolution mode in the reference, unless one is not present, in which case it is the mode of the containing file.
     */
    function getModeForFileReference(ref: FileReference | string, containingFileMode: ResolutionMode): ts.ResolutionMode;
    /**
     * Calculates the final resolution mode for an import at some index within a file's imports list. This is generally the explicitly
     * defined mode of the import if provided, or, if not, the mode of the containing file (with some exceptions: import=require is always commonjs, dynamic import is always esm).
     * If you have an actual import node, prefer using getModeForUsageLocation on the reference string node.
     * @param file File to fetch the resolution mode within
     * @param index Index into the file's complete resolution list to get the resolution of - this is a concatenation of the file's imports and module augmentations
     */
    function getModeForResolutionAtIndex(file: SourceFile, index: number): ResolutionMode;
    /**
     * Calculates the final resolution mode for a given module reference node. This is generally the explicitly provided resolution mode, if
     * one exists, or the mode of the containing source file. (Excepting import=require, which is always commonjs, and dynamic import, which is always esm).
     * Notably, this function always returns `undefined` if the containing file has an `undefined` `impliedNodeFormat` - this field is only set when
     * `moduleResolution` is `node16`+.
     * @param file The file the import or import-like reference is contained within
     * @param usage The module reference string
     * @returns The final resolution mode of the import
     */
    function getModeForUsageLocation(file: {
        impliedNodeFormat?: ResolutionMode;
    }, usage: StringLiteralLike): ts.ModuleKind.CommonJS | ts.ModuleKind.ESNext | undefined;
    function getConfigFileParsingDiagnostics(configFileParseResult: ParsedCommandLine): readonly Diagnostic[];
    /**
     * A function for determining if a given file is esm or cjs format, assuming modern node module resolution rules, as configured by the
     * `options` parameter.
     *
     * @param fileName The normalized absolute path to check the format of (it need not exist on disk)
     * @param [packageJsonInfoCache] A cache for package file lookups - it's best to have a cache when this function is called often
     * @param host The ModuleResolutionHost which can perform the filesystem lookups for package json data
     * @param options The compiler options to perform the analysis under - relevant options are `moduleResolution` and `traceResolution`
     * @returns `undefined` if the path has no relevant implied format, `ModuleKind.ESNext` for esm format, and `ModuleKind.CommonJS` for cjs format
     */
    function getImpliedNodeFormatForFile(fileName: Path, packageJsonInfoCache: PackageJsonInfoCache | undefined, host: ModuleResolutionHost, options: CompilerOptions): ResolutionMode;
    /**
     * Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'
     * that represent a compilation unit.
     *
     * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and
     * triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.
     *
     * @param createProgramOptions - The options for creating a program.
     * @returns A 'Program' object.
     */
    function createProgram(createProgramOptions: CreateProgramOptions): Program;
    /**
     * Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'
     * that represent a compilation unit.
     *
     * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and
     * triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.
     *
     * @param rootNames - A set of root files.
     * @param options - The compiler options which should be used.
     * @param host - The host interacts with the underlying file system.
     * @param oldProgram - Reuses an old program structure.
     * @param configFileParsingDiagnostics - error during config file parsing
     * @returns A 'Program' object.
     */
    function createProgram(rootNames: readonly string[], options: CompilerOptions, host?: CompilerHost, oldProgram?: Program, configFileParsingDiagnostics?: readonly Diagnostic[]): Program;
    /**
     * Returns the target config filename of a project reference.
     * Note: The file might not exist.
     */
    function resolveProjectReferencePath(ref: ProjectReference): ResolvedConfigFileName;
    interface FormatDiagnosticsHost {
        getCurrentDirectory(): string;
        getCanonicalFileName(fileName: string): string;
        getNewLine(): string;
    }
    interface EmitOutput {
        outputFiles: OutputFile[];
        emitSkipped: boolean;
    }
    interface OutputFile {
        name: string;
        writeByteOrderMark: boolean;
        text: string;
    }
    /**
     * Create the builder to manage semantic diagnostics and cache them
     */
    function createSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): SemanticDiagnosticsBuilderProgram;
    function createSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): SemanticDiagnosticsBuilderProgram;
    /**
     * Create the builder that can handle the changes in program and iterate through changed files
     * to emit the those files and manage semantic diagnostics cache as well
     */
    function createEmitAndSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): EmitAndSemanticDiagnosticsBuilderProgram;
    function createEmitAndSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): EmitAndSemanticDiagnosticsBuilderProgram;
    /**
     * Creates a builder thats just abstraction over program and can be used with watch
     */
    function createAbstractBuilder(newProgram: Program, host: BuilderProgramHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): BuilderProgram;
    function createAbstractBuilder(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): BuilderProgram;
    type AffectedFileResult<T> = {
        result: T;
        affected: SourceFile | Program;
    } | undefined;
    interface BuilderProgramHost {
        /**
         * If provided this would be used this hash instead of actual file shape text for detecting changes
         */
        createHash?: (data: string) => string;
        /**
         * When emit or emitNextAffectedFile are called without writeFile,
         * this callback if present would be used to write files
         */
        writeFile?: WriteFileCallback;
    }
    /**
     * Builder to manage the program state changes
     */
    interface BuilderProgram {
        /**
         * Returns current program
         */
        getProgram(): Program;
        /**
         * Get compiler options of the program
         */
        getCompilerOptions(): CompilerOptions;
        /**
         * Get the source file in the program with file name
         */
        getSourceFile(fileName: string): SourceFile | undefined;
        /**
         * Get a list of files in the program
         */
        getSourceFiles(): readonly SourceFile[];
        /**
         * Get the diagnostics for compiler options
         */
        getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
        /**
         * Get the diagnostics that dont belong to any file
         */
        getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
        /**
         * Get the diagnostics from config file parsing
         */
        getConfigFileParsingDiagnostics(): readonly Diagnostic[];
        /**
         * Get the syntax diagnostics, for all source files if source file is not supplied
         */
        getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
        /**
         * Get the declaration diagnostics, for all source files if source file is not supplied
         */
        getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
        /**
         * Get all the dependencies of the file
         */
        getAllDependencies(sourceFile: SourceFile): readonly string[];
        /**
         * Gets the semantic diagnostics from the program corresponding to this state of file (if provided) or whole program
         * The semantic diagnostics are cached and managed here
         * Note that it is assumed that when asked about semantic diagnostics through this API,
         * the file has been taken out of affected files so it is safe to use cache or get from program and cache the diagnostics
         * In case of SemanticDiagnosticsBuilderProgram if the source file is not provided,
         * it will iterate through all the affected files, to ensure that cache stays valid and yet provide a way to get all semantic diagnostics
         */
        getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
        /**
         * Emits the JavaScript and declaration files.
         * When targetSource file is specified, emits the files corresponding to that source file,
         * otherwise for the whole program.
         * In case of EmitAndSemanticDiagnosticsBuilderProgram, when targetSourceFile is specified,
         * it is assumed that that file is handled from affected file list. If targetSourceFile is not specified,
         * it will only emit all the affected files instead of whole program
         *
         * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host
         * in that order would be used to write the files
         */
        emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;
        /**
         * Get the current directory of the program
         */
        getCurrentDirectory(): string;
    }
    /**
     * The builder that caches the semantic diagnostics for the program and handles the changed files and affected files
     */
    interface SemanticDiagnosticsBuilderProgram extends BuilderProgram {
        /**
         * Gets the semantic diagnostics from the program for the next affected file and caches it
         * Returns undefined if the iteration is complete
         */
        getSemanticDiagnosticsOfNextAffectedFile(cancellationToken?: CancellationToken, ignoreSourceFile?: (sourceFile: SourceFile) => boolean): AffectedFileResult<readonly Diagnostic[]>;
    }
    /**
     * The builder that can handle the changes in program and iterate through changed file to emit the files
     * The semantic diagnostics are cached per file and managed by clearing for the changed/affected files
     */
    interface EmitAndSemanticDiagnosticsBuilderProgram extends SemanticDiagnosticsBuilderProgram {
        /**
         * Emits the next affected file's emit result (EmitResult and sourceFiles emitted) or returns undefined if iteration is complete
         * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host
         * in that order would be used to write the files
         */
        emitNextAffectedFile(writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): AffectedFileResult<EmitResult>;
    }
    function readBuilderProgram(compilerOptions: CompilerOptions, host: ReadBuildProgramHost): ts.EmitAndSemanticDiagnosticsBuilderProgram | undefined;
    function createIncrementalCompilerHost(options: CompilerOptions, system?: ts.System): CompilerHost;
    function createIncrementalProgram<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>({ rootNames, options, configFileParsingDiagnostics, projectReferences, host, createProgram }: IncrementalProgramOptions<T>): T;
    /**
     * Create the watch compiler host for either configFile or fileNames and its options
     */
    function createWatchCompilerHost<T extends BuilderProgram>(configFileName: string, optionsToExtend: CompilerOptions | undefined, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): WatchCompilerHostOfConfigFile<T>;
    function createWatchCompilerHost<T extends BuilderProgram>(rootFiles: string[], options: CompilerOptions, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, projectReferences?: readonly ProjectReference[], watchOptions?: WatchOptions): WatchCompilerHostOfFilesAndCompilerOptions<T>;
    /**
     * Creates the watch from the host for root files and compiler options
     */
    function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfFilesAndCompilerOptions<T>): WatchOfFilesAndCompilerOptions<T>;
    /**
     * Creates the watch from the host for config file
     */
    function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfConfigFile<T>): WatchOfConfigFile<T>;
    interface ReadBuildProgramHost {
        useCaseSensitiveFileNames(): boolean;
        getCurrentDirectory(): string;
        readFile(fileName: string): string | undefined;
    }
    interface IncrementalProgramOptions<T extends BuilderProgram> {
        rootNames: readonly string[];
        options: CompilerOptions;
        configFileParsingDiagnostics?: readonly Diagnostic[];
        projectReferences?: readonly ProjectReference[];
        host?: CompilerHost;
        createProgram?: CreateProgram<T>;
    }
    type WatchStatusReporter = (diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number) => void;
    /** Create the program with rootNames and options, if they are undefined, oldProgram and new configFile diagnostics create new program */
    type CreateProgram<T extends BuilderProgram> = (rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: T, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[] | undefined) => T;
    /** Host that has watch functionality used in --watch mode */
    interface WatchHost {
        /** If provided, called with Diagnostic message that informs about change in watch status */
        onWatchStatusChange?(diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number): void;
        /** Used to watch changes in source files, missing files needed to update the program or config file */
        watchFile(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;
        /** Used to watch resolved module's failed lookup locations, config file specs, type roots where auto type reference directives are added */
        watchDirectory(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;
        /** If provided, will be used to set delayed compilation, so that multiple changes in short span are compiled together */
        setTimeout?(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;
        /** If provided, will be used to reset existing delayed compilation */
        clearTimeout?(timeoutId: any): void;
    }
    interface ProgramHost<T extends BuilderProgram> {
        /**
         * Used to create the program when need for program creation or recreation detected
         */
        createProgram: CreateProgram<T>;
        useCaseSensitiveFileNames(): boolean;
        getNewLine(): string;
        getCurrentDirectory(): string;
        getDefaultLibFileName(options: CompilerOptions): string;
        getDefaultLibLocation?(): string;
        createHash?(data: string): string;
        /**
         * Use to check file presence for source files and
         * if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well
         */
        fileExists(path: string): boolean;
        /**
         * Use to read file text for source files and
         * if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well
         */
        readFile(path: string, encoding?: string): string | undefined;
        /** If provided, used for module resolution as well as to handle directory structure */
        directoryExists?(path: string): boolean;
        /** If provided, used in resolutions as well as handling directory structure */
        getDirectories?(path: string): string[];
        /** If provided, used to cache and handle directory structure modifications */
        readDirectory?(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
        /** Symbol links resolution */
        realpath?(path: string): string;
        /** If provided would be used to write log about compilation */
        trace?(s: string): void;
        /** If provided is used to get the environment variable */
        getEnvironmentVariable?(name: string): string | undefined;
        /**
         * @deprecated supply resolveModuleNameLiterals instead for resolution that can handle newer resolution modes like nodenext
         *
         * If provided, used to resolve the module names, otherwise typescript's default module resolution
         */
        resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];
        /**
         * @deprecated supply resolveTypeReferenceDirectiveReferences instead for resolution that can handle newer resolution modes like nodenext
         *
         * If provided, used to resolve type reference directives, otherwise typescript's default resolution
         */
        resolveTypeReferenceDirectives?(typeReferenceDirectiveNames: string[] | readonly FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: ResolutionMode): (ResolvedTypeReferenceDirective | undefined)[];
        resolveModuleNameLiterals?(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[];
        resolveTypeReferenceDirectiveReferences?<T extends FileReference | string>(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[];
        /** If provided along with custom resolveModuleNames or resolveTypeReferenceDirectives, used to determine if unchanged file path needs to re-resolve modules/type reference directives */
        hasInvalidatedResolutions?(filePath: Path): boolean;
        /**
         * Returns the module resolution cache used by a provided `resolveModuleNames` implementation so that any non-name module resolution operations (eg, package.json lookup) can reuse it
         */
        getModuleResolutionCache?(): ModuleResolutionCache | undefined;
    }
    interface WatchCompilerHost<T extends BuilderProgram> extends ProgramHost<T>, WatchHost {
        /** Instead of using output d.ts file from project reference, use its source file */
        useSourceOfProjectReferenceRedirect?(): boolean;
        /** If provided, use this method to get parsed command lines for referenced projects */
        getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
        /** If provided, callback to invoke after every new program creation */
        afterProgramCreate?(program: T): void;
    }
    /**
     * Host to create watch with root files and options
     */
    interface WatchCompilerHostOfFilesAndCompilerOptions<T extends BuilderProgram> extends WatchCompilerHost<T> {
        /** root files to use to generate program */
        rootFiles: string[];
        /** Compiler options */
        options: CompilerOptions;
        watchOptions?: WatchOptions;
        /** Project References */
        projectReferences?: readonly ProjectReference[];
    }
    /**
     * Host to create watch with config file
     */
    interface WatchCompilerHostOfConfigFile<T extends BuilderProgram> extends WatchCompilerHost<T>, ConfigFileDiagnosticsReporter {
        /** Name of the config file to compile */
        configFileName: string;
        /** Options to extend */
        optionsToExtend?: CompilerOptions;
        watchOptionsToExtend?: WatchOptions;
        extraFileExtensions?: readonly FileExtensionInfo[];
        /**
         * Used to generate source file names from the config file and its include, exclude, files rules
         * and also to cache the directory stucture
         */
        readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
    }
    interface Watch<T> {
        /** Synchronize with host and get updated program */
        getProgram(): T;
        /** Closes the watch */
        close(): void;
    }
    /**
     * Creates the watch what generates program using the config file
     */
    interface WatchOfConfigFile<T> extends Watch<T> {
    }
    /**
     * Creates the watch that generates program using the root files and compiler options
     */
    interface WatchOfFilesAndCompilerOptions<T> extends Watch<T> {
        /** Updates the root files in the program, only if this is not config file compilation */
        updateRootFileNames(fileNames: string[]): void;
    }
    /**
     * Create a function that reports watch status by writing to the system and handles the formating of the diagnostic
     */
    function createBuilderStatusReporter(system: System, pretty?: boolean): DiagnosticReporter;
    function createSolutionBuilderHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: ts.System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportErrorSummary?: ReportEmitErrorSummary): ts.SolutionBuilderHost<T>;
    function createSolutionBuilderWithWatchHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: ts.System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter): ts.SolutionBuilderWithWatchHost<T>;
    function createSolutionBuilder<T extends BuilderProgram>(host: SolutionBuilderHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions): SolutionBuilder<T>;
    function createSolutionBuilderWithWatch<T extends BuilderProgram>(host: SolutionBuilderWithWatchHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions, baseWatchOptions?: WatchOptions): SolutionBuilder<T>;
    interface BuildOptions {
        dry?: boolean;
        force?: boolean;
        verbose?: boolean;
        incremental?: boolean;
        assumeChangesOnlyAffectDirectDependencies?: boolean;
        declaration?: boolean;
        declarationMap?: boolean;
        emitDeclarationOnly?: boolean;
        sourceMap?: boolean;
        inlineSourceMap?: boolean;
        traceResolution?: boolean;
        [option: string]: CompilerOptionsValue | undefined;
    }
    type ReportEmitErrorSummary = (errorCount: number, filesInError: (ReportFileInError | undefined)[]) => void;
    interface ReportFileInError {
        fileName: string;
        line: number;
    }
    interface SolutionBuilderHostBase<T extends BuilderProgram> extends ProgramHost<T> {
        createDirectory?(path: string): void;
        /**
         * Should provide create directory and writeFile if done of invalidatedProjects is not invoked with
         * writeFileCallback
         */
        writeFile?(path: string, data: string, writeByteOrderMark?: boolean): void;
        getCustomTransformers?: (project: string) => CustomTransformers | undefined;
        getModifiedTime(fileName: string): Date | undefined;
        setModifiedTime(fileName: string, date: Date): void;
        deleteFile(fileName: string): void;
        getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
        reportDiagnostic: DiagnosticReporter;
        reportSolutionBuilderStatus: DiagnosticReporter;
        afterProgramEmitAndDiagnostics?(program: T): void;
    }
    interface SolutionBuilderHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T> {
        reportErrorSummary?: ReportEmitErrorSummary;
    }
    interface SolutionBuilderWithWatchHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T>, WatchHost {
    }
    interface SolutionBuilder<T extends BuilderProgram> {
        build(project?: string, cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, getCustomTransformers?: (project: string) => CustomTransformers): ExitStatus;
        clean(project?: string): ExitStatus;
        buildReferences(project: string, cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, getCustomTransformers?: (project: string) => CustomTransformers): ExitStatus;
        cleanReferences(project?: string): ExitStatus;
        getNextInvalidatedProject(cancellationToken?: CancellationToken): InvalidatedProject<T> | undefined;
    }
    enum InvalidatedProjectKind {
        Build = 0,
        /** @deprecated */ UpdateBundle = 1,
        UpdateOutputFileStamps = 2
    }
    interface InvalidatedProjectBase {
        readonly kind: InvalidatedProjectKind;
        readonly project: ResolvedConfigFileName;
        /**
         *  To dispose this project and ensure that all the necessary actions are taken and state is updated accordingly
         */
        done(cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, customTransformers?: CustomTransformers): ExitStatus;
        getCompilerOptions(): CompilerOptions;
        getCurrentDirectory(): string;
    }
    interface UpdateOutputFileStampsProject extends InvalidatedProjectBase {
        readonly kind: InvalidatedProjectKind.UpdateOutputFileStamps;
        updateOutputFileStatmps(): void;
    }
    interface BuildInvalidedProject<T extends BuilderProgram> extends InvalidatedProjectBase {
        readonly kind: InvalidatedProjectKind.Build;
        getBuilderProgram(): T | undefined;
        getProgram(): Program | undefined;
        getSourceFile(fileName: string): SourceFile | undefined;
        getSourceFiles(): readonly SourceFile[];
        getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
        getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
        getConfigFileParsingDiagnostics(): readonly Diagnostic[];
        getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
        getAllDependencies(sourceFile: SourceFile): readonly string[];
        getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
        getSemanticDiagnosticsOfNextAffectedFile(cancellationToken?: CancellationToken, ignoreSourceFile?: (sourceFile: SourceFile) => boolean): AffectedFileResult<readonly Diagnostic[]>;
        emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult | undefined;
    }
    /** @deprecated */
    interface UpdateBundleProject<T extends BuilderProgram> extends InvalidatedProjectBase {
        readonly kind: InvalidatedProjectKind.UpdateBundle;
        emit(writeFile?: WriteFileCallback, customTransformers?: CustomTransformers): EmitResult | BuildInvalidedProject<T> | undefined;
    }
    type InvalidatedProject<T extends BuilderProgram> = UpdateOutputFileStampsProject | BuildInvalidedProject<T> | UpdateBundleProject<T>;
    namespace server {
        type ActionSet = "action::set";
        type ActionInvalidate = "action::invalidate";
        type ActionPackageInstalled = "action::packageInstalled";
        type EventTypesRegistry = "event::typesRegistry";
        type EventBeginInstallTypes = "event::beginInstallTypes";
        type EventEndInstallTypes = "event::endInstallTypes";
        type EventInitializationFailed = "event::initializationFailed";
        interface TypingInstallerResponse {
            readonly kind: ActionSet | ActionInvalidate | EventTypesRegistry | ActionPackageInstalled | EventBeginInstallTypes | EventEndInstallTypes | EventInitializationFailed;
        }
        interface TypingInstallerRequestWithProjectName {
            readonly projectName: string;
        }
        interface DiscoverTypings extends TypingInstallerRequestWithProjectName {
            readonly fileNames: string[];
            readonly projectRootPath: Path;
            readonly compilerOptions: CompilerOptions;
            readonly watchOptions?: WatchOptions;
            readonly typeAcquisition: TypeAcquisition;
            readonly unresolvedImports: SortedReadonlyArray<string>;
            readonly cachePath?: string;
            readonly kind: "discover";
        }
        interface CloseProject extends TypingInstallerRequestWithProjectName {
            readonly kind: "closeProject";
        }
        interface TypesRegistryRequest {
            readonly kind: "typesRegistry";
        }
        interface InstallPackageRequest extends TypingInstallerRequestWithProjectName {
            readonly kind: "installPackage";
            readonly fileName: Path;
            readonly packageName: string;
            readonly projectRootPath: Path;
        }
        interface PackageInstalledResponse extends ProjectResponse {
            readonly kind: ActionPackageInstalled;
            readonly success: boolean;
            readonly message: string;
        }
        interface InitializationFailedResponse extends TypingInstallerResponse {
            readonly kind: EventInitializationFailed;
            readonly message: string;
            readonly stack?: string;
        }
        interface ProjectResponse extends TypingInstallerResponse {
            readonly projectName: string;
        }
        interface InvalidateCachedTypings extends ProjectResponse {
            readonly kind: ActionInvalidate;
        }
        interface InstallTypes extends ProjectResponse {
            readonly kind: EventBeginInstallTypes | EventEndInstallTypes;
            readonly eventId: number;
            readonly typingsInstallerVersion: string;
            readonly packagesToInstall: readonly string[];
        }
        interface BeginInstallTypes extends InstallTypes {
            readonly kind: EventBeginInstallTypes;
        }
        interface EndInstallTypes extends InstallTypes {
            readonly kind: EventEndInstallTypes;
            readonly installSuccess: boolean;
        }
        interface SetTypings extends ProjectResponse {
            readonly typeAcquisition: TypeAcquisition;
            readonly compilerOptions: CompilerOptions;
            readonly typings: string[];
            readonly unresolvedImports: SortedReadonlyArray<string>;
            readonly kind: ActionSet;
        }
    }
    function getDefaultFormatCodeSettings(newLineCharacter?: string): FormatCodeSettings;
    /**
     * Represents an immutable snapshot of a script at a specified time.Once acquired, the
     * snapshot is observably immutable. i.e. the same calls with the same parameters will return
     * the same values.
     */
    interface IScriptSnapshot {
        /** Gets a portion of the script snapshot specified by [start, end). */
        getText(start: number, end: number): string;
        /** Gets the length of this script snapshot. */
        getLength(): number;
        /**
         * Gets the TextChangeRange that describe how the text changed between this text and
         * an older version.  This information is used by the incremental parser to determine
         * what sections of the script need to be re-parsed.  'undefined' can be returned if the
         * change range cannot be determined.  However, in that case, incremental parsing will
         * not happen and the entire document will be re - parsed.
         */
        getChangeRange(oldSnapshot: IScriptSnapshot): TextChangeRange | undefined;
        /** Releases all resources held by this script snapshot */
        dispose?(): void;
    }
    namespace ScriptSnapshot {
        function fromString(text: string): IScriptSnapshot;
    }
    interface PreProcessedFileInfo {
        referencedFiles: FileReference[];
        typeReferenceDirectives: FileReference[];
        libReferenceDirectives: FileReference[];
        importedFiles: FileReference[];
        ambientExternalModules?: string[];
        isLibFile: boolean;
    }
    interface HostCancellationToken {
        isCancellationRequested(): boolean;
    }
    interface InstallPackageOptions {
        fileName: Path;
        packageName: string;
    }
    interface PerformanceEvent {
        kind: "UpdateGraph" | "CreatePackageJsonAutoImportProvider";
        durationMs: number;
    }
    enum LanguageServiceMode {
        Semantic = 0,
        PartialSemantic = 1,
        Syntactic = 2
    }
    interface IncompleteCompletionsCache {
        get(): CompletionInfo | undefined;
        set(response: CompletionInfo): void;
        clear(): void;
    }
    interface LanguageServiceHost extends GetEffectiveTypeRootsHost, MinimalResolutionCacheHost {
        getCompilationSettings(): CompilerOptions;
        getNewLine?(): string;
        getProjectVersion?(): string;
        getScriptFileNames(): string[];
        getScriptKind?(fileName: string): ScriptKind;
        getScriptVersion(fileName: string): string;
        getScriptSnapshot(fileName: string): IScriptSnapshot | undefined;
        getProjectReferences?(): readonly ProjectReference[] | undefined;
        getLocalizedDiagnosticMessages?(): any;
        getCancellationToken?(): HostCancellationToken;
        getCurrentDirectory(): string;
        getDefaultLibFileName(options: CompilerOptions): string;
        log?(s: string): void;
        trace?(s: string): void;
        error?(s: string): void;
        useCaseSensitiveFileNames?(): boolean;
        readDirectory?(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
        realpath?(path: string): string;
        readFile(path: string, encoding?: string): string | undefined;
        fileExists(path: string): boolean;
        getTypeRootsVersion?(): number;
        /** @deprecated supply resolveModuleNameLiterals instead for resolution that can handle newer resolution modes like nodenext */
        resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];
        getResolvedModuleWithFailedLookupLocationsFromCache?(modulename: string, containingFile: string, resolutionMode?: ResolutionMode): ResolvedModuleWithFailedLookupLocations | undefined;
        /** @deprecated supply resolveTypeReferenceDirectiveReferences instead for resolution that can handle newer resolution modes like nodenext */
        resolveTypeReferenceDirectives?(typeDirectiveNames: string[] | FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: ResolutionMode): (ResolvedTypeReferenceDirective | undefined)[];
        resolveModuleNameLiterals?(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[];
        resolveTypeReferenceDirectiveReferences?<T extends FileReference | string>(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[];
        getDirectories?(directoryName: string): string[];
        /**
         * Gets a set of custom transformers to use during emit.
         */
        getCustomTransformers?(): CustomTransformers | undefined;
        isKnownTypesPackageName?(name: string): boolean;
        installPackage?(options: InstallPackageOptions): Promise<ApplyCodeActionCommandResult>;
        writeFile?(fileName: string, content: string): void;
        getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
    }
    type WithMetadata<T> = T & {
        metadata?: unknown;
    };
    enum SemanticClassificationFormat {
        Original = "original",
        TwentyTwenty = "2020"
    }
    interface LanguageService {
        /** This is used as a part of restarting the language service. */
        cleanupSemanticCache(): void;
        /**
         * Gets errors indicating invalid syntax in a file.
         *
         * In English, "this cdeo have, erorrs" is syntactically invalid because it has typos,
         * grammatical errors, and misplaced punctuation. Likewise, examples of syntax
         * errors in TypeScript are missing parentheses in an `if` statement, mismatched
         * curly braces, and using a reserved keyword as a variable name.
         *
         * These diagnostics are inexpensive to compute and don't require knowledge of
         * other files. Note that a non-empty result increases the likelihood of false positives
         * from `getSemanticDiagnostics`.
         *
         * While these represent the majority of syntax-related diagnostics, there are some
         * that require the type system, which will be present in `getSemanticDiagnostics`.
         *
         * @param fileName A path to the file you want syntactic diagnostics for
         */
        getSyntacticDiagnostics(fileName: string): DiagnosticWithLocation[];
        /**
         * Gets warnings or errors indicating type system issues in a given file.
         * Requesting semantic diagnostics may start up the type system and
         * run deferred work, so the first call may take longer than subsequent calls.
         *
         * Unlike the other get*Diagnostics functions, these diagnostics can potentially not
         * include a reference to a source file. Specifically, the first time this is called,
         * it will return global diagnostics with no associated location.
         *
         * To contrast the differences between semantic and syntactic diagnostics, consider the
         * sentence: "The sun is green." is syntactically correct; those are real English words with
         * correct sentence structure. However, it is semantically invalid, because it is not true.
         *
         * @param fileName A path to the file you want semantic diagnostics for
         */
        getSemanticDiagnostics(fileName: string): Diagnostic[];
        /**
         * Gets suggestion diagnostics for a specific file. These diagnostics tend to
         * proactively suggest refactors, as opposed to diagnostics that indicate
         * potentially incorrect runtime behavior.
         *
         * @param fileName A path to the file you want semantic diagnostics for
         */
        getSuggestionDiagnostics(fileName: string): DiagnosticWithLocation[];
        /**
         * Gets global diagnostics related to the program configuration and compiler options.
         */
        getCompilerOptionsDiagnostics(): Diagnostic[];
        /** @deprecated Use getEncodedSyntacticClassifications instead. */
        getSyntacticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[];
        getSyntacticClassifications(fileName: string, span: TextSpan, format: SemanticClassificationFormat): ClassifiedSpan[] | ClassifiedSpan2020[];
        /** @deprecated Use getEncodedSemanticClassifications instead. */
        getSemanticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[];
        getSemanticClassifications(fileName: string, span: TextSpan, format: SemanticClassificationFormat): ClassifiedSpan[] | ClassifiedSpan2020[];
        /** Encoded as triples of [start, length, ClassificationType]. */
        getEncodedSyntacticClassifications(fileName: string, span: TextSpan): Classifications;
        /**
         * Gets semantic highlights information for a particular file. Has two formats, an older
         * version used by VS and a format used by VS Code.
         *
         * @param fileName The path to the file
         * @param position A text span to return results within
         * @param format Which format to use, defaults to "original"
         * @returns a number array encoded as triples of [start, length, ClassificationType, ...].
         */
        getEncodedSemanticClassifications(fileName: string, span: TextSpan, format?: SemanticClassificationFormat): Classifications;
        /**
         * Gets completion entries at a particular position in a file.
         *
         * @param fileName The path to the file
         * @param position A zero-based index of the character where you want the entries
         * @param options An object describing how the request was triggered and what kinds
         * of code actions can be returned with the completions.
         * @param formattingSettings settings needed for calling formatting functions.
         */
        getCompletionsAtPosition(fileName: string, position: number, options: GetCompletionsAtPositionOptions | undefined, formattingSettings?: FormatCodeSettings): WithMetadata<CompletionInfo> | undefined;
        /**
         * Gets the extended details for a completion entry retrieved from `getCompletionsAtPosition`.
         *
         * @param fileName The path to the file
         * @param position A zero based index of the character where you want the entries
         * @param entryName The `name` from an existing completion which came from `getCompletionsAtPosition`
         * @param formatOptions How should code samples in the completions be formatted, can be undefined for backwards compatibility
         * @param source `source` property from the completion entry
         * @param preferences User settings, can be undefined for backwards compatibility
         * @param data `data` property from the completion entry
         */
        getCompletionEntryDetails(fileName: string, position: number, entryName: string, formatOptions: FormatCodeOptions | FormatCodeSettings | undefined, source: string | undefined, preferences: UserPreferences | undefined, data: CompletionEntryData | undefined): CompletionEntryDetails | undefined;
        getCompletionEntrySymbol(fileName: string, position: number, name: string, source: string | undefined): Symbol | undefined;
        /**
         * Gets semantic information about the identifier at a particular position in a
         * file. Quick info is what you typically see when you hover in an editor.
         *
         * @param fileName The path to the file
         * @param position A zero-based index of the character where you want the quick info
         */
        getQuickInfoAtPosition(fileName: string, position: number): QuickInfo | undefined;
        getNameOrDottedNameSpan(fileName: string, startPos: number, endPos: number): TextSpan | undefined;
        getBreakpointStatementAtPosition(fileName: string, position: number): TextSpan | undefined;
        getSignatureHelpItems(fileName: string, position: number, options: SignatureHelpItemsOptions | undefined): SignatureHelpItems | undefined;
        getRenameInfo(fileName: string, position: number, preferences: UserPreferences): RenameInfo;
        /** @deprecated Use the signature with `UserPreferences` instead. */
        getRenameInfo(fileName: string, position: number, options?: RenameInfoOptions): RenameInfo;
        findRenameLocations(fileName: string, position: number, findInStrings: boolean, findInComments: boolean, providePrefixAndSuffixTextForRename?: boolean): readonly RenameLocation[] | undefined;
        getSmartSelectionRange(fileName: string, position: number): SelectionRange;
        getDefinitionAtPosition(fileName: string, position: number): readonly DefinitionInfo[] | undefined;
        getDefinitionAndBoundSpan(fileName: string, position: number): DefinitionInfoAndBoundSpan | undefined;
        getTypeDefinitionAtPosition(fileName: string, position: number): readonly DefinitionInfo[] | undefined;
        getImplementationAtPosition(fileName: string, position: number): readonly ImplementationLocation[] | undefined;
        getReferencesAtPosition(fileName: string, position: number): ReferenceEntry[] | undefined;
        findReferences(fileName: string, position: number): ReferencedSymbol[] | undefined;
        getDocumentHighlights(fileName: string, position: number, filesToSearch: string[]): DocumentHighlights[] | undefined;
        getFileReferences(fileName: string): ReferenceEntry[];
        /** @deprecated */
        getOccurrencesAtPosition(fileName: string, position: number): readonly ReferenceEntry[] | undefined;
        getNavigateToItems(searchValue: string, maxResultCount?: number, fileName?: string, excludeDtsFiles?: boolean): NavigateToItem[];
        getNavigationBarItems(fileName: string): NavigationBarItem[];
        getNavigationTree(fileName: string): NavigationTree;
        prepareCallHierarchy(fileName: string, position: number): CallHierarchyItem | CallHierarchyItem[] | undefined;
        provideCallHierarchyIncomingCalls(fileName: string, position: number): CallHierarchyIncomingCall[];
        provideCallHierarchyOutgoingCalls(fileName: string, position: number): CallHierarchyOutgoingCall[];
        provideInlayHints(fileName: string, span: TextSpan, preferences: UserPreferences | undefined): InlayHint[];
        getOutliningSpans(fileName: string): OutliningSpan[];
        getTodoComments(fileName: string, descriptors: TodoCommentDescriptor[]): TodoComment[];
        getBraceMatchingAtPosition(fileName: string, position: number): TextSpan[];
        getIndentationAtPosition(fileName: string, position: number, options: EditorOptions | EditorSettings): number;
        getFormattingEditsForRange(fileName: string, start: number, end: number, options: FormatCodeOptions | FormatCodeSettings): TextChange[];
        getFormattingEditsForDocument(fileName: string, options: FormatCodeOptions | FormatCodeSettings): TextChange[];
        getFormattingEditsAfterKeystroke(fileName: string, position: number, key: string, options: FormatCodeOptions | FormatCodeSettings): TextChange[];
        getDocCommentTemplateAtPosition(fileName: string, position: number, options?: DocCommentTemplateOptions, formatOptions?: FormatCodeSettings): TextInsertion | undefined;
        isValidBraceCompletionAtPosition(fileName: string, position: number, openingBrace: number): boolean;
        /**
         * This will return a defined result if the position is after the `>` of the opening tag, or somewhere in the text, of a JSXElement with no closing tag.
         * Editors should call this after `>` is typed.
         */
        getJsxClosingTagAtPosition(fileName: string, position: number): JsxClosingTagInfo | undefined;
        getSpanOfEnclosingComment(fileName: string, position: number, onlyMultiLine: boolean): TextSpan | undefined;
        toLineColumnOffset?(fileName: string, position: number): LineAndCharacter;
        getCodeFixesAtPosition(fileName: string, start: number, end: number, errorCodes: readonly number[], formatOptions: FormatCodeSettings, preferences: UserPreferences): readonly CodeFixAction[];
        getCombinedCodeFix(scope: CombinedCodeFixScope, fixId: {}, formatOptions: FormatCodeSettings, preferences: UserPreferences): CombinedCodeActions;
        applyCodeActionCommand(action: CodeActionCommand, formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult>;
        applyCodeActionCommand(action: CodeActionCommand[], formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult[]>;
        applyCodeActionCommand(action: CodeActionCommand | CodeActionCommand[], formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult | ApplyCodeActionCommandResult[]>;
        /** @deprecated `fileName` will be ignored */
        applyCodeActionCommand(fileName: string, action: CodeActionCommand): Promise<ApplyCodeActionCommandResult>;
        /** @deprecated `fileName` will be ignored */
        applyCodeActionCommand(fileName: string, action: CodeActionCommand[]): Promise<ApplyCodeActionCommandResult[]>;
        /** @deprecated `fileName` will be ignored */
        applyCodeActionCommand(fileName: string, action: CodeActionCommand | CodeActionCommand[]): Promise<ApplyCodeActionCommandResult | ApplyCodeActionCommandResult[]>;
        getApplicableRefactors(fileName: string, positionOrRange: number | TextRange, preferences: UserPreferences | undefined, triggerReason?: RefactorTriggerReason, kind?: string): ApplicableRefactorInfo[];
        getEditsForRefactor(fileName: string, formatOptions: FormatCodeSettings, positionOrRange: number | TextRange, refactorName: string, actionName: string, preferences: UserPreferences | undefined): RefactorEditInfo | undefined;
        organizeImports(args: OrganizeImportsArgs, formatOptions: FormatCodeSettings, preferences: UserPreferences | undefined): readonly FileTextChanges[];
        getEditsForFileRename(oldFilePath: string, newFilePath: string, formatOptions: FormatCodeSettings, preferences: UserPreferences | undefined): readonly FileTextChanges[];
        getEmitOutput(fileName: string, emitOnlyDtsFiles?: boolean, forceDtsEmit?: boolean): EmitOutput;
        getProgram(): Program | undefined;
        toggleLineComment(fileName: string, textRange: TextRange): TextChange[];
        toggleMultilineComment(fileName: string, textRange: TextRange): TextChange[];
        commentSelection(fileName: string, textRange: TextRange): TextChange[];
        uncommentSelection(fileName: string, textRange: TextRange): TextChange[];
        getSupportedCodeFixes(fileName?: string): readonly string[];
        dispose(): void;
    }
    interface JsxClosingTagInfo {
        readonly newText: string;
    }
    interface CombinedCodeFixScope {
        type: "file";
        fileName: string;
    }
    enum OrganizeImportsMode {
        All = "All",
        SortAndCombine = "SortAndCombine",
        RemoveUnused = "RemoveUnused"
    }
    interface OrganizeImportsArgs extends CombinedCodeFixScope {
        /** @deprecated Use `mode` instead */
        skipDestructiveCodeActions?: boolean;
        mode?: OrganizeImportsMode;
    }
    type CompletionsTriggerCharacter = "." | '"' | "'" | "`" | "/" | "@" | "<" | "#" | " ";
    enum CompletionTriggerKind {
        /** Completion was triggered by typing an identifier, manual invocation (e.g Ctrl+Space) or via API. */
        Invoked = 1,
        /** Completion was triggered by a trigger character. */
        TriggerCharacter = 2,
        /** Completion was re-triggered as the current completion list is incomplete. */
        TriggerForIncompleteCompletions = 3
    }
    interface GetCompletionsAtPositionOptions extends UserPreferences {
        /**
         * If the editor is asking for completions because a certain character was typed
         * (as opposed to when the user explicitly requested them) this should be set.
         */
        triggerCharacter?: CompletionsTriggerCharacter;
        triggerKind?: CompletionTriggerKind;
        /**
         * Include a `symbol` property on each completion entry object.
         * Symbols reference cyclic data structures and sometimes an entire TypeChecker instance,
         * so use caution when serializing or retaining completion entries retrieved with this option.
         * @default false
         */
        includeSymbol?: boolean;
        /** @deprecated Use includeCompletionsForModuleExports */
        includeExternalModuleExports?: boolean;
        /** @deprecated Use includeCompletionsWithInsertText */
        includeInsertTextCompletions?: boolean;
    }
    type SignatureHelpTriggerCharacter = "," | "(" | "<";
    type SignatureHelpRetriggerCharacter = SignatureHelpTriggerCharacter | ")";
    interface SignatureHelpItemsOptions {
        triggerReason?: SignatureHelpTriggerReason;
    }
    type SignatureHelpTriggerReason = SignatureHelpInvokedReason | SignatureHelpCharacterTypedReason | SignatureHelpRetriggeredReason;
    /**
     * Signals that the user manually requested signature help.
     * The language service will unconditionally attempt to provide a result.
     */
    interface SignatureHelpInvokedReason {
        kind: "invoked";
        triggerCharacter?: undefined;
    }
    /**
     * Signals that the signature help request came from a user typing a character.
     * Depending on the character and the syntactic context, the request may or may not be served a result.
     */
    interface SignatureHelpCharacterTypedReason {
        kind: "characterTyped";
        /**
         * Character that was responsible for triggering signature help.
         */
        triggerCharacter: SignatureHelpTriggerCharacter;
    }
    /**
     * Signals that this signature help request came from typing a character or moving the cursor.
     * This should only occur if a signature help session was already active and the editor needs to see if it should adjust.
     * The language service will unconditionally attempt to provide a result.
     * `triggerCharacter` can be `undefined` for a retrigger caused by a cursor move.
     */
    interface SignatureHelpRetriggeredReason {
        kind: "retrigger";
        /**
         * Character that was responsible for triggering signature help.
         */
        triggerCharacter?: SignatureHelpRetriggerCharacter;
    }
    interface ApplyCodeActionCommandResult {
        successMessage: string;
    }
    interface Classifications {
        spans: number[];
        endOfLineState: EndOfLineState;
    }
    interface ClassifiedSpan {
        textSpan: TextSpan;
        classificationType: ClassificationTypeNames;
    }
    interface ClassifiedSpan2020 {
        textSpan: TextSpan;
        classificationType: number;
    }
    /**
     * Navigation bar interface designed for visual studio's dual-column layout.
     * This does not form a proper tree.
     * The navbar is returned as a list of top-level items, each of which has a list of child items.
     * Child items always have an empty array for their `childItems`.
     */
    interface NavigationBarItem {
        text: string;
        kind: ScriptElementKind;
        kindModifiers: string;
        spans: TextSpan[];
        childItems: NavigationBarItem[];
        indent: number;
        bolded: boolean;
        grayed: boolean;
    }
    /**
     * Node in a tree of nested declarations in a file.
     * The top node is always a script or module node.
     */
    interface NavigationTree {
        /** Name of the declaration, or a short description, e.g. "<class>". */
        text: string;
        kind: ScriptElementKind;
        /** ScriptElementKindModifier separated by commas, e.g. "public,abstract" */
        kindModifiers: string;
        /**
         * Spans of the nodes that generated this declaration.
         * There will be more than one if this is the result of merging.
         */
        spans: TextSpan[];
        nameSpan: TextSpan | undefined;
        /** Present if non-empty */
        childItems?: NavigationTree[];
    }
    interface CallHierarchyItem {
        name: string;
        kind: ScriptElementKind;
        kindModifiers?: string;
        file: string;
        span: TextSpan;
        selectionSpan: TextSpan;
        containerName?: string;
    }
    interface CallHierarchyIncomingCall {
        from: CallHierarchyItem;
        fromSpans: TextSpan[];
    }
    interface CallHierarchyOutgoingCall {
        to: CallHierarchyItem;
        fromSpans: TextSpan[];
    }
    enum InlayHintKind {
        Type = "Type",
        Parameter = "Parameter",
        Enum = "Enum"
    }
    interface InlayHint {
        text: string;
        position: number;
        kind: InlayHintKind;
        whitespaceBefore?: boolean;
        whitespaceAfter?: boolean;
    }
    interface TodoCommentDescriptor {
        text: string;
        priority: number;
    }
    interface TodoComment {
        descriptor: TodoCommentDescriptor;
        message: string;
        position: number;
    }
    interface TextChange {
        span: TextSpan;
        newText: string;
    }
    interface FileTextChanges {
        fileName: string;
        textChanges: readonly TextChange[];
        isNewFile?: boolean;
    }
    interface CodeAction {
        /** Description of the code action to display in the UI of the editor */
        description: string;
        /** Text changes to apply to each file as part of the code action */
        changes: FileTextChanges[];
        /**
         * If the user accepts the code fix, the editor should send the action back in a `applyAction` request.
         * This allows the language service to have side effects (e.g. installing dependencies) upon a code fix.
         */
        commands?: CodeActionCommand[];
    }
    interface CodeFixAction extends CodeAction {
        /** Short name to identify the fix, for use by telemetry. */
        fixName: string;
        /**
         * If present, one may call 'getCombinedCodeFix' with this fixId.
         * This may be omitted to indicate that the code fix can't be applied in a group.
         */
        fixId?: {};
        fixAllDescription?: string;
    }
    interface CombinedCodeActions {
        changes: readonly FileTextChanges[];
        commands?: readonly CodeActionCommand[];
    }
    type CodeActionCommand = InstallPackageAction;
    interface InstallPackageAction {
    }
    /**
     * A set of one or more available refactoring actions, grouped under a parent refactoring.
     */
    interface ApplicableRefactorInfo {
        /**
         * The programmatic name of the refactoring
         */
        name: string;
        /**
         * A description of this refactoring category to show to the user.
         * If the refactoring gets inlined (see below), this text will not be visible.
         */
        description: string;
        /**
         * Inlineable refactorings can have their actions hoisted out to the top level
         * of a context menu. Non-inlineanable refactorings should always be shown inside
         * their parent grouping.
         *
         * If not specified, this value is assumed to be 'true'
         */
        inlineable?: boolean;
        actions: RefactorActionInfo[];
    }
    /**
     * Represents a single refactoring action - for example, the "Extract Method..." refactor might
     * offer several actions, each corresponding to a surround class or closure to extract into.
     */
    interface RefactorActionInfo {
        /**
         * The programmatic name of the refactoring action
         */
        name: string;
        /**
         * A description of this refactoring action to show to the user.
         * If the parent refactoring is inlined away, this will be the only text shown,
         * so this description should make sense by itself if the parent is inlineable=true
         */
        description: string;
        /**
         * A message to show to the user if the refactoring cannot be applied in
         * the current context.
         */
        notApplicableReason?: string;
        /**
         * The hierarchical dotted name of the refactor action.
         */
        kind?: string;
    }
    /**
     * A set of edits to make in response to a refactor action, plus an optional
     * location where renaming should be invoked from
     */
    interface RefactorEditInfo {
        edits: FileTextChanges[];
        renameFilename?: string;
        renameLocation?: number;
        commands?: CodeActionCommand[];
    }
    type RefactorTriggerReason = "implicit" | "invoked";
    interface TextInsertion {
        newText: string;
        /** The position in newText the caret should point to after the insertion. */
        caretOffset: number;
    }
    interface DocumentSpan {
        textSpan: TextSpan;
        fileName: string;
        /**
         * If the span represents a location that was remapped (e.g. via a .d.ts.map file),
         * then the original filename and span will be specified here
         */
        originalTextSpan?: TextSpan;
        originalFileName?: string;
        /**
         * If DocumentSpan.textSpan is the span for name of the declaration,
         * then this is the span for relevant declaration
         */
        contextSpan?: TextSpan;
        originalContextSpan?: TextSpan;
    }
    interface RenameLocation extends DocumentSpan {
        readonly prefixText?: string;
        readonly suffixText?: string;
    }
    interface ReferenceEntry extends DocumentSpan {
        isWriteAccess: boolean;
        isInString?: true;
    }
    interface ImplementationLocation extends DocumentSpan {
        kind: ScriptElementKind;
        displayParts: SymbolDisplayPart[];
    }
    enum HighlightSpanKind {
        none = "none",
        definition = "definition",
        reference = "reference",
        writtenReference = "writtenReference"
    }
    interface HighlightSpan {
        fileName?: string;
        isInString?: true;
        textSpan: TextSpan;
        contextSpan?: TextSpan;
        kind: HighlightSpanKind;
    }
    interface NavigateToItem {
        name: string;
        kind: ScriptElementKind;
        kindModifiers: string;
        matchKind: "exact" | "prefix" | "substring" | "camelCase";
        isCaseSensitive: boolean;
        fileName: string;
        textSpan: TextSpan;
        containerName: string;
        containerKind: ScriptElementKind;
    }
    enum IndentStyle {
        None = 0,
        Block = 1,
        Smart = 2
    }
    enum SemicolonPreference {
        Ignore = "ignore",
        Insert = "insert",
        Remove = "remove"
    }
    /** @deprecated - consider using EditorSettings instead */
    interface EditorOptions {
        BaseIndentSize?: number;
        IndentSize: number;
        TabSize: number;
        NewLineCharacter: string;
        ConvertTabsToSpaces: boolean;
        IndentStyle: IndentStyle;
    }
    interface EditorSettings {
        baseIndentSize?: number;
        indentSize?: number;
        tabSize?: number;
        newLineCharacter?: string;
        convertTabsToSpaces?: boolean;
        indentStyle?: IndentStyle;
        trimTrailingWhitespace?: boolean;
    }
    /** @deprecated - consider using FormatCodeSettings instead */
    interface FormatCodeOptions extends EditorOptions {
        InsertSpaceAfterCommaDelimiter: boolean;
        InsertSpaceAfterSemicolonInForStatements: boolean;
        InsertSpaceBeforeAndAfterBinaryOperators: boolean;
        InsertSpaceAfterConstructor?: boolean;
        InsertSpaceAfterKeywordsInControlFlowStatements: boolean;
        InsertSpaceAfterFunctionKeywordForAnonymousFunctions: boolean;
        InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: boolean;
        InsertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: boolean;
        InsertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;
        InsertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: boolean;
        InsertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;
        InsertSpaceAfterTypeAssertion?: boolean;
        InsertSpaceBeforeFunctionParenthesis?: boolean;
        PlaceOpenBraceOnNewLineForFunctions: boolean;
        PlaceOpenBraceOnNewLineForControlBlocks: boolean;
        insertSpaceBeforeTypeAnnotation?: boolean;
    }
    interface FormatCodeSettings extends EditorSettings {
        readonly insertSpaceAfterCommaDelimiter?: boolean;
        readonly insertSpaceAfterSemicolonInForStatements?: boolean;
        readonly insertSpaceBeforeAndAfterBinaryOperators?: boolean;
        readonly insertSpaceAfterConstructor?: boolean;
        readonly insertSpaceAfterKeywordsInControlFlowStatements?: boolean;
        readonly insertSpaceAfterFunctionKeywordForAnonymousFunctions?: boolean;
        readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis?: boolean;
        readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets?: boolean;
        readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;
        readonly insertSpaceAfterOpeningAndBeforeClosingEmptyBraces?: boolean;
        readonly insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces?: boolean;
        readonly insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;
        readonly insertSpaceAfterTypeAssertion?: boolean;
        readonly insertSpaceBeforeFunctionParenthesis?: boolean;
        readonly placeOpenBraceOnNewLineForFunctions?: boolean;
        readonly placeOpenBraceOnNewLineForControlBlocks?: boolean;
        readonly insertSpaceBeforeTypeAnnotation?: boolean;
        readonly indentMultiLineObjectLiteralBeginningOnBlankLine?: boolean;
        readonly semicolons?: SemicolonPreference;
    }
    interface DefinitionInfo extends DocumentSpan {
        kind: ScriptElementKind;
        name: string;
        containerKind: ScriptElementKind;
        containerName: string;
        unverified?: boolean;
    }
    interface DefinitionInfoAndBoundSpan {
        definitions?: readonly DefinitionInfo[];
        textSpan: TextSpan;
    }
    interface ReferencedSymbolDefinitionInfo extends DefinitionInfo {
        displayParts: SymbolDisplayPart[];
    }
    interface ReferencedSymbol {
        definition: ReferencedSymbolDefinitionInfo;
        references: ReferencedSymbolEntry[];
    }
    interface ReferencedSymbolEntry extends ReferenceEntry {
        isDefinition?: boolean;
    }
    enum SymbolDisplayPartKind {
        aliasName = 0,
        className = 1,
        enumName = 2,
        fieldName = 3,
        interfaceName = 4,
        keyword = 5,
        lineBreak = 6,
        numericLiteral = 7,
        stringLiteral = 8,
        localName = 9,
        methodName = 10,
        moduleName = 11,
        operator = 12,
        parameterName = 13,
        propertyName = 14,
        punctuation = 15,
        space = 16,
        text = 17,
        typeParameterName = 18,
        enumMemberName = 19,
        functionName = 20,
        regularExpressionLiteral = 21,
        link = 22,
        linkName = 23,
        linkText = 24
    }
    interface SymbolDisplayPart {
        text: string;
        kind: string;
    }
    interface JSDocLinkDisplayPart extends SymbolDisplayPart {
        target: DocumentSpan;
    }
    interface JSDocTagInfo {
        name: string;
        text?: SymbolDisplayPart[];
    }
    interface QuickInfo {
        kind: ScriptElementKind;
        kindModifiers: string;
        textSpan: TextSpan;
        displayParts?: SymbolDisplayPart[];
        documentation?: SymbolDisplayPart[];
        tags?: JSDocTagInfo[];
    }
    type RenameInfo = RenameInfoSuccess | RenameInfoFailure;
    interface RenameInfoSuccess {
        canRename: true;
        /**
         * File or directory to rename.
         * If set, `getEditsForFileRename` should be called instead of `findRenameLocations`.
         */
        fileToRename?: string;
        displayName: string;
        fullDisplayName: string;
        kind: ScriptElementKind;
        kindModifiers: string;
        triggerSpan: TextSpan;
    }
    interface RenameInfoFailure {
        canRename: false;
        localizedErrorMessage: string;
    }
    /**
     * @deprecated Use `UserPreferences` instead.
     */
    interface RenameInfoOptions {
        readonly allowRenameOfImportPath?: boolean;
    }
    interface DocCommentTemplateOptions {
        readonly generateReturnInDocTemplate?: boolean;
    }
    interface SignatureHelpParameter {
        name: string;
        documentation: SymbolDisplayPart[];
        displayParts: SymbolDisplayPart[];
        isOptional: boolean;
        isRest?: boolean;
    }
    interface SelectionRange {
        textSpan: TextSpan;
        parent?: SelectionRange;
    }
    /**
     * Represents a single signature to show in signature help.
     * The id is used for subsequent calls into the language service to ask questions about the
     * signature help item in the context of any documents that have been updated.  i.e. after
     * an edit has happened, while signature help is still active, the host can ask important
     * questions like 'what parameter is the user currently contained within?'.
     */
    interface SignatureHelpItem {
        isVariadic: boolean;
        prefixDisplayParts: SymbolDisplayPart[];
        suffixDisplayParts: SymbolDisplayPart[];
        separatorDisplayParts: SymbolDisplayPart[];
        parameters: SignatureHelpParameter[];
        documentation: SymbolDisplayPart[];
        tags: JSDocTagInfo[];
    }
    /**
     * Represents a set of signature help items, and the preferred item that should be selected.
     */
    interface SignatureHelpItems {
        items: SignatureHelpItem[];
        applicableSpan: TextSpan;
        selectedItemIndex: number;
        argumentIndex: number;
        argumentCount: number;
    }
    enum CompletionInfoFlags {
        None = 0,
        MayIncludeAutoImports = 1,
        IsImportStatementCompletion = 2,
        IsContinuation = 4,
        ResolvedModuleSpecifiers = 8,
        ResolvedModuleSpecifiersBeyondLimit = 16,
        MayIncludeMethodSnippets = 32
    }
    interface CompletionInfo {
        /** For performance telemetry. */
        flags?: CompletionInfoFlags;
        /** Not true for all global completions. This will be true if the enclosing scope matches a few syntax kinds. See `isSnippetScope`. */
        isGlobalCompletion: boolean;
        isMemberCompletion: boolean;
        /**
         * In the absence of `CompletionEntry["replacementSpan"]`, the editor may choose whether to use
         * this span or its default one. If `CompletionEntry["replacementSpan"]` is defined, that span
         * must be used to commit that completion entry.
         */
        optionalReplacementSpan?: TextSpan;
        /**
         * true when the current location also allows for a new identifier
         */
        isNewIdentifierLocation: boolean;
        /**
         * Indicates to client to continue requesting completions on subsequent keystrokes.
         */
        isIncomplete?: true;
        entries: CompletionEntry[];
    }
    interface CompletionEntryDataAutoImport {
        /**
         * The name of the property or export in the module's symbol table. Differs from the completion name
         * in the case of InternalSymbolName.ExportEquals and InternalSymbolName.Default.
         */
        exportName: string;
        exportMapKey?: string;
        moduleSpecifier?: string;
        /** The file name declaring the export's module symbol, if it was an external module */
        fileName?: string;
        /** The module name (with quotes stripped) of the export's module symbol, if it was an ambient module */
        ambientModuleName?: string;
        /** True if the export was found in the package.json AutoImportProvider */
        isPackageJsonImport?: true;
    }
    interface CompletionEntryDataUnresolved extends CompletionEntryDataAutoImport {
        exportMapKey: string;
    }
    interface CompletionEntryDataResolved extends CompletionEntryDataAutoImport {
        moduleSpecifier: string;
    }
    type CompletionEntryData = CompletionEntryDataUnresolved | CompletionEntryDataResolved;
    interface CompletionEntry {
        name: string;
        kind: ScriptElementKind;
        kindModifiers?: string;
        sortText: string;
        insertText?: string;
        isSnippet?: true;
        /**
         * An optional span that indicates the text to be replaced by this completion item.
         * If present, this span should be used instead of the default one.
         * It will be set if the required span differs from the one generated by the default replacement behavior.
         */
        replacementSpan?: TextSpan;
        hasAction?: true;
        source?: string;
        sourceDisplay?: SymbolDisplayPart[];
        labelDetails?: CompletionEntryLabelDetails;
        isRecommended?: true;
        isFromUncheckedFile?: true;
        isPackageJsonImport?: true;
        isImportStatementCompletion?: true;
        /**
         * For API purposes.
         * Included for non-string completions only when `includeSymbol: true` option is passed to `getCompletionsAtPosition`.
         * @example Get declaration of completion: `symbol.valueDeclaration`
         */
        symbol?: Symbol;
        /**
         * A property to be sent back to TS Server in the CompletionDetailsRequest, along with `name`,
         * that allows TS Server to look up the symbol represented by the completion item, disambiguating
         * items with the same name. Currently only defined for auto-import completions, but the type is
         * `unknown` in the protocol, so it can be changed as needed to support other kinds of completions.
         * The presence of this property should generally not be used to assume that this completion entry
         * is an auto-import.
         */
        data?: CompletionEntryData;
    }
    interface CompletionEntryLabelDetails {
        detail?: string;
        description?: string;
    }
    interface CompletionEntryDetails {
        name: string;
        kind: ScriptElementKind;
        kindModifiers: string;
        displayParts: SymbolDisplayPart[];
        documentation?: SymbolDisplayPart[];
        tags?: JSDocTagInfo[];
        codeActions?: CodeAction[];
        /** @deprecated Use `sourceDisplay` instead. */
        source?: SymbolDisplayPart[];
        sourceDisplay?: SymbolDisplayPart[];
    }
    interface OutliningSpan {
        /** The span of the document to actually collapse. */
        textSpan: TextSpan;
        /** The span of the document to display when the user hovers over the collapsed span. */
        hintSpan: TextSpan;
        /** The text to display in the editor for the collapsed region. */
        bannerText: string;
        /**
         * Whether or not this region should be automatically collapsed when
         * the 'Collapse to Definitions' command is invoked.
         */
        autoCollapse: boolean;
        /**
         * Classification of the contents of the span
         */
        kind: OutliningSpanKind;
    }
    enum OutliningSpanKind {
        /** Single or multi-line comments */
        Comment = "comment",
        /** Sections marked by '// #region' and '// #endregion' comments */
        Region = "region",
        /** Declarations and expressions */
        Code = "code",
        /** Contiguous blocks of import declarations */
        Imports = "imports"
    }
    enum OutputFileType {
        JavaScript = 0,
        SourceMap = 1,
        Declaration = 2
    }
    enum EndOfLineState {
        None = 0,
        InMultiLineCommentTrivia = 1,
        InSingleQuoteStringLiteral = 2,
        InDoubleQuoteStringLiteral = 3,
        InTemplateHeadOrNoSubstitutionTemplate = 4,
        InTemplateMiddleOrTail = 5,
        InTemplateSubstitutionPosition = 6
    }
    enum TokenClass {
        Punctuation = 0,
        Keyword = 1,
        Operator = 2,
        Comment = 3,
        Whitespace = 4,
        Identifier = 5,
        NumberLiteral = 6,
        BigIntLiteral = 7,
        StringLiteral = 8,
        RegExpLiteral = 9
    }
    interface ClassificationResult {
        finalLexState: EndOfLineState;
        entries: ClassificationInfo[];
    }
    interface ClassificationInfo {
        length: number;
        classification: TokenClass;
    }
    interface Classifier {
        /**
         * Gives lexical classifications of tokens on a line without any syntactic context.
         * For instance, a token consisting of the text 'string' can be either an identifier
         * named 'string' or the keyword 'string', however, because this classifier is not aware,
         * it relies on certain heuristics to give acceptable results. For classifications where
         * speed trumps accuracy, this function is preferable; however, for true accuracy, the
         * syntactic classifier is ideal. In fact, in certain editing scenarios, combining the
         * lexical, syntactic, and semantic classifiers may issue the best user experience.
         *
         * @param text                      The text of a line to classify.
         * @param lexState                  The state of the lexical classifier at the end of the previous line.
         * @param syntacticClassifierAbsent Whether the client is *not* using a syntactic classifier.
         *                                  If there is no syntactic classifier (syntacticClassifierAbsent=true),
         *                                  certain heuristics may be used in its place; however, if there is a
         *                                  syntactic classifier (syntacticClassifierAbsent=false), certain
         *                                  classifications which may be incorrectly categorized will be given
         *                                  back as Identifiers in order to allow the syntactic classifier to
         *                                  subsume the classification.
         * @deprecated Use getLexicalClassifications instead.
         */
        getClassificationsForLine(text: string, lexState: EndOfLineState, syntacticClassifierAbsent: boolean): ClassificationResult;
        getEncodedLexicalClassifications(text: string, endOfLineState: EndOfLineState, syntacticClassifierAbsent: boolean): Classifications;
    }
    enum ScriptElementKind {
        unknown = "",
        warning = "warning",
        /** predefined type (void) or keyword (class) */
        keyword = "keyword",
        /** top level script node */
        scriptElement = "script",
        /** module foo {} */
        moduleElement = "module",
        /** class X {} */
        classElement = "class",
        /** var x = class X {} */
        localClassElement = "local class",
        /** interface Y {} */
        interfaceElement = "interface",
        /** type T = ... */
        typeElement = "type",
        /** enum E */
        enumElement = "enum",
        enumMemberElement = "enum member",
        /**
         * Inside module and script only
         * const v = ..
         */
        variableElement = "var",
        /** Inside function */
        localVariableElement = "local var",
        /**
         * Inside module and script only
         * function f() { }
         */
        functionElement = "function",
        /** Inside function */
        localFunctionElement = "local function",
        /** class X { [public|private]* foo() {} } */
        memberFunctionElement = "method",
        /** class X { [public|private]* [get|set] foo:number; } */
        memberGetAccessorElement = "getter",
        memberSetAccessorElement = "setter",
        /**
         * class X { [public|private]* foo:number; }
         * interface Y { foo:number; }
         */
        memberVariableElement = "property",
        /** class X { [public|private]* accessor foo: number; } */
        memberAccessorVariableElement = "accessor",
        /**
         * class X { constructor() { } }
         * class X { static { } }
         */
        constructorImplementationElement = "constructor",
        /** interface Y { ():number; } */
        callSignatureElement = "call",
        /** interface Y { []:number; } */
        indexSignatureElement = "index",
        /** interface Y { new():Y; } */
        constructSignatureElement = "construct",
        /** function foo(*Y*: string) */
        parameterElement = "parameter",
        typeParameterElement = "type parameter",
        primitiveType = "primitive type",
        label = "label",
        alias = "alias",
        constElement = "const",
        letElement = "let",
        directory = "directory",
        externalModuleName = "external module name",
        /**
         * <JsxTagName attribute1 attribute2={0} />
         * @deprecated
         */
        jsxAttribute = "JSX attribute",
        /** String literal */
        string = "string",
        /** Jsdoc @link: in `{@link C link text}`, the before and after text "{@link " and "}" */
        link = "link",
        /** Jsdoc @link: in `{@link C link text}`, the entity name "C" */
        linkName = "link name",
        /** Jsdoc @link: in `{@link C link text}`, the link text "link text" */
        linkText = "link text"
    }
    enum ScriptElementKindModifier {
        none = "",
        publicMemberModifier = "public",
        privateMemberModifier = "private",
        protectedMemberModifier = "protected",
        exportedModifier = "export",
        ambientModifier = "declare",
        staticModifier = "static",
        abstractModifier = "abstract",
        optionalModifier = "optional",
        deprecatedModifier = "deprecated",
        dtsModifier = ".d.ts",
        tsModifier = ".ts",
        tsxModifier = ".tsx",
        jsModifier = ".js",
        jsxModifier = ".jsx",
        jsonModifier = ".json",
        dmtsModifier = ".d.mts",
        mtsModifier = ".mts",
        mjsModifier = ".mjs",
        dctsModifier = ".d.cts",
        ctsModifier = ".cts",
        cjsModifier = ".cjs"
    }
    enum ClassificationTypeNames {
        comment = "comment",
        identifier = "identifier",
        keyword = "keyword",
        numericLiteral = "number",
        bigintLiteral = "bigint",
        operator = "operator",
        stringLiteral = "string",
        whiteSpace = "whitespace",
        text = "text",
        punctuation = "punctuation",
        className = "class name",
        enumName = "enum name",
        interfaceName = "interface name",
        moduleName = "module name",
        typeParameterName = "type parameter name",
        typeAliasName = "type alias name",
        parameterName = "parameter name",
        docCommentTagName = "doc comment tag name",
        jsxOpenTagName = "jsx open tag name",
        jsxCloseTagName = "jsx close tag name",
        jsxSelfClosingTagName = "jsx self closing tag name",
        jsxAttribute = "jsx attribute",
        jsxText = "jsx text",
        jsxAttributeStringLiteralValue = "jsx attribute string literal value"
    }
    enum ClassificationType {
        comment = 1,
        identifier = 2,
        keyword = 3,
        numericLiteral = 4,
        operator = 5,
        stringLiteral = 6,
        regularExpressionLiteral = 7,
        whiteSpace = 8,
        text = 9,
        punctuation = 10,
        className = 11,
        enumName = 12,
        interfaceName = 13,
        moduleName = 14,
        typeParameterName = 15,
        typeAliasName = 16,
        parameterName = 17,
        docCommentTagName = 18,
        jsxOpenTagName = 19,
        jsxCloseTagName = 20,
        jsxSelfClosingTagName = 21,
        jsxAttribute = 22,
        jsxText = 23,
        jsxAttributeStringLiteralValue = 24,
        bigintLiteral = 25
    }
    interface InlayHintsContext {
        file: SourceFile;
        program: Program;
        cancellationToken: CancellationToken;
        host: LanguageServiceHost;
        span: TextSpan;
        preferences: UserPreferences;
    }
    /** The classifier is used for syntactic highlighting in editors via the TSServer */
    function createClassifier(): Classifier;
    interface DocumentHighlights {
        fileName: string;
        highlightSpans: HighlightSpan[];
    }
    function createDocumentRegistry(useCaseSensitiveFileNames?: boolean, currentDirectory?: string): DocumentRegistry;
    /**
     * The document registry represents a store of SourceFile objects that can be shared between
     * multiple LanguageService instances. A LanguageService instance holds on the SourceFile (AST)
     * of files in the context.
     * SourceFile objects account for most of the memory usage by the language service. Sharing
     * the same DocumentRegistry instance between different instances of LanguageService allow
     * for more efficient memory utilization since all projects will share at least the library
     * file (lib.d.ts).
     *
     * A more advanced use of the document registry is to serialize sourceFile objects to disk
     * and re-hydrate them when needed.
     *
     * To create a default DocumentRegistry, use createDocumentRegistry to create one, and pass it
     * to all subsequent createLanguageService calls.
     */
    interface DocumentRegistry {
        /**
         * Request a stored SourceFile with a given fileName and compilationSettings.
         * The first call to acquire will call createLanguageServiceSourceFile to generate
         * the SourceFile if was not found in the registry.
         *
         * @param fileName The name of the file requested
         * @param compilationSettingsOrHost Some compilation settings like target affects the
         * shape of a the resulting SourceFile. This allows the DocumentRegistry to store
         * multiple copies of the same file for different compilation settings. A minimal
         * resolution cache is needed to fully define a source file's shape when
         * the compilation settings include `module: node16`+, so providing a cache host
         * object should be preferred. A common host is a language service `ConfiguredProject`.
         * @param scriptSnapshot Text of the file. Only used if the file was not found
         * in the registry and a new one was created.
         * @param version Current version of the file. Only used if the file was not found
         * in the registry and a new one was created.
         */
        acquireDocument(fileName: string, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;
        acquireDocumentWithKey(fileName: string, path: Path, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, key: DocumentRegistryBucketKey, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;
        /**
         * Request an updated version of an already existing SourceFile with a given fileName
         * and compilationSettings. The update will in-turn call updateLanguageServiceSourceFile
         * to get an updated SourceFile.
         *
         * @param fileName The name of the file requested
         * @param compilationSettingsOrHost Some compilation settings like target affects the
         * shape of a the resulting SourceFile. This allows the DocumentRegistry to store
         * multiple copies of the same file for different compilation settings. A minimal
         * resolution cache is needed to fully define a source file's shape when
         * the compilation settings include `module: node16`+, so providing a cache host
         * object should be preferred. A common host is a language service `ConfiguredProject`.
         * @param scriptSnapshot Text of the file.
         * @param version Current version of the file.
         */
        updateDocument(fileName: string, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;
        updateDocumentWithKey(fileName: string, path: Path, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, key: DocumentRegistryBucketKey, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;
        getKeyForCompilationSettings(settings: CompilerOptions): DocumentRegistryBucketKey;
        /**
         * Informs the DocumentRegistry that a file is not needed any longer.
         *
         * Note: It is not allowed to call release on a SourceFile that was not acquired from
         * this registry originally.
         *
         * @param fileName The name of the file to be released
         * @param compilationSettings The compilation settings used to acquire the file
         * @param scriptKind The script kind of the file to be released
         *
         * @deprecated pass scriptKind and impliedNodeFormat for correctness
         */
        releaseDocument(fileName: string, compilationSettings: CompilerOptions, scriptKind?: ScriptKind): void;
        /**
         * Informs the DocumentRegistry that a file is not needed any longer.
         *
         * Note: It is not allowed to call release on a SourceFile that was not acquired from
         * this registry originally.
         *
         * @param fileName The name of the file to be released
         * @param compilationSettings The compilation settings used to acquire the file
         * @param scriptKind The script kind of the file to be released
         * @param impliedNodeFormat The implied source file format of the file to be released
         */
        releaseDocument(fileName: string, compilationSettings: CompilerOptions, scriptKind: ScriptKind, impliedNodeFormat: ResolutionMode): void;
        /**
         * @deprecated pass scriptKind for and impliedNodeFormat correctness */
        releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey, scriptKind?: ScriptKind): void;
        releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey, scriptKind: ScriptKind, impliedNodeFormat: ResolutionMode): void;
        reportStats(): string;
    }
    type DocumentRegistryBucketKey = string & {
        __bucketKey: any;
    };
    function preProcessFile(sourceText: string, readImportFiles?: boolean, detectJavaScriptImports?: boolean): PreProcessedFileInfo;
    function transpileModule(input: string, transpileOptions: TranspileOptions): TranspileOutput;
    function transpile(input: string, compilerOptions?: CompilerOptions, fileName?: string, diagnostics?: Diagnostic[], moduleName?: string): string;
    interface TranspileOptions {
        compilerOptions?: CompilerOptions;
        fileName?: string;
        reportDiagnostics?: boolean;
        moduleName?: string;
        renamedDependencies?: MapLike<string>;
        transformers?: CustomTransformers;
    }
    interface TranspileOutput {
        outputText: string;
        diagnostics?: Diagnostic[];
        sourceMapText?: string;
    }
    function toEditorSettings(options: EditorOptions | EditorSettings): EditorSettings;
    function displayPartsToString(displayParts: SymbolDisplayPart[] | undefined): string;
    function getDefaultCompilerOptions(): CompilerOptions;
    function getSupportedCodeFixes(): readonly string[];
    function createLanguageServiceSourceFile(fileName: string, scriptSnapshot: IScriptSnapshot, scriptTargetOrOptions: ScriptTarget | CreateSourceFileOptions, version: string, setNodeParents: boolean, scriptKind?: ScriptKind): SourceFile;
    function updateLanguageServiceSourceFile(sourceFile: SourceFile, scriptSnapshot: IScriptSnapshot, version: string, textChangeRange: TextChangeRange | undefined, aggressiveChecks?: boolean): SourceFile;
    function createLanguageService(host: LanguageServiceHost, documentRegistry?: DocumentRegistry, syntaxOnlyOrLanguageServiceMode?: boolean | LanguageServiceMode): LanguageService;
    /**
     * Get the path of the default library files (lib.d.ts) as distributed with the typescript
     * node package.
     * The functionality is not supported if the ts module is consumed outside of a node module.
     */
    function getDefaultLibFilePath(options: CompilerOptions): string;
    /** The version of the language service API */
    const servicesVersion = "0.8";
    /**
     * Transform one or more nodes using the supplied transformers.
     * @param source A single `Node` or an array of `Node` objects.
     * @param transformers An array of `TransformerFactory` callbacks used to process the transformation.
     * @param compilerOptions Optional compiler options.
     */
    function transform<T extends Node>(source: T | T[], transformers: TransformerFactory<T>[], compilerOptions?: CompilerOptions): TransformationResult<T>;
}
export = ts;
};

declare namespace TactCompiler {
                /// <amd-module name="tact-compiler/abi/AbiFunction.d.ts" /> 
 declare module "tact-compiler/abi/AbiFunction.d.ts" {
                import { AstExpression } from "../ast/ast";
import { CompilerContext } from "../context/context";
import { WriterContext } from "../generator/Writer";
import { TypeRef } from "../types/types";
import { SrcInfo } from "../grammar";
export type AbiFunction = {
    name: string;
    resolve: (ctx: CompilerContext, args: TypeRef[], loc: SrcInfo) => TypeRef;
    generate: (ctx: WriterContext, args: TypeRef[], resolved: AstExpression[], loc: SrcInfo) => string;
};

            };
/// <amd-module name="tact-compiler/abi/errors.d.ts" /> 
 declare module "tact-compiler/abi/errors.d.ts" {
                export declare const contractErrors: {
    null: {
        id: number;
        message: string;
    };
    invalidPrefix: {
        id: number;
        message: string;
    };
    invalidMessage: {
        id: number;
        message: string;
    };
    constraintsError: {
        id: number;
        message: string;
    };
    accessDenied: {
        id: number;
        message: string;
    };
    contractStopped: {
        id: number;
        message: string;
    };
    invalidArgument: {
        id: number;
        message: string;
    };
    codeNotFound: {
        id: number;
        message: string;
    };
};

            };
/// <amd-module name="tact-compiler/abi/global.d.ts" /> 
 declare module "tact-compiler/abi/global.d.ts" {
                import { AbiFunction } from "./AbiFunction";
export declare const GlobalFunctions: Map<string, AbiFunction>;

            };
/// <amd-module name="tact-compiler/abi/map.d.ts" /> 
 declare module "tact-compiler/abi/map.d.ts" {
                import { AbiFunction } from "./AbiFunction";
export declare const MapFunctions: Map<string, AbiFunction>;

            };
/// <amd-module name="tact-compiler/abi/struct.d.ts" /> 
 declare module "tact-compiler/abi/struct.d.ts" {
                import { AbiFunction } from "./AbiFunction";
export declare const StructFunctions: Map<string, AbiFunction>;

            };
/// <amd-module name="tact-compiler/ast/ast.d.ts" /> 
 declare module "tact-compiler/ast/ast.d.ts" {
                import { Address, Cell, Slice } from "@ijstech/ton-core";
import { SrcInfo } from "../grammar/src-info";
export type AstModule = {
    kind: "module";
    imports: AstImport[];
    items: AstModuleItem[];
    id: number;
};
export type AstImport = {
    kind: "import";
    path: AstString;
    id: number;
    loc: SrcInfo;
};
export type AstModuleItem = AstPrimitiveTypeDecl | AstFunctionDef | AstAsmFunctionDef | AstNativeFunctionDecl | AstConstantDef | AstStructDecl | AstMessageDecl | AstContract | AstTrait;
export type AstTypeDecl = AstPrimitiveTypeDecl | AstStructDecl | AstMessageDecl | AstContract | AstTrait;
export type AstPrimitiveTypeDecl = {
    kind: "primitive_type_decl";
    name: AstId;
    id: number;
    loc: SrcInfo;
};
export type AstFunctionDef = {
    kind: "function_def";
    attributes: AstFunctionAttribute[];
    name: AstId;
    return: AstType | null;
    params: AstTypedParameter[];
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstAsmFunctionDef = {
    kind: "asm_function_def";
    shuffle: AstAsmShuffle;
    attributes: AstFunctionAttribute[];
    name: AstId;
    return: AstType | null;
    params: AstTypedParameter[];
    instructions: AstAsmInstruction[];
    id: number;
    loc: SrcInfo;
};
export type AstAsmInstruction = string;
export type AstAsmShuffle = {
    args: AstId[];
    ret: AstNumber[];
};
export type AstFunctionDecl = {
    kind: "function_decl";
    attributes: AstFunctionAttribute[];
    name: AstId;
    return: AstType | null;
    params: AstTypedParameter[];
    id: number;
    loc: SrcInfo;
};
export type AstNativeFunctionDecl = {
    kind: "native_function_decl";
    attributes: AstFunctionAttribute[];
    name: AstId;
    nativeName: AstFuncId;
    params: AstTypedParameter[];
    return: AstType | null;
    id: number;
    loc: SrcInfo;
};
export type AstConstantDef = {
    kind: "constant_def";
    attributes: AstConstantAttribute[];
    name: AstId;
    type: AstType;
    initializer: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstConstantDecl = {
    kind: "constant_decl";
    attributes: AstConstantAttribute[];
    name: AstId;
    type: AstType;
    id: number;
    loc: SrcInfo;
};
export type AstStructDecl = {
    kind: "struct_decl";
    name: AstId;
    fields: AstFieldDecl[];
    id: number;
    loc: SrcInfo;
};
export type AstMessageDecl = {
    kind: "message_decl";
    name: AstId;
    opcode: AstExpression | null;
    fields: AstFieldDecl[];
    id: number;
    loc: SrcInfo;
};
export type AstContract = {
    kind: "contract";
    name: AstId;
    traits: AstId[];
    attributes: AstContractAttribute[];
    declarations: AstContractDeclaration[];
    id: number;
    loc: SrcInfo;
};
export type AstTrait = {
    kind: "trait";
    name: AstId;
    traits: AstId[];
    attributes: AstContractAttribute[];
    declarations: AstTraitDeclaration[];
    id: number;
    loc: SrcInfo;
};
export type AstContractDeclaration = AstFieldDecl | AstFunctionDef | AstAsmFunctionDef | AstContractInit | AstReceiver | AstConstantDef;
export type AstTraitDeclaration = AstFieldDecl | AstFunctionDef | AstAsmFunctionDef | AstFunctionDecl | AstReceiver | AstConstantDef | AstConstantDecl;
export type AstFieldDecl = {
    kind: "field_decl";
    name: AstId;
    type: AstType;
    initializer: AstExpression | null;
    as: AstId | null;
    id: number;
    loc: SrcInfo;
};
export type AstReceiver = {
    kind: "receiver";
    selector: AstReceiverKind;
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstContractInit = {
    kind: "contract_init";
    params: AstTypedParameter[];
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstStatement = AstStatementLet | AstStatementReturn | AstStatementExpression | AstStatementAssign | AstStatementAugmentedAssign | AstCondition | AstStatementWhile | AstStatementUntil | AstStatementRepeat | AstStatementTry | AstStatementTryCatch | AstStatementForEach | AstStatementDestruct | AstStatementBlock;
export type AstStatementLet = {
    kind: "statement_let";
    name: AstId;
    type: AstType | null;
    expression: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstStatementReturn = {
    kind: "statement_return";
    expression: AstExpression | null;
    id: number;
    loc: SrcInfo;
};
export type AstStatementExpression = {
    kind: "statement_expression";
    expression: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstStatementAssign = {
    kind: "statement_assign";
    path: AstExpression;
    expression: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstAugmentedAssignOperation = "+" | "-" | "*" | "/" | "&&" | "||" | "%" | "|" | "<<" | ">>" | "&" | "^";
export type AstStatementAugmentedAssign = {
    kind: "statement_augmentedassign";
    op: AstAugmentedAssignOperation;
    path: AstExpression;
    expression: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstCondition = {
    kind: "statement_condition";
    condition: AstExpression;
    trueStatements: AstStatement[];
    falseStatements: AstStatement[] | null;
    elseif: AstCondition | null;
    id: number;
    loc: SrcInfo;
};
export type AstStatementWhile = {
    kind: "statement_while";
    condition: AstExpression;
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstStatementUntil = {
    kind: "statement_until";
    condition: AstExpression;
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstStatementRepeat = {
    kind: "statement_repeat";
    iterations: AstExpression;
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstStatementTry = {
    kind: "statement_try";
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstStatementTryCatch = {
    kind: "statement_try_catch";
    statements: AstStatement[];
    catchName: AstId;
    catchStatements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstStatementForEach = {
    kind: "statement_foreach";
    keyName: AstId;
    valueName: AstId;
    map: AstExpression;
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstStatementDestruct = {
    kind: "statement_destruct";
    type: AstTypeId;
    /** field name -> [field id, local id] */
    identifiers: Map<string, [AstId, AstId]>;
    ignoreUnspecifiedFields: boolean;
    expression: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstStatementBlock = {
    kind: "statement_block";
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstType = AstTypeId | AstOptionalType | AstMapType | AstBouncedMessageType;
export type AstTypeId = {
    kind: "type_id";
    text: string;
    id: number;
    loc: SrcInfo;
};
export type AstOptionalType = {
    kind: "optional_type";
    typeArg: AstType;
    id: number;
    loc: SrcInfo;
};
export type AstMapType = {
    kind: "map_type";
    keyType: AstTypeId;
    keyStorageType: AstId | null;
    valueType: AstTypeId;
    valueStorageType: AstId | null;
    id: number;
    loc: SrcInfo;
};
export type AstBouncedMessageType = {
    kind: "bounced_message_type";
    messageType: AstTypeId;
    id: number;
    loc: SrcInfo;
};
export type AstExpression = AstOpBinary | AstOpUnary | AstConditional | AstMethodCall | AstFieldAccess | AstStaticCall | AstStructInstance | AstId | AstInitOf | AstString | AstLiteral;
export type AstLiteral = AstNumber | AstBoolean | AstNull | AstSimplifiedString | AstAddress | AstCell | AstSlice | AstCommentValue | AstStructValue;
export type AstBinaryOperation = "+" | "-" | "*" | "/" | "!=" | ">" | "<" | ">=" | "<=" | "==" | "&&" | "||" | "%" | "<<" | ">>" | "&" | "|" | "^";
export type AstOpBinary = {
    kind: "op_binary";
    op: AstBinaryOperation;
    left: AstExpression;
    right: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstUnaryOperation = "+" | "-" | "!" | "!!" | "~";
export type AstOpUnary = {
    kind: "op_unary";
    op: AstUnaryOperation;
    operand: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstFieldAccess = {
    kind: "field_access";
    aggregate: AstExpression;
    field: AstId;
    id: number;
    loc: SrcInfo;
};
export type AstMethodCall = {
    kind: "method_call";
    self: AstExpression;
    method: AstId;
    args: AstExpression[];
    id: number;
    loc: SrcInfo;
};
export type AstStaticCall = {
    kind: "static_call";
    function: AstId;
    args: AstExpression[];
    id: number;
    loc: SrcInfo;
};
export type AstStructInstance = {
    kind: "struct_instance";
    type: AstId;
    args: AstStructFieldInitializer[];
    id: number;
    loc: SrcInfo;
};
export type AstStructFieldInitializer = {
    kind: "struct_field_initializer";
    field: AstId;
    initializer: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstInitOf = {
    kind: "init_of";
    contract: AstId;
    args: AstExpression[];
    id: number;
    loc: SrcInfo;
};
export type AstConditional = {
    kind: "conditional";
    condition: AstExpression;
    thenBranch: AstExpression;
    elseBranch: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstId = {
    kind: "id";
    text: string;
    id: number;
    loc: SrcInfo;
};
export type AstFuncId = {
    kind: "func_id";
    text: string;
    id: number;
    loc: SrcInfo;
};
export declare function idText(ident: AstId | AstFuncId | AstTypeId): string;
export declare function isInt(ident: AstTypeId): boolean;
export declare function isBool(ident: AstTypeId): boolean;
export declare function isCell(ident: AstTypeId): boolean;
export declare function isSlice(ident: AstTypeId): boolean;
export declare function isBuilder(ident: AstTypeId): boolean;
export declare function isAddress(ident: AstTypeId): boolean;
export declare function isString(ident: AstTypeId): boolean;
export declare function isStringBuilder(ident: AstTypeId): boolean;
export declare function isSelfId(ident: AstId): boolean;
export declare function isWildcard(ident: AstId): boolean;
export declare function isRequire(ident: AstId): boolean;
export declare function eqNames(left: AstId | AstTypeId | string, right: AstId | AstTypeId | string): boolean;
export declare function idOfText(text: string): AstId;
export declare const selfId: AstId;
export type AstDestructMapping = {
    kind: "destruct_mapping";
    field: AstId;
    name: AstId;
    id: number;
    loc: SrcInfo;
};
export type AstDestructEnd = {
    kind: "destruct_end";
    ignoreUnspecifiedFields: boolean;
    id: number;
    loc: SrcInfo;
};
export type AstNumber = {
    kind: "number";
    base: AstNumberBase;
    value: bigint;
    id: number;
    loc: SrcInfo;
};
export type AstNumberBase = 2 | 8 | 10 | 16;
export declare function astNumToString(n: AstNumber): string;
export type AstBoolean = {
    kind: "boolean";
    value: boolean;
    id: number;
    loc: SrcInfo;
};
export type AstSimplifiedString = {
    kind: "simplified_string";
    value: string;
    id: number;
    loc: SrcInfo;
};
/**
 * @deprecated AstSimplifiedString
 */
export type AstString = {
    kind: "string";
    value: string;
    id: number;
    loc: SrcInfo;
};
export type AstNull = {
    kind: "null";
    id: number;
    loc: SrcInfo;
};
export type AstAddress = {
    kind: "address";
    value: Address;
    id: number;
    loc: SrcInfo;
};
export type AstCell = {
    kind: "cell";
    value: Cell;
    id: number;
    loc: SrcInfo;
};
export type AstSlice = {
    kind: "slice";
    value: Slice;
    id: number;
    loc: SrcInfo;
};
export type AstCommentValue = {
    kind: "comment_value";
    value: string;
    id: number;
    loc: SrcInfo;
};
export type AstStructValue = {
    kind: "struct_value";
    type: AstId;
    args: AstStructFieldValue[];
    id: number;
    loc: SrcInfo;
};
export type AstStructFieldValue = {
    kind: "struct_field_value";
    field: AstId;
    initializer: AstLiteral;
    id: number;
    loc: SrcInfo;
};
export type AstConstantAttributeName = "virtual" | "override" | "abstract";
export type AstConstantAttribute = {
    type: AstConstantAttributeName;
    loc: SrcInfo;
};
export type AstContractAttribute = {
    type: "interface";
    name: AstString;
    loc: SrcInfo;
};
export type AstFunctionAttributeGet = {
    kind: "function_attribute";
    type: "get";
    methodId: AstExpression | null;
    loc: SrcInfo;
};
export type AstFunctionAttributeName = "mutates" | "extends" | "virtual" | "abstract" | "override" | "inline";
export type AstFunctionAttributeRest = {
    kind: "function_attribute";
    type: AstFunctionAttributeName;
    loc: SrcInfo;
};
export type AstFunctionAttribute = AstFunctionAttributeGet | AstFunctionAttributeRest;
export type AstTypedParameter = {
    kind: "typed_parameter";
    name: AstId;
    type: AstType;
    id: number;
    loc: SrcInfo;
};
export type AstReceiverKind = {
    kind: "internal-simple";
    param: AstTypedParameter;
} | {
    kind: "internal-fallback";
} | {
    kind: "internal-comment";
    comment: AstString;
} | {
    kind: "bounce";
    param: AstTypedParameter;
} | {
    kind: "external-simple";
    param: AstTypedParameter;
} | {
    kind: "external-fallback";
} | {
    kind: "external-comment";
    comment: AstString;
};
export type AstNode = AstFuncId | AstDestructMapping | AstDestructEnd | AstExpression | AstStatement | AstTypeDecl | AstFieldDecl | AstTypedParameter | AstFunctionDef | AstFunctionAttribute | AstAsmFunctionDef | AstFunctionDecl | AstModule | AstNativeFunctionDecl | AstStructFieldInitializer | AstStructFieldValue | AstType | AstContractInit | AstReceiver | AstImport | AstConstantDef | AstConstantDecl;
/**
 * Check if input expression is a 'path expression',
 * i.e. an identifier or a sequence of field accesses starting from an identifier.
 * @param path A path expression to check.
 * @returns An array of identifiers or null if the input expression is not a path expression.
 */
export declare function tryExtractPath(path: AstExpression): AstId[] | null;
type DistributiveOmit<T, K extends keyof any> = T extends any ? Omit<T, K> : never;
export declare const getAstFactory: () => {
    createNode: (src: DistributiveOmit<AstNode, "id">) => AstNode;
    cloneNode: <T extends AstNode>(src: T) => T;
};
export type FactoryAst = ReturnType<typeof getAstFactory>;
export declare function eqExpressions(ast1: AstExpression, ast2: AstExpression): boolean;
export declare function isLiteral(ast: AstExpression): ast is AstLiteral;
export declare function checkLiteral<T>(ast: AstExpression, t: (node: AstLiteral) => T, f: (node: Exclude<AstExpression, AstLiteral>) => T): T;
export {};

            };
/// <amd-module name="tact-compiler/ast/clone.d.ts" /> 
 declare module "tact-compiler/ast/clone.d.ts" {
                import { AstNode, FactoryAst } from "./ast";
export declare function cloneNode<T extends AstNode>(src: T, { cloneNode }: FactoryAst): T;

            };
/// <amd-module name="tact-compiler/ast/compare.d.ts" /> 
 declare module "tact-compiler/ast/compare.d.ts" {
                import { AstNode } from "./ast";
/**
 * Provides an API to compare two AST nodes with extra options.
 */
export declare class AstComparator {
    private readonly sort;
    private readonly canonicalize;
    /**
     * @param sort Topologically sort AST entries before comparing. Should be enabled
     *        in order to handle duplicate entries shuffled in the source code.
     * @param canonicalize Introduce de Brujin indices for local bindings to handle
     *        duplicate code with different names. Should be enabled in order to
     *        treat duplicate entries with different names as the same elements.
     */
    private constructor();
    static make(options?: Partial<{
        sort: boolean;
        canonicalize: boolean;
    }>): AstComparator;
    compare(node1: AstNode, node2: AstNode): boolean;
    private compareNullableNodes;
    private compareArray;
    private compareNullableArray;
    private compareAsmInstructions;
    private compareAttributes;
    private compareReceiverKinds;
}

            };
/// <amd-module name="tact-compiler/ast/getAstSchema.d.ts" /> 
 declare module "tact-compiler/ast/getAstSchema.d.ts" {
                /**
 * AST node constructors are not just constructors: they also generate ids
 * We have this file so that the "current id" state would not be stored globally
 */
import { Loc } from "@tonstudio/parser-runtime";
import * as A from "./ast";
import { SrcInfo } from "../grammar/src-info";
export declare const getAstSchema: (factory: A.FactoryAst, toSrcInfo: (location: Loc) => SrcInfo) => {
    Module: (imports: A.AstImport[], items: A.AstModuleItem[]) => A.AstModule;
    Import: (path: A.AstString, loc: Loc) => A.AstImport;
    PrimitiveTypeDecl: (name: A.AstId, loc: Loc) => A.AstPrimitiveTypeDecl;
    FunctionDef: (attributes: A.AstFunctionAttribute[], name: A.AstId, retType: A.AstType | null, params: A.AstTypedParameter[], statements: A.AstStatement[], loc: Loc) => A.AstFunctionDef;
    AsmFunctionDef: (shuffle: A.AstAsmShuffle, attributes: A.AstFunctionAttribute[], name: A.AstId, retType: A.AstType | null, params: A.AstTypedParameter[], instructions: A.AstAsmInstruction[], loc: Loc) => A.AstAsmFunctionDef;
    FunctionDecl: (attributes: A.AstFunctionAttribute[], name: A.AstId, retType: A.AstType | null, params: A.AstTypedParameter[], loc: Loc) => A.AstFunctionDecl;
    NativeFunctionDecl: (attributes: A.AstFunctionAttribute[], name: A.AstId, nativeName: A.AstFuncId, params: A.AstTypedParameter[], retType: A.AstType | null, loc: Loc) => A.AstNativeFunctionDecl;
    ConstantDef: (attributes: A.AstConstantAttribute[], name: A.AstId, type: A.AstType, initializer: A.AstExpression, loc: Loc) => A.AstConstantDef;
    ConstantDecl: (attributes: A.AstConstantAttribute[], name: A.AstId, type: A.AstType, loc: Loc) => A.AstConstantDecl;
    StructDecl: (name: A.AstId, fields: A.AstFieldDecl[], loc: Loc) => A.AstStructDecl;
    MessageDecl: (name: A.AstId, opcode: A.AstExpression | null, fields: A.AstFieldDecl[], loc: Loc) => A.AstMessageDecl;
    Contract: (name: A.AstId, traits: A.AstId[], attributes: A.AstContractAttribute[], declarations: A.AstContractDeclaration[], loc: Loc) => A.AstContract;
    Trait: (name: A.AstId, traits: A.AstId[], attributes: A.AstContractAttribute[], declarations: A.AstTraitDeclaration[], loc: Loc) => A.AstTrait;
    FieldDecl: (name: A.AstId, type: A.AstType, initializer: A.AstExpression | null, as: A.AstId | null, loc: Loc) => A.AstFieldDecl;
    Receiver: (selector: A.AstReceiverKind, statements: A.AstStatement[], loc: Loc) => A.AstReceiver;
    ContractInit: (params: A.AstTypedParameter[], statements: A.AstStatement[], loc: Loc) => A.AstContractInit;
    StatementLet: (name: A.AstId, type: A.AstType | null, expression: A.AstExpression, loc: Loc) => A.AstStatementLet;
    StatementDestruct: (type: A.AstTypeId, identifiers: Map<string, [A.AstId, A.AstId]>, ignoreUnspecifiedFields: boolean, expression: A.AstExpression, loc: Loc) => A.AstStatementDestruct;
    StatementReturn: (expression: A.AstExpression | null, loc: Loc) => A.AstStatementReturn;
    StatementExpression: (expression: A.AstExpression, loc: Loc) => A.AstStatementExpression;
    StatementAssign: (path: A.AstExpression, expression: A.AstExpression, loc: Loc) => A.AstStatementAssign;
    StatementAugmentedAssign: (op: A.AstAugmentedAssignOperation, path: A.AstExpression, expression: A.AstExpression, loc: Loc) => A.AstStatementAugmentedAssign;
    Condition: (condition: A.AstExpression, trueStatements: A.AstStatement[], falseStatements: A.AstStatement[] | null, elseif: A.AstCondition | null, loc: Loc) => A.AstCondition;
    StatementWhile: (condition: A.AstExpression, statements: A.AstStatement[], loc: Loc) => A.AstStatementWhile;
    StatementUntil: (condition: A.AstExpression, statements: A.AstStatement[], loc: Loc) => A.AstStatementUntil;
    StatementRepeat: (iterations: A.AstExpression, statements: A.AstStatement[], loc: Loc) => A.AstStatementRepeat;
    StatementTry: (statements: A.AstStatement[], loc: Loc) => A.AstStatementTry;
    StatementTryCatch: (statements: A.AstStatement[], catchName: A.AstId, catchStatements: A.AstStatement[], loc: Loc) => A.AstStatementTryCatch;
    StatementForEach: (keyName: A.AstId, valueName: A.AstId, map: A.AstExpression, statements: A.AstStatement[], loc: Loc) => A.AstStatementForEach;
    StatementBlock: (statements: A.AstStatement[], loc: Loc) => A.AstStatementBlock;
    TypeId: (text: string, loc: Loc) => A.AstTypeId;
    OptionalType: (typeArg: A.AstType, loc: Loc) => A.AstOptionalType;
    MapType: (keyType: A.AstTypeId, keyStorageType: A.AstId | null, valueType: A.AstTypeId, valueStorageType: A.AstId | null, loc: Loc) => A.AstMapType;
    BouncedMessageType: (messageType: A.AstTypeId, loc: Loc) => A.AstBouncedMessageType;
    OpBinary: (op: A.AstBinaryOperation, left: A.AstExpression, right: A.AstExpression, loc: Loc) => A.AstOpBinary;
    OpUnary: (op: A.AstUnaryOperation, operand: A.AstExpression, loc: Loc) => A.AstOpUnary;
    FieldAccess: (aggregate: A.AstExpression, field: A.AstId, loc: Loc) => A.AstFieldAccess;
    MethodCall: (self: A.AstExpression, method: A.AstId, args: A.AstExpression[], loc: Loc) => A.AstMethodCall;
    StaticCall: (funcId: A.AstId, args: A.AstExpression[], loc: Loc) => A.AstStaticCall;
    StructInstance: (type: A.AstId, args: A.AstStructFieldInitializer[], loc: Loc) => A.AstStructInstance;
    StructFieldInitializer: (field: A.AstId, initializer: A.AstExpression, loc: Loc) => A.AstStructFieldInitializer;
    InitOf: (contract: A.AstId, args: A.AstExpression[], loc: Loc) => A.AstInitOf;
    Conditional: (condition: A.AstExpression, thenBranch: A.AstExpression, elseBranch: A.AstExpression, loc: Loc) => A.AstConditional;
    Id: (text: string, loc: Loc) => A.AstId;
    FuncId: (text: string, loc: Loc) => A.AstFuncId;
    Null: (loc: Loc) => A.AstNull;
    String: (value: string, loc: Loc) => A.AstString;
    Boolean: (value: boolean, loc: Loc) => A.AstBoolean;
    Number: (base: A.AstNumberBase, value: bigint, loc: Loc) => A.AstNumber;
    ContractAttribute: (name: A.AstString, loc: Loc) => A.AstContractAttribute;
    FunctionAttributeGet: (methodId: A.AstExpression | null, loc: Loc) => A.AstFunctionAttributeGet;
    FunctionAttribute: (type: A.AstFunctionAttributeName, loc: Loc) => A.AstFunctionAttributeRest;
    ConstantAttribute: (type: A.AstConstantAttributeName, loc: Loc) => A.AstConstantAttribute;
    TypedParameter: (name: A.AstId, type: A.AstType, loc: Loc) => A.AstTypedParameter;
};
/**
 * List of all constructors for AST nodes
 */
export type AstSchema = ReturnType<typeof getAstSchema>;

            };
/// <amd-module name="tact-compiler/ast/hash.d.ts" /> 
 declare module "tact-compiler/ast/hash.d.ts" {
                import { AstNode } from "./ast";
export type AstHash = string;
/**
 * Provides functionality to hash AST nodes regardless of identifiers.
 */
export declare class AstHasher {
    private readonly sort;
    private constructor();
    static make(params?: Partial<{
        sort: boolean;
    }>): AstHasher;
    hash(node: AstNode): AstHash;
    /**
     * Generates a string that is used to create a hash.
     */
    private getHashData;
    private hashDestructIdentifiers;
    private hashStructDecl;
    private hashMessageDecl;
    private hashFunctionDef;
    private hashAsmFunctionDef;
    private hashConstantDef;
    private hashTrait;
    private hashContract;
    private hashFields;
    private hashParams;
    private hashTypedParameter;
    private hashAttributes;
    private hashContractAttributes;
    private hashIds;
    private hashDeclarations;
    private hashStatements;
    private hashInstructions;
    private hashStructFieldInitializer;
    private hashFieldDecl;
    private hashContractInit;
    private hashNativeFunctionDecl;
    private hashReceiver;
    private hashFunctionDecl;
    private hashImport;
    private hashConstantDecl;
    private hashModule;
    private hashImports;
    private hashModuleItems;
}

            };
/// <amd-module name="tact-compiler/ast/iterators.d.ts" /> 
 declare module "tact-compiler/ast/iterators.d.ts" {
                import { AstNode } from "./ast";
/**
 * Recursively iterates over each node in an AstNode and applies a callback to each AST element.
 * @public
 * @param node The node to traverse.
 * @param callback The callback function to apply to each AST element.
 */
export declare function traverse(node: AstNode, callback: (node: AstNode) => void): void;

            };
/// <amd-module name="tact-compiler/ast/rename.d.ts" /> 
 declare module "tact-compiler/ast/rename.d.ts" {
                import { AstModuleItem, AstModule, AstNode } from "./ast";
/**
 * An utility class that provides alpha-renaming and topological sort functionality
 * for the AST comparison.
 */
export declare class AstRenamer {
    private sort;
    private currentIdx;
    private renamed;
    private givenNames;
    private constructor();
    static make(params?: Partial<{
        sort: boolean;
    }>): AstRenamer;
    /**
     * Renames the given node based on its AST.
     */
    renameModule(module: AstModule): AstNode;
    private nextIdx;
    /**
     * Generates a new unique node name.
     */
    private generateName;
    /**
     * Tries to get an identifier based on the node definition.
     */
    private getName;
    /**
     * Sets new or an existent name based on node's hash.
     */
    private setName;
    renameModuleItems(items: AstModuleItem[]): AstModuleItem[];
    /**
     * Lexicographically sort items based on their kinds and then by their names.
     */
    private sortModuleItems;
    /**
     * Changes the name of a top-level/contract/trait element without inspecting its body.
     */
    private changeItemName;
    /**
     * Renames the contents of an AstModuleItem based on its kind.
     */
    private renameModuleItemContents;
    /**
     * Sorts attributes within an item if available.
     */
    private sortAttributes;
    /**
     * Renames the contents of a function.
     */
    private renameFunctionContents;
    /**
     * Renames getter's methodId expression.
     */
    private renameFunctionAttributes;
    /**
     * Renames the contents of a constant, focusing on the initializer.
     */
    private renameConstantContents;
    /**
     * Renames the contents of a trait, including its declarations.
     */
    private renameTraitContents;
    /**
     * Renames the contents of a contract, including its declarations and parameters.
     */
    private renameContractContents;
    private renameStatements;
    private renameStatement;
    private renameExpression;
    private renameStructFieldInitializer;
}

            };
/// <amd-module name="tact-compiler/ast/sort.d.ts" /> 
 declare module "tact-compiler/ast/sort.d.ts" {
                import { AstFunctionAttribute, AstConstantAttribute, AstContractAttribute, AstNode } from "./ast";
/**
 * Provides utilities to sort lists of AST nodes.
 */
export declare class AstSorter {
    static sort<T extends AstNode>(items: T[]): T[];
    private static sortPrimitiveTypeDecls;
    static sortAttributes<T extends AstConstantAttribute | AstContractAttribute | AstFunctionAttribute>(attributes: T[]): T[];
}

            };
/// <amd-module name="tact-compiler/bindings/typescript/serializers.d.ts" /> 
 declare module "tact-compiler/bindings/typescript/serializers.d.ts" {
                import { ABITypeRef } from "@ijstech/ton-core";
import { Writer } from "../../utils/Writer";
type Serializer<T> = {
    tsType: (v: T) => string;
    tsLoad: (v: T, slice: string, field: string, w: Writer) => void;
    tsLoadTuple: (v: T, reader: string, field: string, w: Writer, fromGet: boolean) => void;
    tsStore: (v: T, builder: string, field: string, w: Writer) => void;
    tsStoreTuple: (v: T, to: string, field: string, w: Writer) => void;
    abiMatcher: (src: ABITypeRef) => T | null;
};
export declare const serializers: Serializer<any>[];
export {};

            };
/// <amd-module name="tact-compiler/bindings/typescript/writeStruct.d.ts" /> 
 declare module "tact-compiler/bindings/typescript/writeStruct.d.ts" {
                import { ABIType, ABITypeRef } from "@ijstech/ton-core";
import { AllocationCell } from "../../storage/operation";
import { Writer } from "../../utils/Writer";
export declare const maxTupleSize = 15;
export declare function writeStruct(name: string, fields: {
    name: string;
    type: ABITypeRef;
}[], exp: boolean, w: Writer): void;
export declare function writeParser(s: ABIType, allocation: AllocationCell, w: Writer): void;
export declare function writeSerializer(s: ABIType, allocation: AllocationCell, w: Writer): void;
export declare function writeInitSerializer(name: string, allocation: AllocationCell, w: Writer): void;
export declare function writeTupleParser(s: ABIType, w: Writer): void;
export declare function writeGetterTupleParser(s: ABIType, w: Writer): void;
export declare function writeGetParser(name: string, type: ABITypeRef, w: Writer): void;
export declare function writeTupleSerializer(s: ABIType, w: Writer): void;
export declare function writeArgumentToStack(name: string, ref: ABITypeRef, w: Writer): void;
export declare function writeDictParser(s: ABIType, w: Writer): void;

            };
/// <amd-module name="tact-compiler/bindings/writeTypescript.d.ts" /> 
 declare module "tact-compiler/bindings/writeTypescript.d.ts" {
                import { ABIArgument, ContractABI } from "@ijstech/ton-core";
export declare function writeTypescript(abi: ContractABI, init?: {
    code: string;
    system: string | null;
    args: ABIArgument[];
    prefix?: {
        value: number;
        bits: number;
    } | undefined;
}): string;

            };
/// <amd-module name="tact-compiler/browser.d.ts" /> 
 declare module "tact-compiler/browser.d.ts" {
                import { Config } from "./config/parseConfig";
import { ILogger } from "./context/logger";
export declare function run(args: {
    config: Config;
    files: Record<string, string>;
    logger?: ILogger;
}): Promise<{
    ok: boolean;
    error: Error[];
}>;

            };
/// <amd-module name="tact-compiler/config/features.d.ts" /> 
 declare module "tact-compiler/config/features.d.ts" {
                import { CompilerContext } from "../context/context";
export declare function enabledInline(ctx: CompilerContext): boolean;
export declare function enabledDebug(ctx: CompilerContext): boolean;
export declare function enabledExternals(ctx: CompilerContext): boolean;
export declare function enabledIpfsAbiGetter(ctx: CompilerContext): boolean;
export declare function enabledInterfacesGetter(ctx: CompilerContext): boolean;
export declare function featureEnable(ctx: CompilerContext, key: string): CompilerContext;

            };
/// <amd-module name="tact-compiler/config/parseConfig.d.ts" /> 
 declare module "tact-compiler/config/parseConfig.d.ts" {
                import { z } from "zod";
export declare const optionsSchema: z.ZodObject<{
    /**
     * If set to true, enables debug output of a contract and allows usage of `dump()` function,
     * which is useful for debugging purposes.
     *
     * Read more: https://docs.tact-lang.org/book/debug
     */
    debug: z.ZodOptional<z.ZodBoolean>;
    /**
     * If set to true, enables support of external message receivers.
     *
     * Read more: https://docs.tact-lang.org/book/external
     */
    external: z.ZodOptional<z.ZodBoolean>;
    /**
     * If set to true, enables generation of a getter with IPFS links describing the contract's ABI.
     *
     * Read more: https://docs.tact-lang.org/ref/evolution/OTP-003
     */
    ipfsAbiGetter: z.ZodOptional<z.ZodBoolean>;
    /**
     * If set to true, enables generation of a getter with a list of interfaces provided by the contract.
     *
     * Read more: https://docs.tact-lang.org/book/contracts#interfaces
     */
    interfacesGetter: z.ZodOptional<z.ZodBoolean>;
    /**
     * If set to "new", uses new parser. If set to "old", uses legacy parser. Default is "old".
     */
    parser: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"new">, z.ZodLiteral<"old">]>>;
    /**
     * Experimental options that might be removed in the future. Use with caution!
     */
    experimental: z.ZodOptional<z.ZodObject<{
        /**
         * If set to true, enables inlining of all functions in contracts.
         * This can reduce gas usage at the cost of bigger contracts.
         */
        inline: z.ZodOptional<z.ZodBoolean>;
    }, "strict", z.ZodTypeAny, {
        inline?: boolean | undefined;
    }, {
        inline?: boolean | undefined;
    }>>;
}, "strict", z.ZodTypeAny, {
    debug?: boolean | undefined;
    external?: boolean | undefined;
    ipfsAbiGetter?: boolean | undefined;
    interfacesGetter?: boolean | undefined;
    parser?: "new" | "old" | undefined;
    experimental?: {
        inline?: boolean | undefined;
    } | undefined;
}, {
    debug?: boolean | undefined;
    external?: boolean | undefined;
    ipfsAbiGetter?: boolean | undefined;
    interfacesGetter?: boolean | undefined;
    parser?: "new" | "old" | undefined;
    experimental?: {
        inline?: boolean | undefined;
    } | undefined;
}>;
export declare const projectSchema: z.ZodObject<{
    /**
     * Name of the project. All generated files are prefixed with it.
     *
     * Read more: https://docs.tact-lang.org/book/config#projects-name
     */
    name: z.ZodString;
    /**
     * Path to the project's Tact file. You can only specify one Tact file per project.
     *
     * Read more: https://docs.tact-lang.org/book/config#projects-path
     */
    path: z.ZodString;
    /**
     * Path to the directory where all generated files will be placed.
     *
     * Read more: https://docs.tact-lang.org/book/config#projects-output
     */
    output: z.ZodString;
    /**
     * Compilation options for the project.
     *
     * Read more: https://docs.tact-lang.org/book/config#projects-options
     */
    options: z.ZodOptional<z.ZodObject<{
        /**
         * If set to true, enables debug output of a contract and allows usage of `dump()` function,
         * which is useful for debugging purposes.
         *
         * Read more: https://docs.tact-lang.org/book/debug
         */
        debug: z.ZodOptional<z.ZodBoolean>;
        /**
         * If set to true, enables support of external message receivers.
         *
         * Read more: https://docs.tact-lang.org/book/external
         */
        external: z.ZodOptional<z.ZodBoolean>;
        /**
         * If set to true, enables generation of a getter with IPFS links describing the contract's ABI.
         *
         * Read more: https://docs.tact-lang.org/ref/evolution/OTP-003
         */
        ipfsAbiGetter: z.ZodOptional<z.ZodBoolean>;
        /**
         * If set to true, enables generation of a getter with a list of interfaces provided by the contract.
         *
         * Read more: https://docs.tact-lang.org/book/contracts#interfaces
         */
        interfacesGetter: z.ZodOptional<z.ZodBoolean>;
        /**
         * If set to "new", uses new parser. If set to "old", uses legacy parser. Default is "old".
         */
        parser: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"new">, z.ZodLiteral<"old">]>>;
        /**
         * Experimental options that might be removed in the future. Use with caution!
         */
        experimental: z.ZodOptional<z.ZodObject<{
            /**
             * If set to true, enables inlining of all functions in contracts.
             * This can reduce gas usage at the cost of bigger contracts.
             */
            inline: z.ZodOptional<z.ZodBoolean>;
        }, "strict", z.ZodTypeAny, {
            inline?: boolean | undefined;
        }, {
            inline?: boolean | undefined;
        }>>;
    }, "strict", z.ZodTypeAny, {
        debug?: boolean | undefined;
        external?: boolean | undefined;
        ipfsAbiGetter?: boolean | undefined;
        interfacesGetter?: boolean | undefined;
        parser?: "new" | "old" | undefined;
        experimental?: {
            inline?: boolean | undefined;
        } | undefined;
    }, {
        debug?: boolean | undefined;
        external?: boolean | undefined;
        ipfsAbiGetter?: boolean | undefined;
        interfacesGetter?: boolean | undefined;
        parser?: "new" | "old" | undefined;
        experimental?: {
            inline?: boolean | undefined;
        } | undefined;
    }>>;
    /**
     * Compilation mode of the project.
     *
     * Read more: https://docs.tact-lang.org/book/config#projects-mode
     */
    mode: z.ZodOptional<z.ZodEnum<["fullWithDecompilation", "full", "funcOnly", "checkOnly"]>>;
}, "strict", z.ZodTypeAny, {
    path: string;
    name: string;
    output: string;
    options?: {
        debug?: boolean | undefined;
        external?: boolean | undefined;
        ipfsAbiGetter?: boolean | undefined;
        interfacesGetter?: boolean | undefined;
        parser?: "new" | "old" | undefined;
        experimental?: {
            inline?: boolean | undefined;
        } | undefined;
    } | undefined;
    mode?: "fullWithDecompilation" | "full" | "funcOnly" | "checkOnly" | undefined;
}, {
    path: string;
    name: string;
    output: string;
    options?: {
        debug?: boolean | undefined;
        external?: boolean | undefined;
        ipfsAbiGetter?: boolean | undefined;
        interfacesGetter?: boolean | undefined;
        parser?: "new" | "old" | undefined;
        experimental?: {
            inline?: boolean | undefined;
        } | undefined;
    } | undefined;
    mode?: "fullWithDecompilation" | "full" | "funcOnly" | "checkOnly" | undefined;
}>;
export declare const configSchema: z.ZodObject<{
    /**
     * A property for specifying a path or URL to the JSON schema of tact.config.json
     *
     * Read more: https://docs.tact-lang.org/book/config#schema
     */
    $schema: z.ZodOptional<z.ZodString>;
    /**
     * List of Tact projects with respective compilation options. Each .tact file represents its own Tact project.
     *
     * Read more: https://docs.tact-lang.org/book/config#projects
     */
    projects: z.ZodArray<z.ZodObject<{
        /**
         * Name of the project. All generated files are prefixed with it.
         *
         * Read more: https://docs.tact-lang.org/book/config#projects-name
         */
        name: z.ZodString;
        /**
         * Path to the project's Tact file. You can only specify one Tact file per project.
         *
         * Read more: https://docs.tact-lang.org/book/config#projects-path
         */
        path: z.ZodString;
        /**
         * Path to the directory where all generated files will be placed.
         *
         * Read more: https://docs.tact-lang.org/book/config#projects-output
         */
        output: z.ZodString;
        /**
         * Compilation options for the project.
         *
         * Read more: https://docs.tact-lang.org/book/config#projects-options
         */
        options: z.ZodOptional<z.ZodObject<{
            /**
             * If set to true, enables debug output of a contract and allows usage of `dump()` function,
             * which is useful for debugging purposes.
             *
             * Read more: https://docs.tact-lang.org/book/debug
             */
            debug: z.ZodOptional<z.ZodBoolean>;
            /**
             * If set to true, enables support of external message receivers.
             *
             * Read more: https://docs.tact-lang.org/book/external
             */
            external: z.ZodOptional<z.ZodBoolean>;
            /**
             * If set to true, enables generation of a getter with IPFS links describing the contract's ABI.
             *
             * Read more: https://docs.tact-lang.org/ref/evolution/OTP-003
             */
            ipfsAbiGetter: z.ZodOptional<z.ZodBoolean>;
            /**
             * If set to true, enables generation of a getter with a list of interfaces provided by the contract.
             *
             * Read more: https://docs.tact-lang.org/book/contracts#interfaces
             */
            interfacesGetter: z.ZodOptional<z.ZodBoolean>;
            /**
             * If set to "new", uses new parser. If set to "old", uses legacy parser. Default is "old".
             */
            parser: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"new">, z.ZodLiteral<"old">]>>;
            /**
             * Experimental options that might be removed in the future. Use with caution!
             */
            experimental: z.ZodOptional<z.ZodObject<{
                /**
                 * If set to true, enables inlining of all functions in contracts.
                 * This can reduce gas usage at the cost of bigger contracts.
                 */
                inline: z.ZodOptional<z.ZodBoolean>;
            }, "strict", z.ZodTypeAny, {
                inline?: boolean | undefined;
            }, {
                inline?: boolean | undefined;
            }>>;
        }, "strict", z.ZodTypeAny, {
            debug?: boolean | undefined;
            external?: boolean | undefined;
            ipfsAbiGetter?: boolean | undefined;
            interfacesGetter?: boolean | undefined;
            parser?: "new" | "old" | undefined;
            experimental?: {
                inline?: boolean | undefined;
            } | undefined;
        }, {
            debug?: boolean | undefined;
            external?: boolean | undefined;
            ipfsAbiGetter?: boolean | undefined;
            interfacesGetter?: boolean | undefined;
            parser?: "new" | "old" | undefined;
            experimental?: {
                inline?: boolean | undefined;
            } | undefined;
        }>>;
        /**
         * Compilation mode of the project.
         *
         * Read more: https://docs.tact-lang.org/book/config#projects-mode
         */
        mode: z.ZodOptional<z.ZodEnum<["fullWithDecompilation", "full", "funcOnly", "checkOnly"]>>;
    }, "strict", z.ZodTypeAny, {
        path: string;
        name: string;
        output: string;
        options?: {
            debug?: boolean | undefined;
            external?: boolean | undefined;
            ipfsAbiGetter?: boolean | undefined;
            interfacesGetter?: boolean | undefined;
            parser?: "new" | "old" | undefined;
            experimental?: {
                inline?: boolean | undefined;
            } | undefined;
        } | undefined;
        mode?: "fullWithDecompilation" | "full" | "funcOnly" | "checkOnly" | undefined;
    }, {
        path: string;
        name: string;
        output: string;
        options?: {
            debug?: boolean | undefined;
            external?: boolean | undefined;
            ipfsAbiGetter?: boolean | undefined;
            interfacesGetter?: boolean | undefined;
            parser?: "new" | "old" | undefined;
            experimental?: {
                inline?: boolean | undefined;
            } | undefined;
        } | undefined;
        mode?: "fullWithDecompilation" | "full" | "funcOnly" | "checkOnly" | undefined;
    }>, "many">;
}, "strict", z.ZodTypeAny, {
    projects: {
        path: string;
        name: string;
        output: string;
        options?: {
            debug?: boolean | undefined;
            external?: boolean | undefined;
            ipfsAbiGetter?: boolean | undefined;
            interfacesGetter?: boolean | undefined;
            parser?: "new" | "old" | undefined;
            experimental?: {
                inline?: boolean | undefined;
            } | undefined;
        } | undefined;
        mode?: "fullWithDecompilation" | "full" | "funcOnly" | "checkOnly" | undefined;
    }[];
    $schema?: string | undefined;
}, {
    projects: {
        path: string;
        name: string;
        output: string;
        options?: {
            debug?: boolean | undefined;
            external?: boolean | undefined;
            ipfsAbiGetter?: boolean | undefined;
            interfacesGetter?: boolean | undefined;
            parser?: "new" | "old" | undefined;
            experimental?: {
                inline?: boolean | undefined;
            } | undefined;
        } | undefined;
        mode?: "fullWithDecompilation" | "full" | "funcOnly" | "checkOnly" | undefined;
    }[];
    $schema?: string | undefined;
}>;
/**
 * Compiler configuration schema
 *
 * Read more: https://docs.tact-lang.org/book/config
 */
export type Config = z.infer<typeof configSchema>;
/**
 * Per-project configuration options
 *
 * Read more: https://docs.tact-lang.org/book/config#projects
 */
export type ConfigProject = z.infer<typeof projectSchema>;
/**
 * Per-project configuration options
 *
 * Read more: https://docs.tact-lang.org/book/config#projects
 */
export type Options = z.infer<typeof optionsSchema>;
/**
 * Takes a stringified JSON [src] of a schema, converts to JSON and returns a parsed schema if it's valid
 *
 * @throws If the provided JSON string isn't a valid JSON
 * @throws If the provided JSON string isn't valid according to the config schema
 */
export declare function parseConfig(src: string): {
    projects: {
        path: string;
        name: string;
        output: string;
        options?: {
            debug?: boolean | undefined;
            external?: boolean | undefined;
            ipfsAbiGetter?: boolean | undefined;
            interfacesGetter?: boolean | undefined;
            parser?: "new" | "old" | undefined;
            experimental?: {
                inline?: boolean | undefined;
            } | undefined;
        } | undefined;
        mode?: "fullWithDecompilation" | "full" | "funcOnly" | "checkOnly" | undefined;
    }[];
    $schema?: string | undefined;
};
/**
 * Takes a config schema object and verifies that it's valid
 *
 * @throws If the provided object isn't valid according to the config schema
 */
export declare function verifyConfig(config: Config): {
    projects: {
        path: string;
        name: string;
        output: string;
        options?: {
            debug?: boolean | undefined;
            external?: boolean | undefined;
            ipfsAbiGetter?: boolean | undefined;
            interfacesGetter?: boolean | undefined;
            parser?: "new" | "old" | undefined;
            experimental?: {
                inline?: boolean | undefined;
            } | undefined;
        } | undefined;
        mode?: "fullWithDecompilation" | "full" | "funcOnly" | "checkOnly" | undefined;
    }[];
    $schema?: string | undefined;
};

            };
/// <amd-module name="tact-compiler/context/context.d.ts" /> 
 declare module "tact-compiler/context/context.d.ts" {
                type Key = string | number;
export type Store<T> = Map<Key, T>;
type Stores = Map<symbol, Store<any> | undefined>;
export declare class CompilerContext {
    readonly stores: Stores;
    constructor(args?: {
        stores: Stores;
    });
    updateStore: <T>(storeDispatch: symbol, key: Key, value: T) => CompilerContext;
}
export declare function createContextStore<T>(): {
    get(ctx: CompilerContext, key: Key): T | null;
    all(ctx: CompilerContext): Store<T>;
    set(ctx: CompilerContext, key: Key, v: T): CompilerContext;
};
export {};

            };
/// <amd-module name="tact-compiler/context/logger.d.ts" /> 
 declare module "tact-compiler/context/logger.d.ts" {
                export declare enum LogLevel {
    /** Logging is turned off */
    NONE = 0,
    /** Logs only error messages */
    ERROR = 1,
    /** Logs warning and error messages */
    WARN = 2,
    /** Logs informational, warning, and error messages */
    INFO = 3,
    /** Logs debugging, informational, warning, and error messages */
    DEBUG = 4
}
type messageType = string | Error;
/**
 * Interface defining the logging methods used by the `Logger` class, enabling
 * custom logger implementations.
 */
export interface ILogger {
    debug: (message: messageType) => void;
    info: (message: messageType) => void;
    warn: (message: messageType) => void;
    error: (message: messageType) => void;
}
export declare class Logger {
    private level;
    private logMethods;
    constructor(level?: LogLevel);
    protected log(level: LogLevel, message: messageType): void;
    debug(message: messageType): void;
    info(message: messageType): void;
    warn(message: messageType): void;
    error(message: messageType): void;
    setLevel(level: LogLevel): void;
}
export {};

            };
/// <amd-module name="tact-compiler/context/store.d.ts" /> 
 declare module "tact-compiler/context/store.d.ts" {
                import { AstModule, AstConstantDef, AstFunctionDef, AstNativeFunctionDecl, AstTypeDecl, AstAsmFunctionDef } from "../ast/ast";
import { CompilerContext } from "./context";
import { ItemOrigin } from "../grammar/src-info";
import { Parser } from "../grammar/grammar";
/**
 * @public
 */
export type TactSource = {
    code: string;
    path: string;
    origin: ItemOrigin;
};
/**
 * Represents the storage for all AST-related data within the compiler context.
 * @public
 * @property functions AST entries representing top-level functions.
 * @property constants AST entries representing top-level constant definitions.
 * @property types AST entries representing structures, contracts, and traits.
 */
export type AstStore = {
    sources: TactSource[];
    funcSources: {
        code: string;
        path: string;
    }[];
    functions: (AstFunctionDef | AstNativeFunctionDecl | AstAsmFunctionDef)[];
    constants: AstConstantDef[];
    types: AstTypeDecl[];
};
/**
 * Retrieves the raw AST for the given context.
 * @public
 * @param ctx The compiler context from which the AST is retrieved.
 * @throws Will throw an error if the AST is not found in the context.
 * @returns The AST types associated with the context.
 */
export declare function getRawAST(ctx: CompilerContext): AstStore;
/**
 * Parses multiple Tact source files into AST modules.
 * @public
 */
export declare function parseModules(sources: TactSource[], parser: Parser): AstModule[];
/**
 * Extends the compiler context by adding AST entries and source information from
 * given sources and parsed programs.
 * @public
 * @param parsedModules An optional array of previously parsed programs. If not defined, they will be parsed from `sources`.
 * @returns The updated compiler context.
 */
export declare function openContext(ctx: CompilerContext, sources: TactSource[], funcSources: {
    code: string;
    path: string;
}[], parser: Parser, parsedModules?: AstModule[]): CompilerContext;

            };
/// <amd-module name="tact-compiler/error/display-to-json.d.ts" /> 
 declare module "tact-compiler/error/display-to-json.d.ts" {
                /**
 * Render error message to JSON for tests
 */
import { SrcInfo } from "../grammar";
import { ErrorDisplay } from "./display";
export type ErrorJson = ErrorSub | ErrorText | ErrorLink | ErrorAt;
export type ErrorText = {
    kind: "text";
    text: string;
};
export type ErrorSub = {
    kind: "sub";
    parts: string[];
    subst: ErrorJson[];
};
export type ErrorLink = {
    kind: "link";
    text: string;
    loc: SrcInfo;
};
export type ErrorAt = {
    kind: "at";
    body: ErrorJson;
    loc: SrcInfo;
};
export declare const errorJsonEqual: (left: ErrorJson, right: ErrorJson) => boolean;
export declare const displayToJson: ErrorDisplay<ErrorJson>;

            };
/// <amd-module name="tact-compiler/error/display-to-string.d.ts" /> 
 declare module "tact-compiler/error/display-to-string.d.ts" {
                /**
 * Render error message to string for compiler CLI
 */
import { ErrorDisplay } from "./display";
export declare const displayToString: ErrorDisplay<string>;

            };
/// <amd-module name="tact-compiler/error/display.d.ts" /> 
 declare module "tact-compiler/error/display.d.ts" {
                /**
 * Describes DSL for displaying errors
 */
import { SrcInfo } from "../grammar";
export interface ErrorDisplay<T> {
    at: (loc: SrcInfo, body: T) => T;
    text: (text: string) => T;
    sub: (text: TemplateStringsArray, ...subst: T[]) => T;
    link: (text: string, loc: SrcInfo) => T;
}

            };
/// <amd-module name="tact-compiler/error/errors.d.ts" /> 
 declare module "tact-compiler/error/errors.d.ts" {
                import { AstFuncId, AstId, AstTypeId } from "../ast/ast";
import { SrcInfo } from "../grammar";
export declare class TactError extends Error {
    readonly loc?: SrcInfo;
    constructor(message: string, loc?: SrcInfo);
}
export declare class TactCompilationError extends TactError {
    constructor(message: string, loc?: SrcInfo);
}
export declare class TactInternalCompilerError extends TactError {
    constructor(message: string, loc?: SrcInfo);
}
export declare class TactConstEvalError extends TactCompilationError {
    fatal: boolean;
    constructor(message: string, fatal: boolean, loc: SrcInfo);
}
export declare function locationStr(sourceInfo: SrcInfo): string;
export declare function throwCompilationError(message: string, source?: SrcInfo): never;
export declare function throwInternalCompilerError(message: string, source?: SrcInfo): never;
export declare function throwConstEvalError(message: string, fatal: boolean, source: SrcInfo): never;
export declare function idTextErr(ident: AstId | AstFuncId | AstTypeId | string): string;
export type TactErrorCollection = Error | TactCompilationError | TactInternalCompilerError | TactConstEvalError;

            };
/// <amd-module name="tact-compiler/func/funcCompile.d.ts" /> 
 declare module "tact-compiler/func/funcCompile.d.ts" {
                import { ILogger } from "../context/logger";
export type FuncCompilationResult = {
    ok: false;
    log: string;
    fift: string | null;
    output: Buffer | null;
} | {
    ok: true;
    log: string;
    fift: string;
    output: Buffer;
};
export declare function funcCompile(args: {
    entries: string[];
    sources: {
        path: string;
        content: string;
    }[];
    logger: ILogger;
}): Promise<FuncCompilationResult>;

            };
/// <amd-module name="tact-compiler/generator/createABI.d.ts" /> 
 declare module "tact-compiler/generator/createABI.d.ts" {
                import { ContractABI } from "@ijstech/ton-core";
import { CompilerContext } from "../context/context";
export declare function createABI(ctx: CompilerContext, name: string): ContractABI;

            };
/// <amd-module name="tact-compiler/generator/emitter/createPadded.d.ts" /> 
 declare module "tact-compiler/generator/emitter/createPadded.d.ts" {
                export declare function createPadded(src: string): string;

            };
/// <amd-module name="tact-compiler/generator/emitter/emit.d.ts" /> 
 declare module "tact-compiler/generator/emitter/emit.d.ts" {
                import { Maybe } from "@ijstech/ton-core";
import { WrittenFunction } from "../Writer";
export declare function emit(args: {
    header?: Maybe<string>;
    functions?: Maybe<WrittenFunction[]>;
}): string;

            };
/// <amd-module name="tact-compiler/generator/writeProgram.d.ts" /> 
 declare module "tact-compiler/generator/writeProgram.d.ts" {
                import { CompilerContext } from "../context/context";
import { ContractABI } from "@ijstech/ton-core";
export declare function writeProgram(ctx: CompilerContext, abiSrc: ContractABI, basename: string, debug?: boolean): Promise<{
    entrypoint: string;
    files: {
        name: string;
        code: string;
    }[];
    abi: string;
}>;

            };
/// <amd-module name="tact-compiler/generator/Writer.d.ts" /> 
 declare module "tact-compiler/generator/Writer.d.ts" {
                import { CompilerContext } from "../context/context";
type Flag = "inline" | "impure" | "inline_ref";
type Body = {
    kind: "generic";
    code: string;
} | {
    kind: "asm";
    shuffle: string;
    code: string;
} | {
    kind: "skip";
};
export type WrittenFunction = {
    name: string;
    code: Body;
    signature: string;
    flags: Set<Flag>;
    depends: Set<string>;
    comment: string | null;
    context: string | null;
};
export declare class WriterContext {
    #private;
    readonly ctx: CompilerContext;
    constructor(ctx: CompilerContext, name: string);
    get name(): string;
    clone(): WriterContext;
    extract(debug?: boolean): WrittenFunction[];
    skip(name: string): void;
    fun(name: string, handler: () => void): void;
    asm(shuffle: string, code: string): void;
    body(handler: () => void): void;
    main(handler: () => void): void;
    signature(sig: string): void;
    flag(flag: Flag): void;
    used(name: string): string;
    comment(src: string): void;
    context(src: string): void;
    currentContext(): string | null;
    inIndent: (handler: () => void) => void;
    append(src?: string): void;
    write(src?: string): void;
    isRendered(key: string): boolean;
    markRendered(key: string): void;
}
export {};

            };
/// <amd-module name="tact-compiler/generator/writeReport.d.ts" /> 
 declare module "tact-compiler/generator/writeReport.d.ts" {
                import { CompilerContext } from "../context/context";
import { PackageFileFormat } from "../packaging/fileFormat";
export declare function writeReport(ctx: CompilerContext, pkg: PackageFileFormat): string;

            };
/// <amd-module name="tact-compiler/generator/writers/cast.d.ts" /> 
 declare module "tact-compiler/generator/writers/cast.d.ts" {
                import { TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function cast(from: TypeRef, to: TypeRef, expression: string, ctx: WriterContext): string;

            };
/// <amd-module name="tact-compiler/generator/writers/freshIdentifier.d.ts" /> 
 declare module "tact-compiler/generator/writers/freshIdentifier.d.ts" {
                export declare function freshIdentifier(prefix: string): string;

            };
/// <amd-module name="tact-compiler/generator/writers/id.d.ts" /> 
 declare module "tact-compiler/generator/writers/id.d.ts" {
                import { AstId } from "../../ast/ast";
export declare function funcIdOf(ident: AstId | string): string;
export declare function funcInitIdOf(ident: AstId | string): string;

            };
/// <amd-module name="tact-compiler/generator/writers/ops.d.ts" /> 
 declare module "tact-compiler/generator/writers/ops.d.ts" {
                import { WriterContext } from "../Writer";
export declare const ops: {
    writer: (type: string, ctx: WriterContext) => string;
    writerCell: (type: string, ctx: WriterContext) => string;
    writerCellOpt: (type: string, ctx: WriterContext) => string;
    reader: (type: string, ctx: WriterContext) => string;
    readerNonModifying: (type: string, ctx: WriterContext) => string;
    readerBounced: (type: string, ctx: WriterContext) => string;
    readerOpt: (type: string, ctx: WriterContext) => string;
    typeField: (type: string, name: string, ctx: WriterContext) => string;
    typeTensorCast: (type: string, ctx: WriterContext) => string;
    typeNotNull: (type: string, ctx: WriterContext) => string;
    typeAsOptional: (type: string, ctx: WriterContext) => string;
    typeToTuple: (type: string, ctx: WriterContext) => string;
    typeToOptTuple: (type: string, ctx: WriterContext) => string;
    typeFromTuple: (type: string, ctx: WriterContext) => string;
    typeFromOptTuple: (type: string, ctx: WriterContext) => string;
    typeToExternal: (type: string, ctx: WriterContext) => string;
    typeToOptExternal: (type: string, ctx: WriterContext) => string;
    typeConstructor: (type: string, fields: string[], ctx: WriterContext) => string;
    contractInit: (type: string, ctx: WriterContext) => string;
    contractInitChild: (type: string, ctx: WriterContext) => string;
    contractLoad: (type: string, ctx: WriterContext) => string;
    contractStore: (type: string, ctx: WriterContext) => string;
    contractRouter: (type: string, kind: "internal" | "external") => string;
    receiveEmpty: (type: string, kind: "internal" | "external") => string;
    receiveType: (type: string, kind: "internal" | "external", msg: string) => string;
    receiveAnyText: (type: string, kind: "internal" | "external") => string;
    receiveText: (type: string, kind: "internal" | "external", hash: string) => string;
    receiveAny: (type: string, kind: "internal" | "external") => string;
    receiveTypeBounce: (type: string, msg: string) => string;
    receiveBounceAny: (type: string) => string;
    extension: (type: string, name: string) => string;
    global: (name: string) => string;
    nonModifying: (name: string) => string;
    str: (id: string, ctx: WriterContext) => string;
};

            };
/// <amd-module name="tact-compiler/generator/writers/resolveFuncFlatPack.d.ts" /> 
 declare module "tact-compiler/generator/writers/resolveFuncFlatPack.d.ts" {
                import { TypeDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function resolveFuncFlatPack(descriptor: TypeRef | TypeDescription | string, name: string, ctx: WriterContext, optional?: boolean): string[];

            };
/// <amd-module name="tact-compiler/generator/writers/resolveFuncFlatTypes.d.ts" /> 
 declare module "tact-compiler/generator/writers/resolveFuncFlatTypes.d.ts" {
                import { TypeDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function resolveFuncFlatTypes(descriptor: TypeRef | TypeDescription | string, ctx: WriterContext, optional?: boolean): string[];

            };
/// <amd-module name="tact-compiler/generator/writers/resolveFuncPrimitive.d.ts" /> 
 declare module "tact-compiler/generator/writers/resolveFuncPrimitive.d.ts" {
                import { TypeDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function resolveFuncPrimitive(descriptor: TypeRef | TypeDescription | string, ctx: WriterContext): boolean;

            };
/// <amd-module name="tact-compiler/generator/writers/resolveFuncTupleType.d.ts" /> 
 declare module "tact-compiler/generator/writers/resolveFuncTupleType.d.ts" {
                import { TypeDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function resolveFuncTupleType(descriptor: TypeRef | TypeDescription | string, ctx: WriterContext): string;

            };
/// <amd-module name="tact-compiler/generator/writers/resolveFuncType.d.ts" /> 
 declare module "tact-compiler/generator/writers/resolveFuncType.d.ts" {
                import { TypeDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function resolveFuncType(descriptor: TypeRef | TypeDescription | string, ctx: WriterContext, optional?: boolean, usePartialFields?: boolean): string;

            };
/// <amd-module name="tact-compiler/generator/writers/resolveFuncTypeFromAbi.d.ts" /> 
 declare module "tact-compiler/generator/writers/resolveFuncTypeFromAbi.d.ts" {
                import { ABITypeRef } from "@ijstech/ton-core";
import { WriterContext } from "../Writer";
export declare function resolveFuncTypeFromAbi(fields: ABITypeRef[], ctx: WriterContext): string;

            };
/// <amd-module name="tact-compiler/generator/writers/resolveFuncTypeFromAbiUnpack.d.ts" /> 
 declare module "tact-compiler/generator/writers/resolveFuncTypeFromAbiUnpack.d.ts" {
                import { ABITypeRef } from "@ijstech/ton-core";
import { WriterContext } from "../Writer";
export declare function resolveFuncTypeFromAbiUnpack(name: string, fields: {
    name: string;
    type: ABITypeRef;
}[], ctx: WriterContext): string;

            };
/// <amd-module name="tact-compiler/generator/writers/resolveFuncTypeUnpack.d.ts" /> 
 declare module "tact-compiler/generator/writers/resolveFuncTypeUnpack.d.ts" {
                import { TypeDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function resolveFuncTypeUnpack(descriptor: TypeRef | TypeDescription | string, name: string, ctx: WriterContext, optional?: boolean, usePartialFields?: boolean): string;

            };
/// <amd-module name="tact-compiler/generator/writers/writeAccessors.d.ts" /> 
 declare module "tact-compiler/generator/writers/writeAccessors.d.ts" {
                import { ItemOrigin } from "../../grammar";
import { TypeDescription } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function writeAccessors(type: TypeDescription, origin: ItemOrigin, ctx: WriterContext): void;

            };
/// <amd-module name="tact-compiler/generator/writers/writeConstant.d.ts" /> 
 declare module "tact-compiler/generator/writers/writeConstant.d.ts" {
                import { Address, Cell, Slice } from "@ijstech/ton-core";
import { WriterContext } from "../Writer";
export declare function writeString(str: string, ctx: WriterContext): string;
export declare function writeComment(str: string, ctx: WriterContext): string;
export declare function writeAddress(address: Address, ctx: WriterContext): string;
export declare function writeCell(cell: Cell, ctx: WriterContext): string;
export declare function writeSlice(slice: Slice, ctx: WriterContext): string;

            };
/// <amd-module name="tact-compiler/generator/writers/writeContract.d.ts" /> 
 declare module "tact-compiler/generator/writers/writeContract.d.ts" {
                import { ItemOrigin } from "../../grammar";
import { InitDescription, TypeDescription } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function writeStorageOps(type: TypeDescription, origin: ItemOrigin, ctx: WriterContext): void;
export declare function writeInit(t: TypeDescription, init: InitDescription, ctx: WriterContext): void;
export declare function writeMainContract(type: TypeDescription, abiLink: string, ctx: WriterContext): void;

            };
/// <amd-module name="tact-compiler/generator/writers/writeExpression.d.ts" /> 
 declare module "tact-compiler/generator/writers/writeExpression.d.ts" {
                import { AstExpression, AstId, AstLiteral } from "../../ast/ast";
import { WriterContext } from "../Writer";
export declare function writeValue(val: AstLiteral, wCtx: WriterContext): string;
export declare function writePathExpression(path: AstId[]): string;
export declare function writeExpression(f: AstExpression, wCtx: WriterContext): string;

            };
/// <amd-module name="tact-compiler/generator/writers/writeFunction.d.ts" /> 
 declare module "tact-compiler/generator/writers/writeFunction.d.ts" {
                import { AstExpression, AstStatement } from "../../ast/ast";
import { FunctionDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function writeCastedExpression(expression: AstExpression, to: TypeRef, ctx: WriterContext): string;
export declare function writeStatement(f: AstStatement, self: string | null, returns: TypeRef | null, ctx: WriterContext): void;
export declare function writeFunction(f: FunctionDescription, ctx: WriterContext): void;
export declare function writeGetter(f: FunctionDescription, wCtx: WriterContext): void;

            };
/// <amd-module name="tact-compiler/generator/writers/writeInterfaces.d.ts" /> 
 declare module "tact-compiler/generator/writers/writeInterfaces.d.ts" {
                import { TypeDescription } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function writeInterfaces(type: TypeDescription, ctx: WriterContext): void;

            };
/// <amd-module name="tact-compiler/generator/writers/writeRouter.d.ts" /> 
 declare module "tact-compiler/generator/writers/writeRouter.d.ts" {
                import { ReceiverDescription, TypeDescription } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function commentPseudoOpcode(comment: string): string;
export declare function writeRouter(type: TypeDescription, kind: "internal" | "external", ctx: WriterContext): void;
export declare function writeReceiver(self: TypeDescription, f: ReceiverDescription, ctx: WriterContext): void;

            };
/// <amd-module name="tact-compiler/generator/writers/writeSerialization.d.ts" /> 
 declare module "tact-compiler/generator/writers/writeSerialization.d.ts" {
                import { ItemOrigin } from "../../grammar";
import { StorageAllocation } from "../../storage/StorageAllocation";
import { WriterContext } from "../Writer";
export declare function writeSerializer(name: string, forceInline: boolean, allocation: StorageAllocation, origin: ItemOrigin, ctx: WriterContext): void;
export declare function writeOptionalSerializer(name: string, origin: ItemOrigin, ctx: WriterContext): void;
export declare function writeParser(name: string, forceInline: boolean, allocation: StorageAllocation, origin: ItemOrigin, ctx: WriterContext): void;
export declare function writeBouncedParser(name: string, forceInline: boolean, allocation: StorageAllocation, origin: ItemOrigin, ctx: WriterContext): void;
export declare function writeOptionalParser(name: string, origin: ItemOrigin, ctx: WriterContext): void;

            };
/// <amd-module name="tact-compiler/generator/writers/writeStdlib.d.ts" /> 
 declare module "tact-compiler/generator/writers/writeStdlib.d.ts" {
                import { WriterContext } from "../Writer";
export declare function writeStdlib(ctx: WriterContext): void;

            };
/// <amd-module name="tact-compiler/grammar/grammar.d.ts" /> 
 declare module "tact-compiler/grammar/grammar.d.ts" {
                import { AstExpression, AstImport, AstModule, FactoryAst } from "../ast/ast";
import { ItemOrigin } from "./src-info";
export type Parser = {
    parse: (src: string, path: string, origin: ItemOrigin) => AstModule;
    parseExpression: (sourceCode: string) => AstExpression;
    parseImports: (src: string, path: string, origin: ItemOrigin) => AstImport[];
};
export declare const defaultParser = "new";
export declare const getParser: (ast: FactoryAst, version: "old" | "new") => Parser;

            };
/// <amd-module name="tact-compiler/grammar/next/grammar.d.ts" /> 
 declare module "tact-compiler/grammar/next/grammar.d.ts" {
                import * as $ from "@tonstudio/parser-runtime";
export declare namespace $ast {
    type Module = $.Located<{
        readonly $: "Module";
        readonly imports: readonly Import[];
        readonly items: readonly moduleItem[];
    }>;
    type Import = $.Located<{
        readonly $: "Import";
        readonly path: StringLiteral;
    }>;
    type PrimitiveTypeDecl = $.Located<{
        readonly $: "PrimitiveTypeDecl";
        readonly name: TypeId;
    }>;
    type $Function = $.Located<{
        readonly $: "Function";
        readonly attributes: readonly FunctionAttribute[];
        readonly name: Id;
        readonly parameters: parameterList<Parameter>;
        readonly returnType: ascription | undefined;
        readonly body: FunctionDefinition | FunctionDeclaration;
    }>;
    type AsmFunction = $.Located<{
        readonly $: "AsmFunction";
        readonly shuffle: shuffle | undefined;
        readonly attributes: readonly FunctionAttribute[];
        readonly name: Id;
        readonly parameters: parameterList<Parameter>;
        readonly returnType: ascription | undefined;
        readonly instructions: assembly;
    }>;
    type NativeFunctionDecl = $.Located<{
        readonly $: "NativeFunctionDecl";
        readonly nativeName: FuncId;
        readonly attributes: readonly FunctionAttribute[];
        readonly name: Id;
        readonly parameters: parameterList<Parameter>;
        readonly returnType: ascription | undefined;
    }>;
    type Constant = $.Located<{
        readonly $: "Constant";
        readonly attributes: readonly ConstantAttribute[];
        readonly name: Id;
        readonly type: ascription;
        readonly body: ConstantDefinition | ConstantDeclaration;
    }>;
    type StructDecl = $.Located<{
        readonly $: "StructDecl";
        readonly name: TypeId;
        readonly fields: structFields;
    }>;
    type MessageDecl = $.Located<{
        readonly $: "MessageDecl";
        readonly opcode: expression | undefined;
        readonly name: TypeId;
        readonly fields: structFields;
    }>;
    type Contract = $.Located<{
        readonly $: "Contract";
        readonly attributes: readonly ContractAttribute[];
        readonly name: Id;
        readonly traits: inheritedTraits | undefined;
        readonly declarations: readonly contractItemDecl[];
    }>;
    type Trait = $.Located<{
        readonly $: "Trait";
        readonly attributes: readonly ContractAttribute[];
        readonly name: Id;
        readonly traits: inheritedTraits | undefined;
        readonly declarations: readonly traitItemDecl[];
    }>;
    type moduleItem = PrimitiveTypeDecl | $Function | AsmFunction | NativeFunctionDecl | Constant | StructDecl | MessageDecl | Contract | Trait;
    type ContractInit = $.Located<{
        readonly $: "ContractInit";
        readonly parameters: parameterList<Parameter>;
        readonly body: statements;
    }>;
    type Receiver = $.Located<{
        readonly $: "Receiver";
        readonly type: receiverType;
        readonly param: receiverParam;
        readonly body: statements;
    }>;
    type FieldDecl = $.Located<{
        readonly $: "FieldDecl";
        readonly name: Id;
        readonly type: ascription;
        readonly as: asType | undefined;
        readonly expression: expression | undefined;
    }>;
    type semicolon = ";" | "}";
    type storageVar = FieldDecl;
    type contractItemDecl = ContractInit | Receiver | $Function | Constant | storageVar;
    type traitItemDecl = Receiver | $Function | Constant | storageVar;
    type FunctionDefinition = $.Located<{
        readonly $: "FunctionDefinition";
        readonly body: statements;
    }>;
    type FunctionDeclaration = $.Located<{
        readonly $: "FunctionDeclaration";
    }>;
    type Id = $.Located<{
        readonly $: "Id";
        readonly name: string;
    }>;
    type IntegerLiteralDec = $.Located<{
        readonly $: "IntegerLiteralDec";
        readonly digits: underscored<digit>;
    }>;
    type shuffle = {
        readonly ids: readonly Id[];
        readonly to: readonly IntegerLiteralDec[] | undefined;
    };
    type ConstantAttribute = $.Located<{
        readonly $: "ConstantAttribute";
        readonly name: keyword<"virtual"> | keyword<"override"> | keyword<"abstract">;
    }>;
    type ConstantDefinition = $.Located<{
        readonly $: "ConstantDefinition";
        readonly expression: expression;
    }>;
    type ConstantDeclaration = $.Located<{
        readonly $: "ConstantDeclaration";
    }>;
    type inter<A, B> = {
        readonly head: A;
        readonly tail: readonly {
            readonly op: B;
            readonly right: A;
        }[];
    };
    type structFields = inter<FieldDecl, ";"> | undefined;
    type keyword<T> = T;
    type commaList<T> = inter<T, ",">;
    type inheritedTraits = commaList<Id>;
    type ContractAttribute = $.Located<{
        readonly $: "ContractAttribute";
        readonly name: StringLiteral;
    }>;
    type FunctionAttribute = $.Located<{
        readonly $: "FunctionAttribute";
        readonly name: GetAttribute | keyword<"mutates"> | keyword<"extends"> | keyword<"virtual"> | keyword<"override"> | keyword<"inline"> | keyword<"abstract">;
    }>;
    type GetAttribute = $.Located<{
        readonly $: "GetAttribute";
        readonly methodId: expression | undefined;
    }>;
    type receiverType = "bounced" | keyword<"receive"> | keyword<"external">;
    type Parameter = $.Located<{
        readonly $: "Parameter";
        readonly name: Id;
        readonly type: ascription;
    }>;
    type StringLiteral = $.Located<{
        readonly $: "StringLiteral";
        readonly value: string;
    }>;
    type receiverParam = Parameter | StringLiteral | undefined;
    type assembly = string;
    type multiLineComment = string;
    type singleLineComment = string;
    type comment = multiLineComment | singleLineComment;
    type assemblyItem = {} | comment | {} | readonly {}[];
    type assemblySequence = readonly assemblyItem[];
    type TypeOptional = $.Located<{
        readonly $: "TypeOptional";
        readonly child: TypeId;
    }>;
    type TypeRegular = $.Located<{
        readonly $: "TypeRegular";
        readonly child: TypeId;
    }>;
    type TypeMap = $.Located<{
        readonly $: "TypeMap";
        readonly key: TypeId;
        readonly keyAs: asType | undefined;
        readonly value: TypeId;
        readonly valueAs: asType | undefined;
    }>;
    type TypeBounced = $.Located<{
        readonly $: "TypeBounced";
        readonly child: TypeId;
    }>;
    type $type = TypeOptional | TypeRegular | TypeMap | TypeBounced;
    type ascription = $type;
    type TypeId = $.Located<{
        readonly $: "TypeId";
        readonly name: string;
    }>;
    type asType = Id;
    type StatementLet = $.Located<{
        readonly $: "StatementLet";
        readonly name: Id;
        readonly type: ascription | undefined;
        readonly init: expression;
    }>;
    type StatementDestruct = $.Located<{
        readonly $: "StatementDestruct";
        readonly type: TypeId;
        readonly fields: inter<destructItem, ",">;
        readonly rest: optionalRest;
        readonly init: expression;
    }>;
    type StatementBlock = $.Located<{
        readonly $: "StatementBlock";
        readonly body: statements;
    }>;
    type StatementReturn = $.Located<{
        readonly $: "StatementReturn";
        readonly expression: expression | undefined;
    }>;
    type StatementCondition = $.Located<{
        readonly $: "StatementCondition";
        readonly condition: expression;
        readonly trueBranch: statements;
        readonly falseBranch: FalseBranch | StatementCondition | undefined;
    }>;
    type StatementWhile = $.Located<{
        readonly $: "StatementWhile";
        readonly condition: parens;
        readonly body: statements;
    }>;
    type StatementRepeat = $.Located<{
        readonly $: "StatementRepeat";
        readonly condition: parens;
        readonly body: statements;
    }>;
    type StatementUntil = $.Located<{
        readonly $: "StatementUntil";
        readonly body: statements;
        readonly condition: parens;
    }>;
    type StatementTry = $.Located<{
        readonly $: "StatementTry";
        readonly body: statements;
        readonly handler: {
            readonly name: Id;
            readonly body: statements;
        } | undefined;
    }>;
    type StatementForEach = $.Located<{
        readonly $: "StatementForEach";
        readonly key: Id;
        readonly value: Id;
        readonly expression: expression;
        readonly body: statements;
    }>;
    type StatementExpression = $.Located<{
        readonly $: "StatementExpression";
        readonly expression: expression;
    }>;
    type StatementAssign = $.Located<{
        readonly $: "StatementAssign";
        readonly left: expression;
        readonly operator: augmentedOp | undefined;
        readonly right: expression;
    }>;
    type statement = StatementLet | StatementDestruct | StatementBlock | StatementReturn | StatementCondition | StatementWhile | StatementRepeat | StatementUntil | StatementTry | StatementForEach | StatementExpression | StatementAssign;
    type statements = readonly statement[];
    type augmentedOp = "||" | "&&" | ">>" | "<<" | "-" | "+" | "*" | "/" | "%" | "|" | "&" | "^";
    type FalseBranch = $.Located<{
        readonly $: "FalseBranch";
        readonly body: statements;
    }>;
    type RegularField = $.Located<{
        readonly $: "RegularField";
        readonly fieldName: Id;
        readonly varName: Id;
    }>;
    type PunnedField = $.Located<{
        readonly $: "PunnedField";
        readonly name: Id;
    }>;
    type destructItem = RegularField | PunnedField;
    type RestArgument = $.Located<{
        readonly $: "RestArgument";
    }>;
    type NoRestArgument = $.Located<{
        readonly $: "NoRestArgument";
    }>;
    type optionalRest = RestArgument | NoRestArgument;
    type Conditional = $.Located<{
        readonly $: "Conditional";
        readonly head: or;
        readonly tail: {
            readonly thenBranch: or;
            readonly elseBranch: Conditional;
        } | undefined;
    }>;
    type expression = Conditional;
    type Binary<T, U> = $.Located<{
        readonly $: "Binary";
        readonly exprs: inter<T, Operator<U>>;
    }>;
    type Unary = $.Located<{
        readonly $: "Unary";
        readonly prefixes: readonly Operator<"-" | "+" | "!" | "~">[];
        readonly expression: Suffix;
    }>;
    type mul = Binary<Unary, "*" | "/" | "%">;
    type add = Binary<mul, "+" | "-">;
    type bitwiseShift = Binary<add, "<<" | ">>">;
    type compare = Binary<bitwiseShift, "<=" | "<" | ">=" | ">">;
    type equality = Binary<compare, "!=" | "==">;
    type bitwiseAnd = Binary<equality, "&">;
    type bitwiseXor = Binary<bitwiseAnd, "^">;
    type bitwiseOr = Binary<bitwiseXor, "|">;
    type and = Binary<bitwiseOr, "&&">;
    type or = Binary<and, "||">;
    type Suffix = $.Located<{
        readonly $: "Suffix";
        readonly expression: primary;
        readonly suffixes: readonly suffix[];
    }>;
    type Operator<U> = $.Located<{
        readonly $: "Operator";
        readonly name: U;
    }>;
    type SuffixUnboxNotNull = $.Located<{
        readonly $: "SuffixUnboxNotNull";
    }>;
    type SuffixCall = $.Located<{
        readonly $: "SuffixCall";
        readonly params: parameterList<expression>;
    }>;
    type SuffixFieldAccess = $.Located<{
        readonly $: "SuffixFieldAccess";
        readonly name: Id;
    }>;
    type suffix = SuffixUnboxNotNull | SuffixCall | SuffixFieldAccess;
    type Parens = $.Located<{
        readonly $: "Parens";
        readonly child: parens;
    }>;
    type StructInstance = $.Located<{
        readonly $: "StructInstance";
        readonly type: TypeId;
        readonly fields: commaList<StructFieldInitializer> | undefined;
    }>;
    type IntegerLiteral = $.Located<{
        readonly $: "IntegerLiteral";
        readonly value: IntegerLiteralHex | IntegerLiteralBin | IntegerLiteralOct | IntegerLiteralDec;
    }>;
    type BoolLiteral = $.Located<{
        readonly $: "BoolLiteral";
        readonly value: "true" | "false";
    }>;
    type InitOf = $.Located<{
        readonly $: "InitOf";
        readonly name: Id;
        readonly params: parameterList<expression>;
    }>;
    type Null = $.Located<{
        readonly $: "Null";
    }>;
    type primary = Parens | StructInstance | IntegerLiteral | BoolLiteral | InitOf | Null | StringLiteral | Id;
    type parens = expression;
    type StructFieldInitializer = $.Located<{
        readonly $: "StructFieldInitializer";
        readonly name: Id;
        readonly init: expression | undefined;
    }>;
    type parameterList<T> = commaList<T> | undefined;
    type IntegerLiteralHex = $.Located<{
        readonly $: "IntegerLiteralHex";
        readonly digits: underscored<hexDigit>;
    }>;
    type IntegerLiteralBin = $.Located<{
        readonly $: "IntegerLiteralBin";
        readonly digits: underscored<"0" | "1">;
    }>;
    type IntegerLiteralOct = $.Located<{
        readonly $: "IntegerLiteralOct";
        readonly digits: underscored<string>;
    }>;
    type underscored<T> = string;
    type digit = string;
    type idPart = string | string | string | "_";
    type FuncId = $.Located<{
        readonly $: "FuncId";
        readonly accessor: "." | "~" | undefined;
        readonly id: string;
    }>;
    type hexDigit = string | string | string;
    type escapeChar = "\\" | "\"" | "n" | "r" | "t" | "v" | "b" | "f" | string | string | string;
    type reservedWord = keyword<"extend" | "public" | "fun" | "let" | "return" | "receive" | "native" | "primitive" | "null" | "if" | "else" | "while" | "repeat" | "do" | "until" | "try" | "catch" | "foreach" | "as" | "map" | "mutates" | "extends" | "external" | "import" | "with" | "trait" | "initOf" | "override" | "abstract" | "virtual" | "inline" | "const">;
    type space = " " | "\t" | "\r" | "\n" | comment;
    type JustImports = $.Located<{
        readonly $: "JustImports";
        readonly imports: readonly Import[];
    }>;
}
export declare const Module: $.Parser<$ast.Module>;
export declare const Import: $.Parser<$ast.Import>;
export declare const PrimitiveTypeDecl: $.Parser<$ast.PrimitiveTypeDecl>;
export declare const $Function: $.Parser<$ast.$Function>;
export declare const AsmFunction: $.Parser<$ast.AsmFunction>;
export declare const NativeFunctionDecl: $.Parser<$ast.NativeFunctionDecl>;
export declare const Constant: $.Parser<$ast.Constant>;
export declare const StructDecl: $.Parser<$ast.StructDecl>;
export declare const MessageDecl: $.Parser<$ast.MessageDecl>;
export declare const Contract: $.Parser<$ast.Contract>;
export declare const Trait: $.Parser<$ast.Trait>;
export declare const moduleItem: $.Parser<$ast.moduleItem>;
export declare const ContractInit: $.Parser<$ast.ContractInit>;
export declare const Receiver: $.Parser<$ast.Receiver>;
export declare const FieldDecl: $.Parser<$ast.FieldDecl>;
export declare const semicolon: $.Parser<$ast.semicolon>;
export declare const storageVar: $.Parser<$ast.storageVar>;
export declare const contractItemDecl: $.Parser<$ast.contractItemDecl>;
export declare const traitItemDecl: $.Parser<$ast.traitItemDecl>;
export declare const FunctionDefinition: $.Parser<$ast.FunctionDefinition>;
export declare const FunctionDeclaration: $.Parser<$ast.FunctionDeclaration>;
export declare const Id: $.Parser<$ast.Id>;
export declare const IntegerLiteralDec: $.Parser<$ast.IntegerLiteralDec>;
export declare const shuffle: $.Parser<$ast.shuffle>;
export declare const ConstantAttribute: $.Parser<$ast.ConstantAttribute>;
export declare const ConstantDefinition: $.Parser<$ast.ConstantDefinition>;
export declare const ConstantDeclaration: $.Parser<$ast.ConstantDeclaration>;
export declare const inter: <A, B>(A: $.Parser<A>, B: $.Parser<B>) => $.Parser<$ast.inter<A, B>>;
export declare const structFields: $.Parser<$ast.structFields>;
export declare const keyword: <T>(T: $.Parser<T>) => $.Parser<$ast.keyword<T>>;
export declare const commaList: <T>(T: $.Parser<T>) => $.Parser<$ast.commaList<T>>;
export declare const inheritedTraits: $.Parser<$ast.inheritedTraits>;
export declare const ContractAttribute: $.Parser<$ast.ContractAttribute>;
export declare const FunctionAttribute: $.Parser<$ast.FunctionAttribute>;
export declare const GetAttribute: $.Parser<$ast.GetAttribute>;
export declare const receiverType: $.Parser<$ast.receiverType>;
export declare const Parameter: $.Parser<$ast.Parameter>;
export declare const StringLiteral: $.Parser<$ast.StringLiteral>;
export declare const receiverParam: $.Parser<$ast.receiverParam>;
export declare const assembly: $.Parser<$ast.assembly>;
export declare const multiLineComment: $.Parser<$ast.multiLineComment>;
export declare const singleLineComment: $.Parser<$ast.singleLineComment>;
export declare const comment: $.Parser<$ast.comment>;
export declare const assemblyItem: $.Parser<$ast.assemblyItem>;
export declare const assemblySequence: $.Parser<$ast.assemblySequence>;
export declare const TypeOptional: $.Parser<$ast.TypeOptional>;
export declare const TypeRegular: $.Parser<$ast.TypeRegular>;
export declare const TypeMap: $.Parser<$ast.TypeMap>;
export declare const TypeBounced: $.Parser<$ast.TypeBounced>;
export declare const $type: $.Parser<$ast.$type>;
export declare const ascription: $.Parser<$ast.ascription>;
export declare const TypeId: $.Parser<$ast.TypeId>;
export declare const asType: $.Parser<$ast.asType>;
export declare const StatementLet: $.Parser<$ast.StatementLet>;
export declare const StatementDestruct: $.Parser<$ast.StatementDestruct>;
export declare const StatementBlock: $.Parser<$ast.StatementBlock>;
export declare const StatementReturn: $.Parser<$ast.StatementReturn>;
export declare const StatementCondition: $.Parser<$ast.StatementCondition>;
export declare const StatementWhile: $.Parser<$ast.StatementWhile>;
export declare const StatementRepeat: $.Parser<$ast.StatementRepeat>;
export declare const StatementUntil: $.Parser<$ast.StatementUntil>;
export declare const StatementTry: $.Parser<$ast.StatementTry>;
export declare const StatementForEach: $.Parser<$ast.StatementForEach>;
export declare const StatementExpression: $.Parser<$ast.StatementExpression>;
export declare const StatementAssign: $.Parser<$ast.StatementAssign>;
export declare const statement: $.Parser<$ast.statement>;
export declare const statements: $.Parser<$ast.statements>;
export declare const augmentedOp: $.Parser<$ast.augmentedOp>;
export declare const FalseBranch: $.Parser<$ast.FalseBranch>;
export declare const RegularField: $.Parser<$ast.RegularField>;
export declare const PunnedField: $.Parser<$ast.PunnedField>;
export declare const destructItem: $.Parser<$ast.destructItem>;
export declare const RestArgument: $.Parser<$ast.RestArgument>;
export declare const NoRestArgument: $.Parser<$ast.NoRestArgument>;
export declare const optionalRest: $.Parser<$ast.optionalRest>;
export declare const Conditional: $.Parser<$ast.Conditional>;
export declare const expression: $.Parser<$ast.expression>;
export declare const Binary: <T, U>(T: $.Parser<T>, U: $.Parser<U>) => $.Parser<$ast.Binary<T, U>>;
export declare const Unary: $.Parser<$ast.Unary>;
export declare const mul: $.Parser<$ast.mul>;
export declare const add: $.Parser<$ast.add>;
export declare const bitwiseShift: $.Parser<$ast.bitwiseShift>;
export declare const compare: $.Parser<$ast.compare>;
export declare const equality: $.Parser<$ast.equality>;
export declare const bitwiseAnd: $.Parser<$ast.bitwiseAnd>;
export declare const bitwiseXor: $.Parser<$ast.bitwiseXor>;
export declare const bitwiseOr: $.Parser<$ast.bitwiseOr>;
export declare const and: $.Parser<$ast.and>;
export declare const or: $.Parser<$ast.or>;
export declare const Suffix: $.Parser<$ast.Suffix>;
export declare const Operator: <U>(U: $.Parser<U>) => $.Parser<$ast.Operator<U>>;
export declare const SuffixUnboxNotNull: $.Parser<$ast.SuffixUnboxNotNull>;
export declare const SuffixCall: $.Parser<$ast.SuffixCall>;
export declare const SuffixFieldAccess: $.Parser<$ast.SuffixFieldAccess>;
export declare const suffix: $.Parser<$ast.suffix>;
export declare const Parens: $.Parser<$ast.Parens>;
export declare const StructInstance: $.Parser<$ast.StructInstance>;
export declare const IntegerLiteral: $.Parser<$ast.IntegerLiteral>;
export declare const BoolLiteral: $.Parser<$ast.BoolLiteral>;
export declare const InitOf: $.Parser<$ast.InitOf>;
export declare const Null: $.Parser<$ast.Null>;
export declare const primary: $.Parser<$ast.primary>;
export declare const parens: $.Parser<$ast.parens>;
export declare const StructFieldInitializer: $.Parser<$ast.StructFieldInitializer>;
export declare const parameterList: <T>(T: $.Parser<T>) => $.Parser<$ast.parameterList<T>>;
export declare const IntegerLiteralHex: $.Parser<$ast.IntegerLiteralHex>;
export declare const IntegerLiteralBin: $.Parser<$ast.IntegerLiteralBin>;
export declare const IntegerLiteralOct: $.Parser<$ast.IntegerLiteralOct>;
export declare const underscored: <T>(T: $.Parser<T>) => $.Parser<$ast.underscored<T>>;
export declare const digit: $.Parser<$ast.digit>;
export declare const idPart: $.Parser<$ast.idPart>;
export declare const FuncId: $.Parser<$ast.FuncId>;
export declare const hexDigit: $.Parser<$ast.hexDigit>;
export declare const escapeChar: $.Parser<$ast.escapeChar>;
export declare const reservedWord: $.Parser<$ast.reservedWord>;
export declare const space: $.Parser<$ast.space>;
export declare const JustImports: $.Parser<$ast.JustImports>;

            };
/// <amd-module name="tact-compiler/grammar/parser-error.d.ts" /> 
 declare module "tact-compiler/grammar/parser-error.d.ts" {
                import { ErrorDisplay } from "../error/display";
export declare const syntaxErrorSchema: <T, U>(display: ErrorDisplay<T>, handle: (t: T) => U) => {
    constant: {
        duplicate: (attr: string) => U;
        notAbstract: () => U;
        tooAbstract: () => U;
    };
    function: {
        duplicate: (attr: string) => U;
        notAbstract: () => U;
        tooAbstract: () => U;
    };
    topLevelConstantWithAttribute: () => U;
    literalTooLong: () => U;
    extraneousComma: () => U;
    duplicateField: (name: string) => U;
    restShouldBeLast: () => U;
    importWithBackslash: () => U;
    reservedVarPrefix: (prefix: string) => U;
    notCallable: () => U;
    noBouncedWithoutArg: () => U;
    noBouncedWithString: () => U;
    noConstantDecl: () => U;
    noFunctionDecl: () => U;
    expected: (expects: ReadonlySet<string>) => U;
    invalidFuncId: () => U;
    reservedFuncId: () => U;
    numericFuncId: () => U;
    leadingZeroUnderscore: () => U;
};
export type SyntaxErrors<T> = ReturnType<typeof syntaxErrorSchema<unknown, T>>;

            };
/// <amd-module name="tact-compiler/grammar/prev/grammar.d.ts" /> 
 declare module "tact-compiler/grammar/prev/grammar.d.ts" {
                import { AstExpression, AstModule, AstImport, FactoryAst } from "../../ast/ast";
import { ItemOrigin } from "../src-info";
/**
 * @deprecated
 */
export declare const getParser: (ast: FactoryAst) => {
    parse: (src: string, path: string, origin: ItemOrigin) => AstModule;
    parseExpression: (sourceCode: string) => AstExpression;
    parseImports: (src: string, path: string, origin: ItemOrigin) => AstImport[];
};

            };
/// <amd-module name="tact-compiler/grammar/prev/grammar.ohm-bundle.d.ts" /> 
 declare module "tact-compiler/grammar/prev/grammar.ohm-bundle.d.ts" {
                // AUTOGENERATED FILE
// This file was generated from grammar.ohm by `ohm generateBundles`.

import {
  BaseActionDict,
  Grammar,
  IterationNode,
  Node,
  NonterminalNode,
  Semantics,
  TerminalNode
} from 'ohm-js';

export interface TactActionDict<T> extends BaseActionDict<T> {
  Module?: (this: NonterminalNode, arg0: IterationNode, arg1: IterationNode) => T;
  ModuleItem?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Import?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  JustImports?: (this: NonterminalNode, arg0: IterationNode, arg1: IterationNode) => T;
  PrimitiveTypeDecl?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  ModuleFunction?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AsmFunction?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: IterationNode, arg3: NonterminalNode, arg4: NonterminalNode, arg5: NonterminalNode, arg6: IterationNode, arg7: IterationNode, arg8: TerminalNode, arg9: IterationNode, arg10: TerminalNode) => T;
  ModuleConstant?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  NativeFunctionDecl?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: IterationNode, arg5: NonterminalNode, arg6: NonterminalNode, arg7: NonterminalNode, arg8: IterationNode, arg9: IterationNode, arg10: TerminalNode) => T;
  Type_optional?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode) => T;
  Type_regular?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Type_map?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: IterationNode, arg5: TerminalNode, arg6: NonterminalNode, arg7: IterationNode, arg8: IterationNode, arg9: TerminalNode) => T;
  Type_bounced?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  Type?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FieldDecl?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: IterationNode, arg5: IterationNode, arg6: IterationNode) => T;
  ConstantAttribute_virtual?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ConstantAttribute_override?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ConstantAttribute_abstract?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ConstantAttribute?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ConstantDefinition?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: NonterminalNode, arg5: TerminalNode, arg6: NonterminalNode, arg7: TerminalNode) => T;
  ConstantDeclaration?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: NonterminalNode, arg5: TerminalNode) => T;
  StructDecl_regular?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode, arg4: TerminalNode) => T;
  StructDecl_message?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: IterationNode, arg3: IterationNode, arg4: NonterminalNode, arg5: TerminalNode, arg6: NonterminalNode, arg7: TerminalNode) => T;
  StructDecl?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  StructField?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  StructFields?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  Contract?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: IterationNode, arg5: TerminalNode, arg6: IterationNode, arg7: TerminalNode) => T;
  ContractItemDecl?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Trait?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: IterationNode, arg5: TerminalNode, arg6: IterationNode, arg7: TerminalNode) => T;
  InheritedTraits?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  TraitItemDecl?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  StorageVar?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode) => T;
  ContractInit?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: IterationNode, arg4: TerminalNode) => T;
  ContractAttribute_interface?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  ContractAttribute?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FunctionAttribute_getter?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: IterationNode, arg3: IterationNode) => T;
  FunctionAttribute_mutates?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FunctionAttribute_extends?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FunctionAttribute_virtual?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FunctionAttribute_override?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FunctionAttribute_inline?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FunctionAttribute_abstract?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FunctionAttribute?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AsmShuffle?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: IterationNode, arg3: IterationNode, arg4: TerminalNode) => T;
  FunctionDefinition?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: IterationNode, arg5: IterationNode, arg6: TerminalNode, arg7: IterationNode, arg8: TerminalNode) => T;
  FunctionDeclaration?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: IterationNode, arg5: IterationNode, arg6: TerminalNode) => T;
  Parameters?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: TerminalNode) => T;
  Parameter?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Receiver_regular?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: IterationNode, arg3: TerminalNode, arg4: TerminalNode, arg5: IterationNode, arg6: TerminalNode) => T;
  Receiver_comment?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: TerminalNode, arg5: IterationNode, arg6: TerminalNode) => T;
  Receiver_bounced?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: TerminalNode, arg5: IterationNode, arg6: TerminalNode) => T;
  Receiver_externalRegular?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: IterationNode, arg3: TerminalNode, arg4: TerminalNode, arg5: IterationNode, arg6: TerminalNode) => T;
  Receiver_externalComment?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: TerminalNode, arg5: IterationNode, arg6: TerminalNode) => T;
  Receiver?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AsmInstruction_internal?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: TerminalNode, arg4: NonterminalNode) => T;
  AsmInstruction_list?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: TerminalNode, arg4: NonterminalNode) => T;
  AsmInstruction_listNoStateCheck?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: TerminalNode, arg4: NonterminalNode) => T;
  AsmInstruction_string?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode, arg3: NonterminalNode) => T;
  AsmInstruction_tick?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  AsmInstruction_char?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode) => T;
  AsmInstruction_hexLiteral?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: IterationNode, arg3: TerminalNode, arg4: NonterminalNode) => T;
  AsmInstruction_binLiteral?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode, arg3: NonterminalNode) => T;
  AsmInstruction_custom?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AsmInstruction?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  asmInstruction?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  asmWord?: (this: NonterminalNode, arg0: IterationNode) => T;
  Statement?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  StatementBlock?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  StatementLet?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode, arg4: TerminalNode, arg5: NonterminalNode, arg6: TerminalNode) => T;
  StatementReturn?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  StatementExpression?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode) => T;
  StatementAssign?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  StatementCondition_noElse?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: IterationNode, arg4: TerminalNode) => T;
  StatementCondition_withElse?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: IterationNode, arg4: TerminalNode, arg5: NonterminalNode, arg6: TerminalNode, arg7: IterationNode, arg8: TerminalNode) => T;
  StatementCondition_withElseIf?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: IterationNode, arg4: TerminalNode, arg5: NonterminalNode, arg6: NonterminalNode) => T;
  StatementCondition?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  StatementWhile?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: TerminalNode, arg5: IterationNode, arg6: TerminalNode) => T;
  StatementRepeat?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: TerminalNode, arg5: IterationNode, arg6: TerminalNode) => T;
  StatementUntil?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: IterationNode, arg3: TerminalNode, arg4: NonterminalNode, arg5: TerminalNode, arg6: NonterminalNode, arg7: TerminalNode, arg8: TerminalNode) => T;
  StatementTry_noCatch?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: IterationNode, arg3: TerminalNode) => T;
  StatementTry_withCatch?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: IterationNode, arg3: TerminalNode, arg4: NonterminalNode, arg5: TerminalNode, arg6: NonterminalNode, arg7: TerminalNode, arg8: TerminalNode, arg9: IterationNode, arg10: TerminalNode) => T;
  StatementTry?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  StatementForEach?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: NonterminalNode, arg5: TerminalNode, arg6: NonterminalNode, arg7: TerminalNode, arg8: TerminalNode, arg9: IterationNode, arg10: TerminalNode) => T;
  StatementDestruct?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode, arg4: NonterminalNode, arg5: TerminalNode, arg6: TerminalNode, arg7: NonterminalNode, arg8: TerminalNode) => T;
  EndOfIdentifiers_ignoreUnspecifiedFields?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  EndOfIdentifiers_regular?: (this: NonterminalNode, arg0: IterationNode) => T;
  EndOfIdentifiers?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  DestructItem_regular?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  DestructItem_punned?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  DestructItem?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Expression?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionConditional_ternary?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: NonterminalNode) => T;
  ExpressionConditional?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionOr_or?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionOr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionAnd_and?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionAnd?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionBitwiseOr_bitwiseOr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionBitwiseOr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionBitwiseXor_bitwiseXor?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionBitwiseXor?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionBitwiseAnd_bitwiseAnd?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionBitwiseAnd?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionEquality_not?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionEquality_eq?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionEquality?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionCompare_gt?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionCompare_gte?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionCompare_lt?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionCompare_lte?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionCompare?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionBitwiseShift_shl?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionBitwiseShift_shr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionBitwiseShift?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionAdd_add?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionAdd_sub?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionAdd?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionMul_mul?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionMul_div?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionMul_rem?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionMul?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionUnary_minus?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  ExpressionUnary_plus?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  ExpressionUnary_not?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  ExpressionUnary_bitwiseNot?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  ExpressionUnary?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionPostfix?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionUnboxNotNull?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode) => T;
  ExpressionFieldAccess?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionMethodCall?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: NonterminalNode) => T;
  ExpressionPrimary?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionParens?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  ExpressionStructInstance?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: TerminalNode) => T;
  ExpressionStaticCall?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  ExpressionInitOf?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  StructFieldInitializer_full?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  StructFieldInitializer_punned?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  StructFieldInitializer?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Arguments?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: TerminalNode) => T;
  typeId?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  typeIdPart?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  integerLiteral?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  integerLiteralDec_nonZeroIntegerLiteralDec?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode) => T;
  integerLiteralDec_integerLiteralWithLeadingZero?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode) => T;
  integerLiteralDec?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  integerLiteralHex?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode) => T;
  integerLiteralBin?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode) => T;
  integerLiteralOct?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode) => T;
  binDigit?: (this: NonterminalNode, arg0: TerminalNode) => T;
  octDigit?: (this: NonterminalNode, arg0: TerminalNode) => T;
  nonZeroDigit?: (this: NonterminalNode, arg0: TerminalNode) => T;
  letterAsciiLC?: (this: NonterminalNode, arg0: TerminalNode) => T;
  letterAsciiUC?: (this: NonterminalNode, arg0: TerminalNode) => T;
  letterAscii?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  letterDigitUnderscore?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  idStart?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  idPart?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  id?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  funcInvalidId_notUnderscore?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notArithOperator?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notComparisonOperator?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notBitwiseOperator?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notAssignOperator?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notDelimiter?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notControlKeyword?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notTypeKeyword?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notKeyword?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notDirective?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notDecimalNumber?: (this: NonterminalNode, arg0: IterationNode, arg1: IterationNode, arg2: TerminalNode) => T;
  funcInvalidId_notHexadecimalNumber?: (this: NonterminalNode, arg0: IterationNode, arg1: TerminalNode, arg2: IterationNode, arg3: TerminalNode) => T;
  funcInvalidId?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  funcPlainId?: (this: NonterminalNode, arg0: IterationNode) => T;
  funcQuotedId?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  funcId?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode) => T;
  boolLiteral?: (this: NonterminalNode, arg0: TerminalNode) => T;
  stringLiteral?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  nonQuoteOrBackslashChar?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  escapeSequence_backslash?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_doubleQuote?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_newline?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_carriageReturn?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_tab?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_verticalTab?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_backspace?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_formFeed?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_unicodeCodePoint?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode, arg4: IterationNode, arg5: IterationNode, arg6: IterationNode, arg7: TerminalNode) => T;
  escapeSequence_unicodeEscape?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: NonterminalNode) => T;
  escapeSequence_hexEscape?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  escapeSequence?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  keyword?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  contract?: (this: NonterminalNode, arg0: TerminalNode) => T;
  let?: (this: NonterminalNode, arg0: TerminalNode) => T;
  fun?: (this: NonterminalNode, arg0: TerminalNode) => T;
  return?: (this: NonterminalNode, arg0: TerminalNode) => T;
  receive?: (this: NonterminalNode, arg0: TerminalNode) => T;
  extend?: (this: NonterminalNode, arg0: TerminalNode) => T;
  external?: (this: NonterminalNode, arg0: TerminalNode) => T;
  native?: (this: NonterminalNode, arg0: TerminalNode) => T;
  primitive?: (this: NonterminalNode, arg0: TerminalNode) => T;
  public?: (this: NonterminalNode, arg0: TerminalNode) => T;
  null?: (this: NonterminalNode, arg0: TerminalNode) => T;
  if?: (this: NonterminalNode, arg0: TerminalNode) => T;
  else?: (this: NonterminalNode, arg0: TerminalNode) => T;
  while?: (this: NonterminalNode, arg0: TerminalNode) => T;
  repeat?: (this: NonterminalNode, arg0: TerminalNode) => T;
  do?: (this: NonterminalNode, arg0: TerminalNode) => T;
  until?: (this: NonterminalNode, arg0: TerminalNode) => T;
  try?: (this: NonterminalNode, arg0: TerminalNode) => T;
  catch?: (this: NonterminalNode, arg0: TerminalNode) => T;
  foreach?: (this: NonterminalNode, arg0: TerminalNode) => T;
  as?: (this: NonterminalNode, arg0: TerminalNode) => T;
  map?: (this: NonterminalNode, arg0: TerminalNode) => T;
  mutates?: (this: NonterminalNode, arg0: TerminalNode) => T;
  extends?: (this: NonterminalNode, arg0: TerminalNode) => T;
  import?: (this: NonterminalNode, arg0: TerminalNode) => T;
  with?: (this: NonterminalNode, arg0: TerminalNode) => T;
  trait?: (this: NonterminalNode, arg0: TerminalNode) => T;
  initOf?: (this: NonterminalNode, arg0: TerminalNode) => T;
  virtual?: (this: NonterminalNode, arg0: TerminalNode) => T;
  override?: (this: NonterminalNode, arg0: TerminalNode) => T;
  inline?: (this: NonterminalNode, arg0: TerminalNode) => T;
  const?: (this: NonterminalNode, arg0: TerminalNode) => T;
  abstract?: (this: NonterminalNode, arg0: TerminalNode) => T;
  reservedWord?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  whiteSpace?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  space?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  comment?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  lineTerminator?: (this: NonterminalNode, arg0: TerminalNode) => T;
  multiLineComment?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  singleLineComment?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode) => T;
}

export interface TactSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: TactActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: TactActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: TactActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: TactActionDict<T>): this;
}

export interface TactGrammar extends Grammar {
  createSemantics(): TactSemantics;
  extendSemantics(superSemantics: TactSemantics): TactSemantics;
}

declare const grammar: TactGrammar;
export default grammar;


            };
/// <amd-module name="tact-compiler/grammar/prev/parser-error.d.ts" /> 
 declare module "tact-compiler/grammar/prev/parser-error.d.ts" {
                import { MatchResult } from "ohm-js";
import { ErrorDisplay } from "../../error/display";
import { ItemOrigin, SrcInfo } from "../src-info";
/**
 * @deprecated
 */
export declare const parserErrorSchema: (display: ErrorDisplay<string>) => {
    generic: (matchResult: MatchResult, path: string, origin: ItemOrigin) => never;
    constant: {
        duplicate: (attr: string) => (source: SrcInfo) => never;
        notAbstract: () => (source: SrcInfo) => never;
        tooAbstract: () => (source: SrcInfo) => never;
    };
    function: {
        duplicate: (attr: string) => (source: SrcInfo) => never;
        notAbstract: () => (source: SrcInfo) => never;
        tooAbstract: () => (source: SrcInfo) => never;
    };
    topLevelConstantWithAttribute: () => (source: SrcInfo) => never;
    literalTooLong: () => (source: SrcInfo) => never;
    extraneousComma: () => (source: SrcInfo) => never;
    duplicateField: (name: string) => (source: SrcInfo) => never;
    restShouldBeLast: () => (source: SrcInfo) => never;
    importWithBackslash: () => (source: SrcInfo) => never;
    reservedVarPrefix: (prefix: string) => (source: SrcInfo) => never;
    notCallable: () => (source: SrcInfo) => never;
    noBouncedWithoutArg: () => (source: SrcInfo) => never;
    noBouncedWithString: () => (source: SrcInfo) => never;
    noConstantDecl: () => (source: SrcInfo) => never;
    noFunctionDecl: () => (source: SrcInfo) => never;
    expected: (expects: ReadonlySet<string>) => (source: SrcInfo) => never;
    invalidFuncId: () => (source: SrcInfo) => never;
    reservedFuncId: () => (source: SrcInfo) => never;
    numericFuncId: () => (source: SrcInfo) => never;
    leadingZeroUnderscore: () => (source: SrcInfo) => never;
};
/**
 * @deprecated
 */
export type ParserErrors = ReturnType<typeof parserErrorSchema>;

            };
/// <amd-module name="tact-compiler/grammar/prev/src-info.d.ts" /> 
 declare module "tact-compiler/grammar/prev/src-info.d.ts" {
                import { Interval } from "ohm-js";
import { ItemOrigin, SrcInfo } from "../src-info";
/**
 * @deprecated
 */
export declare const getSrcInfoFromOhm: ({ sourceString, startIdx, endIdx }: Interval, file: string | null, origin: ItemOrigin) => SrcInfo;

            };
/// <amd-module name="tact-compiler/grammar/src-info.d.ts" /> 
 declare module "tact-compiler/grammar/src-info.d.ts" {
                export type ItemOrigin = "stdlib" | "user";
type LineAndColumnInfo = {
    lineNum: number;
    colNum: number;
    toString(...ranges: number[][]): string;
};
type Interval = {
    contents: string;
    getLineAndColumnMessage(): string;
    getLineAndColumn(): LineAndColumnInfo;
    startIdx: number;
    endIdx: number;
};
declare const srcInfoSymbol: unique symbol;
export declare const isSrcInfo: (t: unknown) => t is SrcInfo;
export interface SrcInfo {
    file: string | null;
    contents: string;
    interval: Interval;
    origin: ItemOrigin;
    /**
     * Tag so that custom snapshot serializer can distinguish it
     */
    [srcInfoSymbol]: true;
    /**
     * toJSON method is provided, so that it's not serialized into snapshots
     */
    toJSON: () => object;
}
export declare const srcInfoEqual: (left: SrcInfo, right: SrcInfo) => boolean;
export declare const getSrcInfo: (sourceString: string, startIdx: number, endIdx: number, file: string | null, origin: ItemOrigin) => SrcInfo;
export declare const dummySrcInfo: SrcInfo;
export {};

            };
/// <amd-module name="tact-compiler/imports/parseImportPath.d.ts" /> 
 declare module "tact-compiler/imports/parseImportPath.d.ts" {
                export declare function parseImportPath(src: string): string[] | null;

            };
/// <amd-module name="tact-compiler/imports/resolveImports.d.ts" /> 
 declare module "tact-compiler/imports/resolveImports.d.ts" {
                import { ItemOrigin, Parser } from "../grammar";
import { VirtualFileSystem } from "../vfs/VirtualFileSystem";
export declare function resolveImports(args: {
    entrypoint: string;
    project: VirtualFileSystem;
    stdlib: VirtualFileSystem;
    parser: Parser;
}): {
    tact: {
        code: string;
        path: string;
        origin: ItemOrigin;
    }[];
    func: {
        code: string;
        path: string;
        origin: ItemOrigin;
    }[];
};

            };
/// <amd-module name="tact-compiler/imports/resolveLibrary.d.ts" /> 
 declare module "tact-compiler/imports/resolveLibrary.d.ts" {
                import { VirtualFileSystem } from "../vfs/VirtualFileSystem";
type ResolveLibraryArgs = {
    path: string;
    name: string;
    project: VirtualFileSystem;
    stdlib: VirtualFileSystem;
};
type ResolveLibraryResult = {
    ok: true;
    path: string;
    kind: "func" | "tact";
    source: "project" | "stdlib";
} | {
    ok: false;
};
export declare function resolveLibrary(args: ResolveLibraryArgs): ResolveLibraryResult;
export {};

            };
/// <amd-module name="tact-compiler/imports/stdlib.d.ts" /> 
 declare module "tact-compiler/imports/stdlib.d.ts" {
                declare const files: Record<string, string>;
export default files;

            };
/// <amd-module name="tact-compiler/node.d.ts" /> 
 declare module "tact-compiler/node.d.ts" {
                import { ConfigProject } from "./config/parseConfig";
type AdditionalCliOptions = {
    mode?: ConfigProject["mode"];
};
export declare function run(args: {
    fileName?: string;
    configPath?: string;
    projectNames?: string[];
    additionalCliOptions?: AdditionalCliOptions;
    suppressLog?: boolean;
}): Promise<{
    ok: boolean;
    error: Error[];
}>;
export { createNodeFileSystem } from "./vfs/createNodeFileSystem";
export { parseAndEvalExpression } from "./optimizer/interpreter";
export { showValue } from "./types/types";

            };
/// <amd-module name="tact-compiler/optimizer/algebraic.d.ts" /> 
 declare module "tact-compiler/optimizer/algebraic.d.ts" {
                import { AstExpression } from "../ast/ast";
import { ExpressionTransformer, Rule } from "./types";
export declare class AddZero extends Rule {
    private additiveOperators;
    applyRule(ast: AstExpression, { util }: ExpressionTransformer): AstExpression;
}
export declare class MultiplyZero extends Rule {
    applyRule(ast: AstExpression, { util }: ExpressionTransformer): AstExpression;
}
export declare class MultiplyOne extends Rule {
    applyRule(ast: AstExpression, _optimizer: ExpressionTransformer): AstExpression;
}
export declare class SubtractSelf extends Rule {
    applyRule(ast: AstExpression, { util }: ExpressionTransformer): AstExpression;
}
export declare class AddSelf extends Rule {
    applyRule(ast: AstExpression, { applyRules, util }: ExpressionTransformer): AstExpression;
}
export declare class OrTrue extends Rule {
    applyRule(ast: AstExpression, { util }: ExpressionTransformer): AstExpression;
}
export declare class AndFalse extends Rule {
    applyRule(ast: AstExpression, { util }: ExpressionTransformer): AstExpression;
}
export declare class OrFalse extends Rule {
    applyRule(ast: AstExpression, _optimizer: ExpressionTransformer): AstExpression;
}
export declare class AndTrue extends Rule {
    applyRule(ast: AstExpression, _optimizer: ExpressionTransformer): AstExpression;
}
export declare class OrSelf extends Rule {
    applyRule(ast: AstExpression, _optimizer: ExpressionTransformer): AstExpression;
}
export declare class AndSelf extends Rule {
    applyRule(ast: AstExpression, _optimizer: ExpressionTransformer): AstExpression;
}
export declare class ExcludedMiddle extends Rule {
    applyRule(ast: AstExpression, { util }: ExpressionTransformer): AstExpression;
}
export declare class Contradiction extends Rule {
    applyRule(ast: AstExpression, { util }: ExpressionTransformer): AstExpression;
}
export declare class DoubleNegation extends Rule {
    applyRule(ast: AstExpression, _optimizer: ExpressionTransformer): AstExpression;
}
export declare class NegateTrue extends Rule {
    applyRule(ast: AstExpression, { util }: ExpressionTransformer): AstExpression;
}
export declare class NegateFalse extends Rule {
    applyRule(ast: AstExpression, { util }: ExpressionTransformer): AstExpression;
}

            };
/// <amd-module name="tact-compiler/optimizer/associative.d.ts" /> 
 declare module "tact-compiler/optimizer/associative.d.ts" {
                import { SrcInfo } from "../grammar";
import { AstBinaryOperation, AstExpression, AstLiteral } from "../ast/ast";
import { ExpressionTransformer, Rule } from "./types";
import { AstUtil } from "./util";
type TransformData = {
    simplifiedExpression: AstExpression;
    safetyCondition: boolean;
};
type Transform = (x1: AstExpression, c1: AstLiteral, c2: AstLiteral, util: AstUtil, s: SrcInfo) => TransformData;
declare abstract class AssociativeRewriteRule extends Rule {
    private associativeOps;
    private commutativeOps;
    constructor();
    areAssociative(op1: AstBinaryOperation, op2: AstBinaryOperation): boolean;
    isCommutative(op: AstBinaryOperation): boolean;
}
declare abstract class AllowableOpRule extends AssociativeRewriteRule {
    private allowedOps;
    constructor();
    isAllowedOp(op: AstBinaryOperation): boolean;
    areAllowedOps(op: AstBinaryOperation[]): boolean;
}
export declare class AssociativeRule1 extends AllowableOpRule {
    applyRule(ast: AstExpression, { applyRules, util }: ExpressionTransformer): AstExpression;
}
export declare class AssociativeRule2 extends AllowableOpRule {
    applyRule(ast: AstExpression, { applyRules, util }: ExpressionTransformer): AstExpression;
}
export declare class AssociativeRule3 extends Rule {
    private leftAssocTransforms;
    private rightAssocTransforms;
    private rightCommuteTransforms;
    private leftCommuteTransforms;
    private standardAdditiveCondition;
    private shiftedAdditiveCondition;
    private oppositeAdditiveCondition;
    private standardMultiplicativeCondition;
    constructor();
    private lookupTransform;
    protected getLeftAssociativityTransform(keyOp1: AstBinaryOperation, keyOp2: AstBinaryOperation): Transform | undefined;
    protected getRightAssociativityTransform(keyOp1: AstBinaryOperation, keyOp2: AstBinaryOperation): Transform | undefined;
    protected getLeftCommutativityTransform(keyOp1: AstBinaryOperation, keyOp2: AstBinaryOperation): Transform | undefined;
    protected getRightCommutativityTransform(keyOp1: AstBinaryOperation, keyOp2: AstBinaryOperation): Transform | undefined;
    applyRule(ast: AstExpression, { applyRules, util }: ExpressionTransformer): AstExpression;
}
export {};

            };
/// <amd-module name="tact-compiler/optimizer/constEval.d.ts" /> 
 declare module "tact-compiler/optimizer/constEval.d.ts" {
                import { CompilerContext } from "../context/context";
import { AstBinaryOperation, AstExpression, AstUnaryOperation, AstLiteral } from "../ast/ast";
import { AstUtil } from "./util";
import { InterpreterConfig } from "./interpreter";
import { SrcInfo } from "../grammar";
export declare const getOptimizer: (util: AstUtil) => {
    partiallyEvalUnaryOp: (op: AstUnaryOperation, operand: AstExpression, source: SrcInfo, ctx: CompilerContext) => AstExpression;
    partiallyEvalBinaryOp: (op: AstBinaryOperation, left: AstExpression, right: AstExpression, source: SrcInfo, ctx: CompilerContext) => AstExpression;
    partiallyEvalExpression: (ast: AstExpression, ctx: CompilerContext, interpreterConfig?: InterpreterConfig) => AstExpression;
};
export declare function evalConstantExpression(ast: AstExpression, ctx: CompilerContext, util: AstUtil, interpreterConfig?: InterpreterConfig): AstLiteral;

            };
/// <amd-module name="tact-compiler/optimizer/interpreter.d.ts" /> 
 declare module "tact-compiler/optimizer/interpreter.d.ts" {
                import { CompilerContext } from "../context/context";
import { AstAddress, AstBinaryOperation, AstBoolean, AstCell, AstCommentValue, AstCondition, AstConditional, AstConstantDef, AstContract, AstExpression, AstFieldAccess, AstFunctionDef, AstId, AstInitOf, AstLiteral, AstMessageDecl, AstMethodCall, AstModuleItem, AstNativeFunctionDecl, AstNull, AstNumber, AstOpBinary, AstOpUnary, AstPrimitiveTypeDecl, AstSimplifiedString, AstSlice, FactoryAst, AstStatement, AstStatementAssign, AstStatementAugmentedAssign, AstStatementDestruct, AstStatementExpression, AstStatementForEach, AstStatementLet, AstStatementRepeat, AstStatementReturn, AstStatementTry, AstStatementTryCatch, AstStatementUntil, AstStatementWhile, AstStaticCall, AstString, AstStructDecl, AstStructInstance, AstStructValue, AstTrait, AstUnaryOperation, AstStatementBlock } from "../ast/ast";
import { AstUtil } from "./util";
import { Parser } from "../grammar/grammar";
import { SrcInfo } from "../grammar";
export declare function throwNonFatalErrorConstEval(msg: string, source: SrcInfo): never;
type EvalResult = {
    kind: "ok";
    value: AstLiteral;
} | {
    kind: "error";
    message: string;
};
export declare function ensureInt(val: AstExpression): AstNumber;
export declare function ensureBoolean(val: AstExpression): AstBoolean;
export declare function ensureString(val: AstExpression): AstString;
export declare function ensureSimplifiedString(val: AstExpression): AstSimplifiedString;
export declare function evalUnaryOp(op: AstUnaryOperation, valOperand: AstLiteral, source: SrcInfo, util: AstUtil): AstLiteral;
export declare function evalBinaryOp(op: AstBinaryOperation, valLeft: AstLiteral, valRightContinuation: () => AstLiteral, // It needs to be a continuation, because some binary operators short-circuit
source: SrcInfo, util: AstUtil): AstLiteral;
export declare function interpretEscapeSequences(stringLiteral: string, source: SrcInfo): string;
export type InterpreterConfig = {
    maxLoopIterations: bigint;
};
export declare function parseAndEvalExpression(sourceCode: string, ast?: FactoryAst, parser?: Parser, util?: AstUtil): EvalResult;
export declare class Interpreter {
    private envStack;
    private context;
    private config;
    private util;
    constructor(util: AstUtil, context?: CompilerContext, config?: InterpreterConfig);
    interpretModuleItem(ast: AstModuleItem): void;
    interpretConstantDef(ast: AstConstantDef): void;
    interpretFunctionDef(ast: AstFunctionDef): void;
    interpretStructDecl(ast: AstStructDecl): void;
    interpretMessageDecl(ast: AstMessageDecl): void;
    interpretPrimitiveTypeDecl(ast: AstPrimitiveTypeDecl): void;
    interpretFunctionDecl(ast: AstNativeFunctionDecl): void;
    interpretContract(ast: AstContract): void;
    interpretTrait(ast: AstTrait): void;
    interpretExpression(ast: AstExpression): AstLiteral;
    interpretName(ast: AstId): AstLiteral;
    interpretMethodCall(ast: AstMethodCall): AstLiteral;
    interpretInitOf(ast: AstInitOf): AstLiteral;
    interpretNull(ast: AstNull): AstNull;
    interpretBoolean(ast: AstBoolean): AstBoolean;
    interpretNumber(ast: AstNumber): AstNumber;
    interpretString(ast: AstString): AstSimplifiedString;
    interpretCommentValue(ast: AstCommentValue): AstCommentValue;
    interpretSimplifiedString(ast: AstSimplifiedString): AstSimplifiedString;
    interpretAddress(ast: AstAddress): AstAddress;
    interpretCell(ast: AstCell): AstCell;
    interpretSlice(ast: AstSlice): AstSlice;
    interpretUnaryOp(ast: AstOpUnary): AstLiteral;
    interpretBinaryOp(ast: AstOpBinary): AstLiteral;
    interpretConditional(ast: AstConditional): AstLiteral;
    interpretStructInstance(ast: AstStructInstance): AstStructValue;
    interpretStructValue(ast: AstStructValue): AstStructValue;
    interpretFieldAccess(ast: AstFieldAccess): AstLiteral;
    interpretStaticCall(ast: AstStaticCall): AstLiteral;
    private evalStaticFunction;
    interpretStatement(ast: AstStatement): void;
    interpretLetStatement(ast: AstStatementLet): void;
    interpretDestructStatement(ast: AstStatementDestruct): void;
    interpretAssignStatement(ast: AstStatementAssign): void;
    interpretAugmentedAssignStatement(ast: AstStatementAugmentedAssign): void;
    interpretConditionStatement(ast: AstCondition): void;
    interpretExpressionStatement(ast: AstStatementExpression): void;
    interpretForEachStatement(ast: AstStatementForEach): void;
    interpretRepeatStatement(ast: AstStatementRepeat): void;
    interpretReturnStatement(ast: AstStatementReturn): void;
    interpretTryStatement(ast: AstStatementTry): void;
    interpretTryCatchStatement(ast: AstStatementTryCatch): void;
    interpretUntilStatement(ast: AstStatementUntil): void;
    interpretWhileStatement(ast: AstStatementWhile): void;
    interpretBlockStatement(ast: AstStatementBlock): void;
}
export {};

            };
/// <amd-module name="tact-compiler/optimizer/standardOptimizer.d.ts" /> 
 declare module "tact-compiler/optimizer/standardOptimizer.d.ts" {
                import { AstExpression } from "../ast/ast";
import { ExpressionTransformer } from "./types";
import { AstUtil } from "./util";
export declare class StandardOptimizer implements ExpressionTransformer {
    util: AstUtil;
    private rules;
    constructor(util: AstUtil);
    applyRules: (ast: AstExpression) => AstExpression;
}

            };
/// <amd-module name="tact-compiler/optimizer/types.d.ts" /> 
 declare module "tact-compiler/optimizer/types.d.ts" {
                import { AstExpression } from "../ast/ast";
import { AstUtil } from "./util";
export interface ExpressionTransformer {
    util: AstUtil;
    applyRules(ast: AstExpression): AstExpression;
}
export declare abstract class Rule {
    abstract applyRule(ast: AstExpression, optimizer: ExpressionTransformer): AstExpression;
}

            };
/// <amd-module name="tact-compiler/optimizer/util.d.ts" /> 
 declare module "tact-compiler/optimizer/util.d.ts" {
                import { Address, Cell, Slice } from "@ijstech/ton-core";
import { AstExpression, AstUnaryOperation, AstBinaryOperation, AstNumber, AstBoolean, AstSimplifiedString, AstNull, AstCell, AstSlice, AstAddress, AstLiteral, AstStructValue, AstStructFieldValue, AstId, AstCommentValue, FactoryAst } from "../ast/ast";
import { SrcInfo } from "../grammar";
export declare const getAstUtil: ({ createNode }: FactoryAst) => {
    makeUnaryExpression: (op: AstUnaryOperation, operand: AstExpression) => AstExpression;
    makeBinaryExpression: (op: AstBinaryOperation, left: AstExpression, right: AstExpression) => AstExpression;
    makeNumberLiteral: (n: bigint, loc: SrcInfo) => AstNumber;
    makeBooleanLiteral: (b: boolean, loc: SrcInfo) => AstBoolean;
    makeSimplifiedStringLiteral: (s: string, loc: SrcInfo) => AstSimplifiedString;
    makeCommentLiteral: (s: string, loc: SrcInfo) => AstCommentValue;
    makeNullLiteral: (loc: SrcInfo) => AstNull;
    makeCellLiteral: (c: Cell, loc: SrcInfo) => AstCell;
    makeSliceLiteral: (s: Slice, loc: SrcInfo) => AstSlice;
    makeAddressLiteral: (a: Address, loc: SrcInfo) => AstAddress;
    makeStructFieldValue: (fieldName: string, val: AstLiteral, loc: SrcInfo) => AstStructFieldValue;
    makeStructValue: (fields: AstStructFieldValue[], type: AstId, loc: SrcInfo) => AstStructValue;
};
export type AstUtil = ReturnType<typeof getAstUtil>;
export declare function checkIsUnaryOpNode(ast: AstExpression): boolean;
export declare function checkIsBinaryOpNode(ast: AstExpression): boolean;
export declare function checkIsBinaryOp_With_RightValue(ast: AstExpression): boolean;
export declare function checkIsBinaryOp_With_LeftValue(ast: AstExpression): boolean;
export declare function checkIsNumber(ast: AstExpression, n: bigint): boolean;
export declare function checkIsName(ast: AstExpression): boolean;
export declare function checkIsBoolean(ast: AstExpression, b: boolean): boolean;
export declare function divFloor(a: bigint, b: bigint): bigint;
export declare function abs(a: bigint): bigint;
export declare function sign(a: bigint): bigint;
export declare function modFloor(a: bigint, b: bigint): bigint;

            };
/// <amd-module name="tact-compiler/packaging/fileFormat.d.ts" /> 
 declare module "tact-compiler/packaging/fileFormat.d.ts" {
                import { z } from "zod";
export declare const fileFormat: z.ZodObject<{
    name: z.ZodString;
    code: z.ZodString;
    abi: z.ZodString;
    init: z.ZodObject<{
        kind: z.ZodLiteral<"direct">;
        args: z.ZodArray<z.ZodObject<{
            name: z.ZodString;
            type: z.ZodUnion<[z.ZodObject<{
                kind: z.ZodLiteral<"simple">;
                type: z.ZodString;
                optional: z.ZodNullable<z.ZodOptional<z.ZodBoolean>>;
                format: z.ZodNullable<z.ZodOptional<z.ZodUnion<[z.ZodBoolean, z.ZodNumber, z.ZodString]>>>;
            }, "strip", z.ZodTypeAny, {
                type: string;
                kind: "simple";
                optional?: boolean | null | undefined;
                format?: string | number | boolean | null | undefined;
            }, {
                type: string;
                kind: "simple";
                optional?: boolean | null | undefined;
                format?: string | number | boolean | null | undefined;
            }>, z.ZodObject<{
                kind: z.ZodLiteral<"dict">;
                format: z.ZodNullable<z.ZodOptional<z.ZodUnion<[z.ZodBoolean, z.ZodNumber, z.ZodString]>>>;
                key: z.ZodString;
                keyFormat: z.ZodNullable<z.ZodOptional<z.ZodUnion<[z.ZodBoolean, z.ZodNumber, z.ZodString]>>>;
                value: z.ZodString;
                valueFormat: z.ZodNullable<z.ZodOptional<z.ZodUnion<[z.ZodBoolean, z.ZodNumber, z.ZodString]>>>;
            }, "strip", z.ZodTypeAny, {
                value: string;
                kind: "dict";
                key: string;
                format?: string | number | boolean | null | undefined;
                keyFormat?: string | number | boolean | null | undefined;
                valueFormat?: string | number | boolean | null | undefined;
            }, {
                value: string;
                kind: "dict";
                key: string;
                format?: string | number | boolean | null | undefined;
                keyFormat?: string | number | boolean | null | undefined;
                valueFormat?: string | number | boolean | null | undefined;
            }>]>;
        }, "strip", z.ZodTypeAny, {
            type: {
                type: string;
                kind: "simple";
                optional?: boolean | null | undefined;
                format?: string | number | boolean | null | undefined;
            } | {
                value: string;
                kind: "dict";
                key: string;
                format?: string | number | boolean | null | undefined;
                keyFormat?: string | number | boolean | null | undefined;
                valueFormat?: string | number | boolean | null | undefined;
            };
            name: string;
        }, {
            type: {
                type: string;
                kind: "simple";
                optional?: boolean | null | undefined;
                format?: string | number | boolean | null | undefined;
            } | {
                value: string;
                kind: "dict";
                key: string;
                format?: string | number | boolean | null | undefined;
                keyFormat?: string | number | boolean | null | undefined;
                valueFormat?: string | number | boolean | null | undefined;
            };
            name: string;
        }>, "many">;
        prefix: z.ZodOptional<z.ZodObject<{
            bits: z.ZodNumber;
            value: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            value: number;
            bits: number;
        }, {
            value: number;
            bits: number;
        }>>;
        deployment: z.ZodUnion<[z.ZodObject<{
            kind: z.ZodLiteral<"direct">;
        }, "strip", z.ZodTypeAny, {
            kind: "direct";
        }, {
            kind: "direct";
        }>, z.ZodObject<{
            kind: z.ZodLiteral<"system-cell">;
            system: z.ZodNullable<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            kind: "system-cell";
            system: string | null;
        }, {
            kind: "system-cell";
            system: string | null;
        }>]>;
    }, "strip", z.ZodTypeAny, {
        args: {
            type: {
                type: string;
                kind: "simple";
                optional?: boolean | null | undefined;
                format?: string | number | boolean | null | undefined;
            } | {
                value: string;
                kind: "dict";
                key: string;
                format?: string | number | boolean | null | undefined;
                keyFormat?: string | number | boolean | null | undefined;
                valueFormat?: string | number | boolean | null | undefined;
            };
            name: string;
        }[];
        kind: "direct";
        deployment: {
            kind: "direct";
        } | {
            kind: "system-cell";
            system: string | null;
        };
        prefix?: {
            value: number;
            bits: number;
        } | undefined;
    }, {
        args: {
            type: {
                type: string;
                kind: "simple";
                optional?: boolean | null | undefined;
                format?: string | number | boolean | null | undefined;
            } | {
                value: string;
                kind: "dict";
                key: string;
                format?: string | number | boolean | null | undefined;
                keyFormat?: string | number | boolean | null | undefined;
                valueFormat?: string | number | boolean | null | undefined;
            };
            name: string;
        }[];
        kind: "direct";
        deployment: {
            kind: "direct";
        } | {
            kind: "system-cell";
            system: string | null;
        };
        prefix?: {
            value: number;
            bits: number;
        } | undefined;
    }>;
    sources: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    compiler: z.ZodObject<{
        name: z.ZodString;
        version: z.ZodString;
        parameters: z.ZodNullable<z.ZodOptional<z.ZodString>>;
    }, "strip", z.ZodTypeAny, {
        name: string;
        version: string;
        parameters?: string | null | undefined;
    }, {
        name: string;
        version: string;
        parameters?: string | null | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    code: string;
    name: string;
    init: {
        args: {
            type: {
                type: string;
                kind: "simple";
                optional?: boolean | null | undefined;
                format?: string | number | boolean | null | undefined;
            } | {
                value: string;
                kind: "dict";
                key: string;
                format?: string | number | boolean | null | undefined;
                keyFormat?: string | number | boolean | null | undefined;
                valueFormat?: string | number | boolean | null | undefined;
            };
            name: string;
        }[];
        kind: "direct";
        deployment: {
            kind: "direct";
        } | {
            kind: "system-cell";
            system: string | null;
        };
        prefix?: {
            value: number;
            bits: number;
        } | undefined;
    };
    abi: string;
    compiler: {
        name: string;
        version: string;
        parameters?: string | null | undefined;
    };
    sources?: Record<string, string> | undefined;
}, {
    code: string;
    name: string;
    init: {
        args: {
            type: {
                type: string;
                kind: "simple";
                optional?: boolean | null | undefined;
                format?: string | number | boolean | null | undefined;
            } | {
                value: string;
                kind: "dict";
                key: string;
                format?: string | number | boolean | null | undefined;
                keyFormat?: string | number | boolean | null | undefined;
                valueFormat?: string | number | boolean | null | undefined;
            };
            name: string;
        }[];
        kind: "direct";
        deployment: {
            kind: "direct";
        } | {
            kind: "system-cell";
            system: string | null;
        };
        prefix?: {
            value: number;
            bits: number;
        } | undefined;
    };
    abi: string;
    compiler: {
        name: string;
        version: string;
        parameters?: string | null | undefined;
    };
    sources?: Record<string, string> | undefined;
}>;
export type PackageFileFormat = z.infer<typeof fileFormat>;

            };
/// <amd-module name="tact-compiler/packaging/packageCode.d.ts" /> 
 declare module "tact-compiler/packaging/packageCode.d.ts" {
                import { PackageFileFormat } from "./fileFormat";
export declare function packageCode(pkg: PackageFileFormat): string;

            };
/// <amd-module name="tact-compiler/pipeline/build.d.ts" /> 
 declare module "tact-compiler/pipeline/build.d.ts" {
                import { ConfigProject } from "../config/parseConfig";
import { CompilerContext } from "../context/context";
import { ILogger } from "../context/logger";
import { VirtualFileSystem } from "../vfs/VirtualFileSystem";
import { FactoryAst } from "../ast/ast";
import { TactErrorCollection } from "../error/errors";
import { Parser } from "../grammar";
export declare function enableFeatures(ctx: CompilerContext, logger: ILogger, config: ConfigProject): CompilerContext;
export declare function build(args: {
    config: ConfigProject;
    project: VirtualFileSystem;
    stdlib: string | VirtualFileSystem;
    logger?: ILogger;
    parser?: Parser;
    ast?: FactoryAst;
}): Promise<{
    ok: boolean;
    error: TactErrorCollection[];
}>;

            };
/// <amd-module name="tact-compiler/pipeline/compile.d.ts" /> 
 declare module "tact-compiler/pipeline/compile.d.ts" {
                import { CompilerContext } from "../context/context";
export declare function compile(ctx: CompilerContext, name: string, basename: string): Promise<{
    output: {
        entrypoint: string;
        files: {
            name: string;
            code: string;
        }[];
        abi: string;
    };
    ctx: CompilerContext;
}>;

            };
/// <amd-module name="tact-compiler/pipeline/precompile.d.ts" /> 
 declare module "tact-compiler/pipeline/precompile.d.ts" {
                import { CompilerContext } from "../context/context";
import { VirtualFileSystem } from "../vfs/VirtualFileSystem";
import { AstModule, FactoryAst } from "../ast/ast";
import { Parser } from "../grammar";
export declare function precompile(ctx: CompilerContext, project: VirtualFileSystem, stdlib: VirtualFileSystem, entrypoint: string, parser: Parser, ast: FactoryAst, parsedModules?: AstModule[]): CompilerContext;

            };
/// <amd-module name="tact-compiler/pipeline/version.d.ts" /> 
 declare module "tact-compiler/pipeline/version.d.ts" {
                export declare function __DANGER__disableVersionNumber(): void;
export declare function getCompilerVersion(): string;

            };
/// <amd-module name="tact-compiler/prettyPrinter.d.ts" /> 
 declare module "tact-compiler/prettyPrinter.d.ts" {
                import * as A from "./ast/ast";
export declare const ppAstTypeId: typeof A.idText;
export declare const ppAstTypeIdWithStorage: (type: A.AstTypeId, storageType: A.AstId | null) => string;
export declare const ppAstMapType: ({ keyType, keyStorageType, valueType, valueStorageType, }: A.AstMapType) => string;
export declare const ppAstBouncedMessageType: ({ messageType, }: A.AstBouncedMessageType) => string;
export declare const ppAstOptionalType: ({ typeArg }: A.AstOptionalType) => string;
export declare const ppAstType: (input: A.AstType) => string;
export declare const unaryOperatorType: Record<A.AstUnaryOperation, "post" | "pre">;
export declare const checkPostfix: (operator: A.AstUnaryOperation) => boolean;
/**
 * Description of precedence of certain type of AST node
 */
export type Precedence = {
    /**
     * Add parentheses around `code` if in this `parent` position we need brackets
     * @param check Position-checking function from parent
     * @param code Code to put parentheses around
     * @returns
     */
    brace: (position: (childPrecedence: number) => boolean, code: string) => string;
    /**
     * Used in positions where grammar rule mentions itself
     *
     * Passed down when a position allows same unparenthesized operator
     * For example, on left side of addition we can use another addition without
     * parentheses: `1 + 2 + 3` means `(1 + 2) + 3`. Thus for left-associative
     * operators we pass `self` to their left argument printer.
     */
    self: (childPrecedence: number) => boolean;
    /**
     * Used in positions where grammar rule mentions other rule
     *
     * Passed down when a position disallows same unparenthesized operator
     * For example, on the right side of subtraction we can't use another subtraction
     * without parentheses: `1 - (2 - 3)` is not the same as `(1 - 2) - 3`. Thus for
     * left-associative operators we pass `child` to their right argument printer.
     */
    child: (childPrecedence: number) => boolean;
};
/**
 * Given numeric value of precedence, where higher values stand for higher binding power,
 * create a helper object for precedence checking
 */
export declare const makePrecedence: (myPrecedence: number) => Precedence;
export declare const lowestPrecedence: Precedence;
export declare const conditionalPrecedence: Precedence;
export declare const binaryPrecedence: Readonly<Record<A.AstBinaryOperation, Precedence>>;
export declare const prefixPrecedence: Precedence;
export declare const postfixPrecedence: Precedence;
/**
 * Expression printer takes an expression and a function from parent AST node printer that checks
 * whether expressions with given precedence should be parenthesized in parent context
 */
export type ExprPrinter<T> = (expr: T) => (check: (childPrecedence: number) => boolean) => string;
/**
 * Wrapper for AST nodes that should never be parenthesized, and thus do not require information
 * about the position they're printed in
 *
 * Takes a regular printer function and returns corresponding ExprPrinter that ignores all
 * position and precedence information
 */
export declare const ppLeaf: <T>(printer: (t: T) => string) => ExprPrinter<T>;
export declare const ppExprArgs: (args: A.AstExpression[]) => string;
export declare const ppAstStructFieldInit: (param: A.AstStructFieldInitializer) => string;
export declare const ppAstStructFieldValue: (param: A.AstStructFieldValue) => string;
export declare const ppAstStructInstance: ({ type, args }: A.AstStructInstance) => string;
export declare const ppAstStructValue: ({ type, args }: A.AstStructValue) => string;
export declare const ppAstInitOf: ({ contract, args }: A.AstInitOf) => string;
export declare const ppAstNumber: typeof A.astNumToString;
export declare const ppAstBoolean: ({ value }: A.AstBoolean) => string;
export declare const ppAstId: ({ text }: A.AstId) => string;
export declare const ppAstNull: (_expr: A.AstNull) => string;
export declare const ppAstString: ({ value }: A.AstString) => string;
export declare const ppAstCommentValue: ({ value }: A.AstCommentValue) => string;
export declare const ppAstSimplifiedString: ({ value }: A.AstSimplifiedString) => string;
export declare const ppAstAddress: ({ value }: A.AstAddress) => string;
export declare const ppAstCell: ({ value }: A.AstCell) => string;
export declare const ppAstSlice: ({ value }: A.AstSlice) => string;
export declare const ppAstStaticCall: ({ function: func, args }: A.AstStaticCall) => string;
export declare const ppAstMethodCall: ExprPrinter<A.AstMethodCall>;
export declare const ppAstFieldAccess: ExprPrinter<A.AstFieldAccess>;
export declare const ppAstOpUnary: ExprPrinter<A.AstOpUnary>;
export declare const ppAstOpBinary: ExprPrinter<A.AstOpBinary>;
export declare const ppAstConditional: ExprPrinter<A.AstConditional>;
export declare const ppAstExpressionNested: (input: A.AstExpression) => (check: (childPrecedence: number) => boolean) => string;
export declare const ppAstExpression: (expr: A.AstExpression) => string;
/**
 * An intermediate language that is only concerned of spacing and indentation
 */
type Context<U> = {
    /**
     * Line of code with \n implied
     */
    row: (s: string) => U;
    /**
     * Stacks lines after each other
     */
    block: (rows: readonly U[]) => U;
    /**
     * Similar to `block`, but adjacent lines of groups get concatenated
     * [a, b] + [c, d] = [a, bc, d]
     */
    concat: (rows: readonly U[]) => U;
    /**
     * Same as `indent`, but indents `rows` 1 level deeper and adds `{` and `}`
     */
    braced: (rows: readonly U[]) => U;
    /**
     * Print a list of `items` with `print`
     */
    list: <T>(items: readonly T[], print: Printer<T>) => readonly U[];
    /**
     * Display `items` with `print` in groups distinguished by return value of `getTag`
     */
    grouped: <T, V>(options: {
        items: readonly T[];
        /**
         * Items with the same tag are displayed without extra empty line between them
         *
         * Use NaN for tag whenever items should always be displayed with empty line,
         * because NaN !== NaN
         */
        getTag: (t: T) => V;
        print: Printer<T>;
    }) => readonly U[];
};
/**
 * Prints AST node of type `T` into an intermediate language of row of type `U`
 *
 * We enforce `U` to be a generic argument so that no implementation can (ab)use
 * the fact it's a string and generate some indentation without resorting to
 * methods of `Context`.
 */
type Printer<T> = (item: T) => <U>(ctx: Context<U>) => U;
export declare const ppAstModule: Printer<A.AstModule>;
export declare const ppAstStruct: Printer<A.AstStructDecl>;
export declare const ppAstContract: Printer<A.AstContract>;
export declare const ppAstPrimitiveTypeDecl: Printer<A.AstPrimitiveTypeDecl>;
export declare const ppAstFunctionDef: Printer<A.AstFunctionDef>;
export declare const ppAsmShuffle: ({ args, ret }: A.AstAsmShuffle) => string;
export declare const ppAstAsmFunctionDef: Printer<A.AstAsmFunctionDef>;
export declare const ppAstNativeFunction: Printer<A.AstNativeFunctionDecl>;
export declare const ppAstTrait: Printer<A.AstTrait>;
export declare const ppAstConstant: Printer<A.AstConstantDef>;
export declare const ppAstMessage: Printer<A.AstMessageDecl>;
export declare const ppModuleItem: Printer<A.AstModuleItem>;
export declare const ppAstFieldDecl: Printer<A.AstFieldDecl>;
export declare const ppAstReceiver: Printer<A.AstReceiver>;
export declare const ppAstFunctionDecl: Printer<A.AstFunctionDecl>;
export declare const ppAstConstDecl: Printer<A.AstConstantDecl>;
export declare const ppTraitBody: Printer<A.AstTraitDeclaration>;
export declare const ppAstInitFunction: Printer<A.AstContractInit>;
export declare const ppContractBody: Printer<A.AstContractDeclaration>;
export declare const ppAstImport: Printer<A.AstImport>;
export declare const ppAstFunctionSignature: ({ name, attributes, return: retTy, params, }: A.AstFunctionDef | A.AstAsmFunctionDef | A.AstFunctionDecl) => string;
export declare const ppAstFunctionAttribute: (attr: A.AstFunctionAttribute) => string;
export declare const ppAstReceiverHeader: (input: A.AstReceiverKind) => string;
export declare const ppAstFuncId: (func: A.AstFuncId) => string;
export declare const ppStatementBlock: Printer<A.AstStatement[]>;
export declare const ppAsmInstructionsBlock: Printer<A.AstAsmInstruction[]>;
export declare const ppAstStatementLet: Printer<A.AstStatementLet>;
export declare const ppAstStatementReturn: Printer<A.AstStatementReturn>;
export declare const ppAstStatementExpression: Printer<A.AstStatementExpression>;
export declare const ppAstStatementAssign: Printer<A.AstStatementAssign>;
export declare const ppAstStatementAugmentedAssign: Printer<A.AstStatementAugmentedAssign>;
export declare const ppAstCondition: Printer<A.AstCondition>;
export declare const ppAstStatementWhile: Printer<A.AstStatementWhile>;
export declare const ppAstStatementRepeat: Printer<A.AstStatementRepeat>;
export declare const ppAstStatementUntil: Printer<A.AstStatementUntil>;
export declare const ppAstStatementForEach: Printer<A.AstStatementForEach>;
export declare const ppAstStatementTry: Printer<A.AstStatementTry>;
export declare const ppAstStatementTryCatch: Printer<A.AstStatementTryCatch>;
export declare const ppAstStatementDestruct: Printer<A.AstStatementDestruct>;
export declare const ppAstStatementBlock: Printer<A.AstStatementBlock>;
export declare const ppAstStatement: Printer<A.AstStatement>;
export declare const exprNode: <T>(exprPrinter: (expr: T) => string) => Printer<T>;
export declare const ppAstNode: Printer<A.AstNode>;
/**
 * Pretty-prints an AST node into a string representation.
 * @param node The AST node to format.
 * @returns A string that represents the formatted AST node.
 */
export declare const prettyPrint: (node: A.AstNode) => string;
export {};

            };
/// <amd-module name="tact-compiler/storage/allocator.d.ts" /> 
 declare module "tact-compiler/storage/allocator.d.ts" {
                import { ABITypeRef } from "@ijstech/ton-core";
import { AllocationCell, AllocationOperation, AllocationOperationType } from "./operation";
export declare function getAllocationOperationFromField(src: ABITypeRef, structLoader: (name: string) => {
    bits: number;
    refs: number;
}): AllocationOperationType;
export declare function allocate(type: {
    reserved: {
        bits: number;
        refs: number;
    };
    ops: AllocationOperation[];
}): AllocationCell;

            };
/// <amd-module name="tact-compiler/storage/operation.d.ts" /> 
 declare module "tact-compiler/storage/operation.d.ts" {
                import { ABITypeRef } from "@ijstech/ton-core";
export type AllocationCell = {
    ops: AllocationOperation[];
    size: {
        bits: number;
        refs: number;
    };
    next: AllocationCell | null;
};
export type AllocationOperation = {
    name: string;
    type: ABITypeRef;
    op: AllocationOperationType;
};
export type AllocationOperationType = {
    kind: "int" | "uint";
    bits: number;
    optional: boolean;
} | {
    kind: "boolean";
    optional: boolean;
} | {
    kind: "varint16" | "varint32" | "varuint16" | "varuint32";
    optional: boolean;
} | {
    kind: "address";
    optional: boolean;
} | {
    kind: "struct";
    type: string;
    ref: boolean;
    optional: boolean;
    size: {
        bits: number;
        refs: number;
    };
} | {
    kind: "cell";
    optional: boolean;
    format: "default" | "remainder";
} | {
    kind: "slice";
    optional: boolean;
    format: "default" | "remainder";
} | {
    kind: "builder";
    optional: boolean;
    format: "default" | "remainder";
} | {
    kind: "map";
} | {
    kind: "string";
    optional: boolean;
} | {
    kind: "fixed-bytes";
    bytes: number;
    optional: boolean;
};

            };
/// <amd-module name="tact-compiler/storage/resolveAllocation.d.ts" /> 
 declare module "tact-compiler/storage/resolveAllocation.d.ts" {
                import { CompilerContext } from "../context/context";
import { TypeDescription } from "../types/types";
import { StorageAllocation } from "./StorageAllocation";
export declare function getAllocation(ctx: CompilerContext, name: string): StorageAllocation;
export declare function getAllocations(ctx: CompilerContext): {
    allocation: StorageAllocation;
    type: TypeDescription;
}[];
export declare function getSortedTypes(ctx: CompilerContext): TypeDescription[];
export declare function resolveAllocations(ctx: CompilerContext): CompilerContext;

            };
/// <amd-module name="tact-compiler/storage/StorageAllocation.d.ts" /> 
 declare module "tact-compiler/storage/StorageAllocation.d.ts" {
                import { AllocationCell, AllocationOperation } from "./operation";
export type StorageAllocation = {
    ops: AllocationOperation[];
    header: {
        value: number;
        bits: number;
    } | null;
    size: {
        bits: number;
        refs: number;
    };
    root: AllocationCell;
};

            };
/// <amd-module name="tact-compiler/test/benchmarks/contracts/output/benchmark_functions_Functions.d.ts" /> 
 declare module "tact-compiler/test/benchmarks/contracts/output/benchmark_functions_Functions.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Add = {
    $$type: 'Add';
    value: bigint;
};
export declare function storeAdd(src: Add): (builder: Builder) => void;
export declare function loadAdd(slice: Slice): {
    $$type: "Add";
    value: bigint;
};
export type Sub = {
    $$type: 'Sub';
    value: bigint;
};
export declare function storeSub(src: Sub): (builder: Builder) => void;
export declare function loadSub(slice: Slice): {
    $$type: "Sub";
    value: bigint;
};
export type Functions$Data = {
    $$type: 'Functions$Data';
    value: bigint;
};
export declare function storeFunctions$Data(src: Functions$Data): (builder: Builder) => void;
export declare function loadFunctions$Data(slice: Slice): {
    $$type: "Functions$Data";
    value: bigint;
};
export declare const Functions_getterMapping: {
    [key: string]: string;
};
export declare class Functions implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Functions>;
    static fromAddress(address: Address): Functions;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Add | Sub): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/benchmarks/contracts/output/benchmark_functions_inline_Functions.d.ts" /> 
 declare module "tact-compiler/test/benchmarks/contracts/output/benchmark_functions_inline_Functions.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Add = {
    $$type: 'Add';
    value: bigint;
};
export declare function storeAdd(src: Add): (builder: Builder) => void;
export declare function loadAdd(slice: Slice): {
    $$type: "Add";
    value: bigint;
};
export type Sub = {
    $$type: 'Sub';
    value: bigint;
};
export declare function storeSub(src: Sub): (builder: Builder) => void;
export declare function loadSub(slice: Slice): {
    $$type: "Sub";
    value: bigint;
};
export type Functions$Data = {
    $$type: 'Functions$Data';
    value: bigint;
};
export declare function storeFunctions$Data(src: Functions$Data): (builder: Builder) => void;
export declare function loadFunctions$Data(slice: Slice): {
    $$type: "Functions$Data";
    value: bigint;
};
export declare const Functions_getterMapping: {
    [key: string]: string;
};
export declare class Functions implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Functions>;
    static fromAddress(address: Address): Functions;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Add | Sub): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_Bar.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_Bar.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const Bar_getterMapping: {
    [key: string]: string;
};
export declare class Bar implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Bar>;
    static fromAddress(address: Address): Bar;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_Example.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_Example.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const Example_getterMapping: {
    [key: string]: string;
};
export declare class Example implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Example>;
    static fromAddress(address: Address): Example;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Binary | Octal | Decimal | Hexadecimal): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_Issue74.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_Issue74.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const Issue74_getterMapping: {
    [key: string]: string;
};
export declare class Issue74 implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Issue74>;
    static fromAddress(address: Address): Issue74;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "send"): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_LargeContract.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_LargeContract.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const LargeContract_getterMapping: {
    [key: string]: string;
};
export declare class LargeContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<LargeContract>;
    static fromAddress(address: Address): LargeContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    getGetTest0(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest1(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest2(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest3(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest4(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest5(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest6(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest7(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest8(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest9(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest10(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest11(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest12(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest13(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest14(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest15(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest16(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest17(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest18(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest19(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest20(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest21(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest22(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest23(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest24(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest25(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest26(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest27(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest28(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest29(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest30(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest31(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest32(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest33(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest34(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest35(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest36(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest37(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest38(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest39(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest40(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest41(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest42(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest43(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest44(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest45(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest46(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest47(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest48(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest49(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest50(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest51(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest52(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest53(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest54(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest55(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest56(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest57(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest58(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest59(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest60(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest61(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest62(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest63(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest64(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest65(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest66(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest67(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest68(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest69(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest70(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest71(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest72(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest73(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest74(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest75(provider: ContractProvider, index: bigint): Promise<bigint | null>;
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_Maps.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_Maps.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const Maps_getterMapping: {
    [key: string]: string;
};
export declare class Maps implements Contract {
    static init(arg: Dictionary<bigint, boolean>): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(arg: Dictionary<bigint, boolean>): Promise<Maps>;
    static fromAddress(address: Address): Maps;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "set keys" | "delete keys" | "clear" | Replace | Deploy): Promise<void>;
    getOneItem(provider: ContractProvider, key: bigint): Promise<Address | null>;
    getItemCheck(provider: ContractProvider): Promise<string>;
    getAllItems(provider: ContractProvider): Promise<Dictionary<Address, TokenInfo>>;
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_MapUintBool.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_MapUintBool.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const MapUintBool_getterMapping: {
    [key: string]: string;
};
export declare class MapUintBool implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapUintBool>;
    static fromAddress(address: Address): MapUintBool;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_MutatingMethodOnNonLvalues.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_MutatingMethodOnNonLvalues.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const MutatingMethodOnNonLvalues_getterMapping: {
    [key: string]: string;
};
export declare class MutatingMethodOnNonLvalues implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MutatingMethodOnNonLvalues>;
    static fromAddress(address: Address): MutatingMethodOnNonLvalues;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "foo"): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_Test.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_Test.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const Test_getterMapping: {
    [key: string]: string;
};
export declare class Test implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Test>;
    static fromAddress(address: Address): Test;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "test"): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_TestContract.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_TestContract.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const TestContract_getterMapping: {
    [key: string]: string;
};
export declare class TestContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<TestContract>;
    static fromAddress(address: Address): TestContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    getTestEq(provider: ContractProvider, s: Dictionary<bigint, bigint>): Promise<boolean>;
    getTestNeq(provider: ContractProvider, s: Dictionary<bigint, bigint>): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_TestGlobalFunctionShadowing.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_TestGlobalFunctionShadowing.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const TestGlobalFunctionShadowing_getterMapping: {
    [key: string]: string;
};
export declare class TestGlobalFunctionShadowing implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<TestGlobalFunctionShadowing>;
    static fromAddress(address: Address): TestGlobalFunctionShadowing;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "foo"): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/compilation-failed/util.d.ts" /> 
 declare module "tact-compiler/test/compilation-failed/util.d.ts" {
                export declare function itShouldNotCompile(params: {
    testName: string;
    errorMessage: string;
}): void;

            };
/// <amd-module name="tact-compiler/test/contracts.build.d.ts" /> 
 declare module "tact-compiler/test/contracts.build.d.ts" {
                export {};

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/address_AddressTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/address_AddressTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type AddressTester$Data = {
    $$type: 'AddressTester$Data';
};
export declare function storeAddressTester$Data(src: AddressTester$Data): (builder: Builder) => void;
export declare function loadAddressTester$Data(slice: Slice): {
    $$type: "AddressTester$Data";
};
export declare const AddressTester_getterMapping: {
    [key: string]: string;
};
export declare class AddressTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<AddressTester>;
    static fromAddress(address: Address): AddressTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTest1(provider: ContractProvider): Promise<Address>;
    getTest2(provider: ContractProvider): Promise<Address>;
    getTest3(provider: ContractProvider): Promise<Address>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/allocation_Test.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/allocation_Test.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type SetCost = {
    $$type: 'SetCost';
    cost: bigint | null;
};
export declare function storeSetCost(src: SetCost): (builder: Builder) => void;
export declare function loadSetCost(slice: Slice): {
    $$type: "SetCost";
    cost: bigint | null;
};
export type Struct2 = {
    $$type: 'Struct2';
    c: string;
    d: string;
    e: string;
    f: string;
};
export declare function storeStruct2(src: Struct2): (builder: Builder) => void;
export declare function loadStruct2(slice: Slice): {
    $$type: "Struct2";
    c: string;
    d: string;
    e: string;
    f: string;
};
export type Test$Data = {
    $$type: 'Test$Data';
    owner: Address;
    seqno: bigint;
    a: bigint;
    b: bigint;
    struct2: Struct2;
    author3: Address | null;
    cost: bigint | null;
    address: Address | null;
    price: bigint | null;
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
    owner: Address;
    seqno: bigint;
    a: bigint;
    b: bigint;
    struct2: {
        $$type: "Struct2";
        c: string;
        d: string;
        e: string;
        f: string;
    };
    author3: Address | null;
    cost: bigint | null;
    address: Address | null;
    price: bigint | null;
};
export declare const Test_getterMapping: {
    [key: string]: string;
};
export declare class Test implements Contract {
    static init(owner: Address, struct2: Struct2): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(owner: Address, struct2: Struct2): Promise<Test>;
    static fromAddress(address: Address): Test;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: SetCost | Deploy): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/asm-functions_AsmFunctionsTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/asm-functions_AsmFunctionsTester.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type AsmFunctionsTester$Data = {
    $$type: 'AsmFunctionsTester$Data';
};
export declare function storeAsmFunctionsTester$Data(src: AsmFunctionsTester$Data): (builder: Builder) => void;
export declare function loadAsmFunctionsTester$Data(slice: Slice): {
    $$type: "AsmFunctionsTester$Data";
};
export type MapIntIntSlice = {
    $$type: 'MapIntIntSlice';
    val: Dictionary<bigint, bigint>;
    rem: Slice;
};
export declare function storeMapIntIntSlice(src: MapIntIntSlice): (builder: Builder) => void;
export declare function loadMapIntIntSlice(slice: Slice): {
    $$type: "MapIntIntSlice";
    val: Dictionary<bigint, bigint>;
    rem: Slice;
};
export type IntSlice = {
    $$type: 'IntSlice';
    val: bigint;
    rem: Slice;
};
export declare function storeIntSlice(src: IntSlice): (builder: Builder) => void;
export declare function loadIntSlice(slice: Slice): {
    $$type: "IntSlice";
    val: bigint;
    rem: Slice;
};
export type SliceInt = {
    $$type: 'SliceInt';
    rem: Slice;
    val: bigint;
};
export declare function storeSliceInt(src: SliceInt): (builder: Builder) => void;
export declare function loadSliceInt(slice: Slice): {
    $$type: "SliceInt";
    rem: Slice;
    val: bigint;
};
export type Two = {
    $$type: 'Two';
    a: bigint;
    b: bigint;
};
export declare function storeTwo(src: Two): (builder: Builder) => void;
export declare function loadTwo(slice: Slice): {
    $$type: "Two";
    a: bigint;
    b: bigint;
};
export type TwoInTwo = {
    $$type: 'TwoInTwo';
    a: Two;
    b: Two;
};
export declare function storeTwoInTwo(src: TwoInTwo): (builder: Builder) => void;
export declare function loadTwoInTwo(slice: Slice): {
    $$type: "TwoInTwo";
    a: {
        $$type: "Two";
        a: bigint;
        b: bigint;
    };
    b: {
        $$type: "Two";
        a: bigint;
        b: bigint;
    };
};
export declare const AsmFunctionsTester_getterMapping: {
    [key: string]: string;
};
export declare class AsmFunctionsTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<AsmFunctionsTester>;
    static fromAddress(address: Address): AsmFunctionsTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestAsmStoreDict(provider: ContractProvider): Promise<boolean>;
    getTestAsmLoadCoins(provider: ContractProvider): Promise<boolean>;
    getTestAsmLoadCoinsMut(provider: ContractProvider): Promise<boolean>;
    getTestAsmLoadCoinsMutRuntime(provider: ContractProvider, c: Cell): Promise<bigint>;
    getTestAsmLoadInt(provider: ContractProvider): Promise<boolean>;
    getTestAsmDebugStr(provider: ContractProvider): Promise<boolean>;
    getTestAsmCreateUseWord(provider: ContractProvider): Promise<boolean>;
    getTestAsmSecondToLast(provider: ContractProvider): Promise<boolean>;
    getTestAsmSecondToLastRuntime(provider: ContractProvider, s1: Two, s2: Two): Promise<bigint>;
    getTestAsmFirst(provider: ContractProvider): Promise<boolean>;
    getTestAsmFirstRuntime(provider: ContractProvider, s1: TwoInTwo, s2: TwoInTwo, s3: TwoInTwo): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/block-statements_Test.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/block-statements_Test.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export declare const Test_getterMapping: {
    [key: string]: string;
};
export declare class Test implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Test>;
    static fromAddress(address: Address): Test;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "test" | Deploy): Promise<void>;
    getA(provider: ContractProvider): Promise<bigint>;
    getB(provider: ContractProvider): Promise<bigint>;
    getC(provider: ContractProvider): Promise<bigint>;
    getD(provider: ContractProvider): Promise<bigint>;
    getE(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/bounced-routing_SampleContract.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/bounced-routing_SampleContract.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type EntryFirst = {
    $$type: 'EntryFirst';
    amountToAdd: bigint;
    toAddress: Address;
};
export declare function storeEntryFirst(src: EntryFirst): (builder: Builder) => void;
export declare function loadEntryFirst(slice: Slice): {
    $$type: "EntryFirst";
    amountToAdd: bigint;
    toAddress: Address;
};
export type EntrySecond = {
    $$type: 'EntrySecond';
    amountToAdd: bigint;
    toAddress: Address;
};
export declare function storeEntrySecond(src: EntrySecond): (builder: Builder) => void;
export declare function loadEntrySecond(slice: Slice): {
    $$type: "EntrySecond";
    amountToAdd: bigint;
    toAddress: Address;
};
export type First = {
    $$type: 'First';
    amount: bigint;
    myCoins: bigint;
    myBool3: boolean;
    anAddress: Address;
};
export declare function storeFirst(src: First): (builder: Builder) => void;
export declare function loadFirst(slice: Slice): {
    $$type: "First";
    amount: bigint;
    myCoins: bigint;
    myBool3: boolean;
    anAddress: Address;
};
export type Second = {
    $$type: 'Second';
    amount_bigger: bigint;
    myBool: boolean;
    thisDoesNotFit: bigint;
    myAddress: Address;
    myBool2: boolean;
    myStruct: MyStruct;
    myStruct2: MyStruct;
};
export declare function storeSecond(src: Second): (builder: Builder) => void;
export declare function loadSecond(slice: Slice): {
    $$type: "Second";
    amount_bigger: bigint;
    myBool: boolean;
    thisDoesNotFit: bigint;
    myAddress: Address;
    myBool2: boolean;
    myStruct: {
        $$type: "MyStruct";
        amount: bigint;
    };
    myStruct2: {
        $$type: "MyStruct";
        amount: bigint;
    };
};
export type Large = {
    $$type: 'Large';
    address: Address;
    value: bigint;
};
export declare function storeLarge(src: Large): (builder: Builder) => void;
export declare function loadLarge(slice: Slice): {
    $$type: "Large";
    address: Address;
    value: bigint;
};
export type SmallBounce = {
    $$type: 'SmallBounce';
    amount: bigint;
    myBool3: boolean;
};
export declare function storeSmallBounce(src: SmallBounce): (builder: Builder) => void;
export declare function loadSmallBounce(slice: Slice): {
    $$type: "SmallBounce";
    amount: bigint;
    myBool3: boolean;
};
export type MyStruct = {
    $$type: 'MyStruct';
    amount: bigint;
};
export declare function storeMyStruct(src: MyStruct): (builder: Builder) => void;
export declare function loadMyStruct(slice: Slice): {
    $$type: "MyStruct";
    amount: bigint;
};
export type SampleContract$Data = {
    $$type: 'SampleContract$Data';
    a: bigint;
};
export declare function storeSampleContract$Data(src: SampleContract$Data): (builder: Builder) => void;
export declare function loadSampleContract$Data(slice: Slice): {
    $$type: "SampleContract$Data";
    a: bigint;
};
export type SampleContract2$Data = {
    $$type: 'SampleContract2$Data';
};
export declare function storeSampleContract2$Data(src: SampleContract2$Data): (builder: Builder) => void;
export declare function loadSampleContract2$Data(slice: Slice): {
    $$type: "SampleContract2$Data";
};
export declare const SampleContract_getterMapping: {
    [key: string]: string;
};
export declare class SampleContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<SampleContract>;
    static fromAddress(address: Address): SampleContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | EntryFirst | EntrySecond | First | Second | "Increment"): Promise<void>;
    getAmount(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/bounced-routing_SampleContract2.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/bounced-routing_SampleContract2.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type EntryFirst = {
    $$type: 'EntryFirst';
    amountToAdd: bigint;
    toAddress: Address;
};
export declare function storeEntryFirst(src: EntryFirst): (builder: Builder) => void;
export declare function loadEntryFirst(slice: Slice): {
    $$type: "EntryFirst";
    amountToAdd: bigint;
    toAddress: Address;
};
export type EntrySecond = {
    $$type: 'EntrySecond';
    amountToAdd: bigint;
    toAddress: Address;
};
export declare function storeEntrySecond(src: EntrySecond): (builder: Builder) => void;
export declare function loadEntrySecond(slice: Slice): {
    $$type: "EntrySecond";
    amountToAdd: bigint;
    toAddress: Address;
};
export type First = {
    $$type: 'First';
    amount: bigint;
    myCoins: bigint;
    myBool3: boolean;
    anAddress: Address;
};
export declare function storeFirst(src: First): (builder: Builder) => void;
export declare function loadFirst(slice: Slice): {
    $$type: "First";
    amount: bigint;
    myCoins: bigint;
    myBool3: boolean;
    anAddress: Address;
};
export type Second = {
    $$type: 'Second';
    amount_bigger: bigint;
    myBool: boolean;
    thisDoesNotFit: bigint;
    myAddress: Address;
    myBool2: boolean;
    myStruct: MyStruct;
    myStruct2: MyStruct;
};
export declare function storeSecond(src: Second): (builder: Builder) => void;
export declare function loadSecond(slice: Slice): {
    $$type: "Second";
    amount_bigger: bigint;
    myBool: boolean;
    thisDoesNotFit: bigint;
    myAddress: Address;
    myBool2: boolean;
    myStruct: {
        $$type: "MyStruct";
        amount: bigint;
    };
    myStruct2: {
        $$type: "MyStruct";
        amount: bigint;
    };
};
export type Large = {
    $$type: 'Large';
    address: Address;
    value: bigint;
};
export declare function storeLarge(src: Large): (builder: Builder) => void;
export declare function loadLarge(slice: Slice): {
    $$type: "Large";
    address: Address;
    value: bigint;
};
export type SmallBounce = {
    $$type: 'SmallBounce';
    amount: bigint;
    myBool3: boolean;
};
export declare function storeSmallBounce(src: SmallBounce): (builder: Builder) => void;
export declare function loadSmallBounce(slice: Slice): {
    $$type: "SmallBounce";
    amount: bigint;
    myBool3: boolean;
};
export type MyStruct = {
    $$type: 'MyStruct';
    amount: bigint;
};
export declare function storeMyStruct(src: MyStruct): (builder: Builder) => void;
export declare function loadMyStruct(slice: Slice): {
    $$type: "MyStruct";
    amount: bigint;
};
export type SampleContract$Data = {
    $$type: 'SampleContract$Data';
    a: bigint;
};
export declare function storeSampleContract$Data(src: SampleContract$Data): (builder: Builder) => void;
export declare function loadSampleContract$Data(slice: Slice): {
    $$type: "SampleContract$Data";
    a: bigint;
};
export type SampleContract2$Data = {
    $$type: 'SampleContract2$Data';
};
export declare function storeSampleContract2$Data(src: SampleContract2$Data): (builder: Builder) => void;
export declare function loadSampleContract2$Data(slice: Slice): {
    $$type: "SampleContract2$Data";
};
export declare const SampleContract2_getterMapping: {
    [key: string]: string;
};
export declare class SampleContract2 implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<SampleContract2>;
    static fromAddress(address: Address): SampleContract2;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | First | Second): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/constants_ConstantTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/constants_ConstantTester.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type S = {
    $$type: 'S';
    a: boolean;
    b: bigint;
};
export declare function storeS(src: S): (builder: Builder) => void;
export declare function loadS(slice: Slice): {
    $$type: "S";
    a: boolean;
    b: bigint;
};
export type T = {
    $$type: 'T';
    a: bigint;
    s: S;
};
export declare function storeT(src: T): (builder: Builder) => void;
export declare function loadT(slice: Slice): {
    $$type: "T";
    a: bigint;
    s: {
        $$type: "S";
        a: boolean;
        b: bigint;
    };
};
export type ConstantTester$Data = {
    $$type: 'ConstantTester$Data';
};
export declare function storeConstantTester$Data(src: ConstantTester$Data): (builder: Builder) => void;
export declare function loadConstantTester$Data(slice: Slice): {
    $$type: "ConstantTester$Data";
};
export declare const ConstantTester_getterMapping: {
    [key: string]: string;
};
export declare class ConstantTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<ConstantTester>;
    static fromAddress(address: Address): ConstantTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getSomething1(provider: ContractProvider): Promise<bigint>;
    getSomething2(provider: ContractProvider): Promise<bigint | null>;
    getSomething3(provider: ContractProvider): Promise<bigint>;
    getSomething4(provider: ContractProvider): Promise<bigint>;
    getSomething5(provider: ContractProvider): Promise<string>;
    getSomething6(provider: ContractProvider): Promise<bigint>;
    getSomething7(provider: ContractProvider): Promise<bigint>;
    getSomething8(provider: ContractProvider): Promise<bigint>;
    getSomething9(provider: ContractProvider): Promise<Address>;
    getSomething10(provider: ContractProvider): Promise<Address>;
    getSomething11(provider: ContractProvider): Promise<bigint>;
    getSomething12(provider: ContractProvider): Promise<bigint>;
    getSomething13(provider: ContractProvider): Promise<bigint>;
    getSomething14(provider: ContractProvider): Promise<bigint>;
    getSomething15(provider: ContractProvider): Promise<bigint>;
    getSomething16(provider: ContractProvider): Promise<bigint>;
    getSomething17(provider: ContractProvider): Promise<bigint>;
    getSomething18(provider: ContractProvider): Promise<bigint>;
    getSomething19(provider: ContractProvider): Promise<bigint>;
    getSomething20(provider: ContractProvider): Promise<bigint>;
    getSomething21(provider: ContractProvider): Promise<bigint>;
    getSomething22(provider: ContractProvider): Promise<bigint>;
    getSomething23(provider: ContractProvider): Promise<bigint>;
    getSomething24(provider: ContractProvider): Promise<bigint>;
    getSomething25(provider: ContractProvider): Promise<bigint>;
    getSomething26(provider: ContractProvider): Promise<bigint>;
    getSomething27(provider: ContractProvider): Promise<bigint>;
    getSomething28(provider: ContractProvider): Promise<bigint>;
    getSomething29(provider: ContractProvider): Promise<bigint | null>;
    getSomething30(provider: ContractProvider): Promise<bigint | null>;
    getSomething31(provider: ContractProvider): Promise<bigint>;
    getSomething32(provider: ContractProvider): Promise<bigint>;
    getSomething33(provider: ContractProvider): Promise<Dictionary<bigint, bigint>>;
    getSomething34(provider: ContractProvider): Promise<Dictionary<bigint, bigint>>;
    getSomething35(provider: ContractProvider): Promise<{
        $$type: "S";
        a: boolean;
        b: bigint;
    }>;
    getSomething36(provider: ContractProvider): Promise<{
        $$type: "S";
        a: boolean;
        b: bigint;
    }>;
    getSomething37(provider: ContractProvider): Promise<{
        $$type: "T";
        a: bigint;
        s: {
            $$type: "S";
            a: boolean;
            b: bigint;
        };
    }>;
    getSomething38(provider: ContractProvider): Promise<bigint>;
    getSomething39(provider: ContractProvider): Promise<boolean>;
    getSomething40(provider: ContractProvider): Promise<boolean>;
    getSomething41(provider: ContractProvider): Promise<Address>;
    getSomething42(provider: ContractProvider): Promise<Address>;
    getSomething43(provider: ContractProvider): Promise<Address>;
    getSomething44(provider: ContractProvider): Promise<Address>;
    getGlobalConst1(provider: ContractProvider): Promise<bigint>;
    getGlobalConst2(provider: ContractProvider): Promise<bigint>;
    getGlobalConst3(provider: ContractProvider): Promise<bigint>;
    getGlobalConst4(provider: ContractProvider): Promise<bigint>;
    getGlobalConst5(provider: ContractProvider): Promise<bigint>;
    getGlobalConst6(provider: ContractProvider): Promise<bigint>;
    getGlobalConst7(provider: ContractProvider): Promise<bigint>;
    getGlobalConst8(provider: ContractProvider): Promise<bigint>;
    getGlobalConst9(provider: ContractProvider): Promise<bigint>;
    getGlobalConst10(provider: ContractProvider): Promise<bigint>;
    getGlobalConst11(provider: ContractProvider): Promise<bigint>;
    getGlobalConst12(provider: ContractProvider): Promise<bigint>;
    getGlobalConst13(provider: ContractProvider): Promise<bigint>;
    getMinInt1(provider: ContractProvider): Promise<bigint>;
    getMinInt2(provider: ContractProvider): Promise<bigint>;
    getMinInt3(provider: ContractProvider): Promise<bigint>;
    getGlobalConst(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/contract-methods_Test.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/contract-methods_Test.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
    flags: bigint;
    oneMoreVar: bigint;
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
    flags: bigint;
    oneMoreVar: bigint;
};
export declare const Test_getterMapping: {
    [key: string]: string;
};
export declare class Test implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Test>;
    static fromAddress(address: Address): Test;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/debug_Debug.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/debug_Debug.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type Debug$Data = {
    $$type: 'Debug$Data';
};
export declare function storeDebug$Data(src: Debug$Data): (builder: Builder) => void;
export declare function loadDebug$Data(slice: Slice): {
    $$type: "Debug$Data";
};
export declare const Debug_getterMapping: {
    [key: string]: string;
};
export declare class Debug implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Debug>;
    static fromAddress(address: Address): Debug;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "Debug" | Deploy): Promise<void>;
    getDebug(provider: ContractProvider): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/deep_A.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/deep_A.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type A$Data = {
    $$type: 'A$Data';
};
export declare function storeA$Data(src: A$Data): (builder: Builder) => void;
export declare function loadA$Data(slice: Slice): {
    $$type: "A$Data";
};
export type B$Data = {
    $$type: 'B$Data';
    parent: Address;
};
export declare function storeB$Data(src: B$Data): (builder: Builder) => void;
export declare function loadB$Data(slice: Slice): {
    $$type: "B$Data";
    parent: Address;
};
export type C$Data = {
    $$type: 'C$Data';
    parent: Address;
};
export declare function storeC$Data(src: C$Data): (builder: Builder) => void;
export declare function loadC$Data(slice: Slice): {
    $$type: "C$Data";
    parent: Address;
};
export declare const A_getterMapping: {
    [key: string]: string;
};
export declare class A implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<A>;
    static fromAddress(address: Address): A;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "Message"): Promise<void>;
    getGetNext(provider: ContractProvider): Promise<{
        $$type: "StateInit";
        code: Cell;
        data: Cell;
    }>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/deep_B.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/deep_B.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type A$Data = {
    $$type: 'A$Data';
};
export declare function storeA$Data(src: A$Data): (builder: Builder) => void;
export declare function loadA$Data(slice: Slice): {
    $$type: "A$Data";
};
export type B$Data = {
    $$type: 'B$Data';
    parent: Address;
};
export declare function storeB$Data(src: B$Data): (builder: Builder) => void;
export declare function loadB$Data(slice: Slice): {
    $$type: "B$Data";
    parent: Address;
};
export type C$Data = {
    $$type: 'C$Data';
    parent: Address;
};
export declare function storeC$Data(src: C$Data): (builder: Builder) => void;
export declare function loadC$Data(slice: Slice): {
    $$type: "C$Data";
    parent: Address;
};
export declare const B_getterMapping: {
    [key: string]: string;
};
export declare class B implements Contract {
    static init(parent: Address): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(parent: Address): Promise<B>;
    static fromAddress(address: Address): B;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "Message"): Promise<void>;
    getGetNext(provider: ContractProvider): Promise<{
        $$type: "StateInit";
        code: Cell;
        data: Cell;
    }>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/deep_C.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/deep_C.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type A$Data = {
    $$type: 'A$Data';
};
export declare function storeA$Data(src: A$Data): (builder: Builder) => void;
export declare function loadA$Data(slice: Slice): {
    $$type: "A$Data";
};
export type B$Data = {
    $$type: 'B$Data';
    parent: Address;
};
export declare function storeB$Data(src: B$Data): (builder: Builder) => void;
export declare function loadB$Data(slice: Slice): {
    $$type: "B$Data";
    parent: Address;
};
export type C$Data = {
    $$type: 'C$Data';
    parent: Address;
};
export declare function storeC$Data(src: C$Data): (builder: Builder) => void;
export declare function loadC$Data(slice: Slice): {
    $$type: "C$Data";
    parent: Address;
};
export declare const C_getterMapping: {
    [key: string]: string;
};
export declare class C implements Contract {
    static init(parent: Address): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(parent: Address): Promise<C>;
    static fromAddress(address: Address): C;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "Message" | "Message2"): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/dns_DNSTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/dns_DNSTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type DNSResolveResult = {
    $$type: 'DNSResolveResult';
    prefix: bigint;
    record: Cell | null;
};
export declare function storeDNSResolveResult(src: DNSResolveResult): (builder: Builder) => void;
export declare function loadDNSResolveResult(slice: Slice): {
    $$type: "DNSResolveResult";
    prefix: bigint;
    record: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type DNSTester$Data = {
    $$type: 'DNSTester$Data';
    tmpC: Cell;
};
export declare function storeDNSTester$Data(src: DNSTester$Data): (builder: Builder) => void;
export declare function loadDNSTester$Data(slice: Slice): {
    $$type: "DNSTester$Data";
    tmpC: Cell;
};
export declare const DNSTester_getterMapping: {
    [key: string]: string;
};
export declare class DNSTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<DNSTester>;
    static fromAddress(address: Address): DNSTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "test dnsInternalNormalize throws" | Deploy): Promise<void>;
    getStringToInternal(provider: ContractProvider, src: string): Promise<Slice | null>;
    getInternalNormalize(provider: ContractProvider, src: Slice): Promise<Slice>;
    getDnsInternalVerify(provider: ContractProvider, subdomain: Slice): Promise<boolean>;
    getDnsExtractTopDomainLength(provider: ContractProvider, subdomain: Slice): Promise<bigint>;
    getDnsExtractTopDomain(provider: ContractProvider, subdomain: Slice): Promise<Slice>;
    getDnsresolve(provider: ContractProvider, subdomain: Slice, category: bigint): Promise<{
        $$type: "DNSResolveResult";
        prefix: bigint;
        record: Cell | null;
    }>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/external-fallbacks_ExternalFallbacksTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/external-fallbacks_ExternalFallbacksTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Add = {
    $$type: 'Add';
    x: bigint;
};
export declare function storeAdd(src: Add): (builder: Builder) => void;
export declare function loadAdd(slice: Slice): {
    $$type: "Add";
    x: bigint;
};
export type ExternalFallbacksTester$Data = {
    $$type: 'ExternalFallbacksTester$Data';
    a: bigint;
};
export declare function storeExternalFallbacksTester$Data(src: ExternalFallbacksTester$Data): (builder: Builder) => void;
export declare function loadExternalFallbacksTester$Data(slice: Slice): {
    $$type: "ExternalFallbacksTester$Data";
    a: bigint;
};
export declare const ExternalFallbacksTester_getterMapping: {
    [key: string]: string;
};
export declare class ExternalFallbacksTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<ExternalFallbacksTester>;
    static fromAddress(address: Address): ExternalFallbacksTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | Add): Promise<void>;
    sendExternal(provider: ContractProvider, message: null | Add): Promise<void>;
    getGetA(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/getters_Test.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/getters_Test.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type S = {
    $$type: 'S';
    a: bigint;
    b: bigint;
};
export declare function storeS(src: S): (builder: Builder) => void;
export declare function loadS(slice: Slice): {
    $$type: "S";
    a: bigint;
    b: bigint;
};
export type SetIdAndData = {
    $$type: 'SetIdAndData';
    id: bigint;
    data: Cell;
};
export declare function storeSetIdAndData(src: SetIdAndData): (builder: Builder) => void;
export declare function loadSetIdAndData(slice: Slice): {
    $$type: "SetIdAndData";
    id: bigint;
    data: Cell;
};
export type Test$Data = {
    $$type: 'Test$Data';
    id: bigint;
    anotherData: Cell;
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
    id: bigint;
    anotherData: Cell;
};
export declare const Test_getterMapping: {
    [key: string]: string;
};
export declare class Test implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Test>;
    static fromAddress(address: Address): Test;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: SetIdAndData | Deploy): Promise<void>;
    getTestGetter(provider: ContractProvider): Promise<bigint>;
    gettest_getter(provider: ContractProvider): Promise<bigint>;
    getTest_getter(provider: ContractProvider): Promise<bigint>;
    getContractData(provider: ContractProvider): Promise<{
        $$type: "Test$Data";
        id: bigint;
        anotherData: Cell;
    }>;
    getStructAsInput(provider: ContractProvider, s: S): Promise<{
        $$type: "S";
        a: bigint;
        b: bigint;
    }>;
    getMessageAsInput1(provider: ContractProvider, m: SetIdAndData): Promise<bigint>;
    getMessageAsInput2(provider: ContractProvider, m: SetIdAndData): Promise<{
        $$type: "SetIdAndData";
        id: bigint;
        data: Cell;
    }>;
    getContractAsInput(provider: ContractProvider, test: Test$Data): Promise<{
        $$type: "Test$Data";
        id: bigint;
        anotherData: Cell;
    }>;
    getMethodIdExpr(provider: ContractProvider): Promise<boolean>;
    getMethodIdConst(provider: ContractProvider): Promise<bigint>;
    getMethodIdMin(provider: ContractProvider): Promise<boolean>;
    getMethodIdMax(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/implicit-init_MyContract.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/implicit-init_MyContract.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type MyContract$Data = {
    $$type: 'MyContract$Data';
    counter: bigint;
};
export declare function storeMyContract$Data(src: MyContract$Data): (builder: Builder) => void;
export declare function loadMyContract$Data(slice: Slice): {
    $$type: "MyContract$Data";
    counter: bigint;
};
export declare const MyContract_getterMapping: {
    [key: string]: string;
};
export declare class MyContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MyContract>;
    static fromAddress(address: Address): MyContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "increment" | Deploy): Promise<void>;
    getGetCounter(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/init-of-message_Test.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/init-of-message_Test.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type InitData = {
    $$type: 'InitData';
    seller: Address;
    nonce: bigint;
};
export declare function storeInitData(src: InitData): (builder: Builder) => void;
export declare function loadInitData(slice: Slice): {
    $$type: "InitData";
    seller: Address;
    nonce: bigint;
};
export type Test$Data = {
    $$type: 'Test$Data';
    seller: Address;
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
    seller: Address;
};
export declare const Test_getterMapping: {
    [key: string]: string;
};
export declare class Test implements Contract {
    static init(i: InitData): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(i: InitData): Promise<Test>;
    static fromAddress(address: Address): Test;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/init-return_Test.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/init-return_Test.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
    a: bigint;
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
    a: bigint;
};
export declare const Test_getterMapping: {
    [key: string]: string;
};
export declare class Test implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Test>;
    static fromAddress(address: Address): Test;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getA(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/initof-2_TestInit.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/initof-2_TestInit.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type Foo = {
    $$type: 'Foo';
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
};
export type TestNested$Data = {
    $$type: 'TestNested$Data';
};
export declare function storeTestNested$Data(src: TestNested$Data): (builder: Builder) => void;
export declare function loadTestNested$Data(slice: Slice): {
    $$type: "TestNested$Data";
};
export type TestInit$Data = {
    $$type: 'TestInit$Data';
};
export declare function storeTestInit$Data(src: TestInit$Data): (builder: Builder) => void;
export declare function loadTestInit$Data(slice: Slice): {
    $$type: "TestInit$Data";
};
export declare const TestInit_getterMapping: {
    [key: string]: string;
};
export declare class TestInit implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<TestInit>;
    static fromAddress(address: Address): TestInit;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Foo | Deploy): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/initof-2_TestNested.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/initof-2_TestNested.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type Foo = {
    $$type: 'Foo';
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
};
export type TestNested$Data = {
    $$type: 'TestNested$Data';
};
export declare function storeTestNested$Data(src: TestNested$Data): (builder: Builder) => void;
export declare function loadTestNested$Data(slice: Slice): {
    $$type: "TestNested$Data";
};
export type TestInit$Data = {
    $$type: 'TestInit$Data';
};
export declare function storeTestInit$Data(src: TestInit$Data): (builder: Builder) => void;
export declare function loadTestInit$Data(slice: Slice): {
    $$type: "TestInit$Data";
};
export declare const TestNested_getterMapping: {
    [key: string]: string;
};
export declare class TestNested implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<TestNested>;
    static fromAddress(address: Address): TestNested;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Deploy): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/initof-3_A.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/initof-3_A.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type B$Data = {
    $$type: 'B$Data';
    owner: Address;
};
export declare function storeB$Data(src: B$Data): (builder: Builder) => void;
export declare function loadB$Data(slice: Slice): {
    $$type: "B$Data";
    owner: Address;
};
export type A$Data = {
    $$type: 'A$Data';
};
export declare function storeA$Data(src: A$Data): (builder: Builder) => void;
export declare function loadA$Data(slice: Slice): {
    $$type: "A$Data";
};
export declare const A_getterMapping: {
    [key: string]: string;
};
export declare class A implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<A>;
    static fromAddress(address: Address): A;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "aa"): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/initof-3_B.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/initof-3_B.d.ts" {
                import { Cell, Slice, Address, Builder, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type B$Data = {
    $$type: 'B$Data';
    owner: Address;
};
export declare function storeB$Data(src: B$Data): (builder: Builder) => void;
export declare function loadB$Data(slice: Slice): {
    $$type: "B$Data";
    owner: Address;
};
export type A$Data = {
    $$type: 'A$Data';
};
export declare function storeA$Data(src: A$Data): (builder: Builder) => void;
export declare function loadA$Data(slice: Slice): {
    $$type: "A$Data";
};
export declare const B_getterMapping: {
    [key: string]: string;
};
export declare class B implements Contract {
    static init(addr: Address): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(addr: Address): Promise<B>;
    static fromAddress(address: Address): B;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/initof_Child.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/initof_Child.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Self$Data = {
    $$type: 'Self$Data';
};
export declare function storeSelf$Data(src: Self$Data): (builder: Builder) => void;
export declare function loadSelf$Data(slice: Slice): {
    $$type: "Self$Data";
};
export type ChildAddress = {
    $$type: 'ChildAddress';
    address: Address;
};
export declare function storeChildAddress(src: ChildAddress): (builder: Builder) => void;
export declare function loadChildAddress(slice: Slice): {
    $$type: "ChildAddress";
    address: Address;
};
export type Child$Data = {
    $$type: 'Child$Data';
    owner: Address;
};
export declare function storeChild$Data(src: Child$Data): (builder: Builder) => void;
export declare function loadChild$Data(slice: Slice): {
    $$type: "Child$Data";
    owner: Address;
};
export type Parent$Data = {
    $$type: 'Parent$Data';
    childMyAddress: Address;
};
export declare function storeParent$Data(src: Parent$Data): (builder: Builder) => void;
export declare function loadParent$Data(slice: Slice): {
    $$type: "Parent$Data";
    childMyAddress: Address;
};
export declare const Child_getterMapping: {
    [key: string]: string;
};
export declare class Child implements Contract {
    static init(owner: Address): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(owner: Address): Promise<Child>;
    static fromAddress(address: Address): Child;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/initof_Parent.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/initof_Parent.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Self$Data = {
    $$type: 'Self$Data';
};
export declare function storeSelf$Data(src: Self$Data): (builder: Builder) => void;
export declare function loadSelf$Data(slice: Slice): {
    $$type: "Self$Data";
};
export type ChildAddress = {
    $$type: 'ChildAddress';
    address: Address;
};
export declare function storeChildAddress(src: ChildAddress): (builder: Builder) => void;
export declare function loadChildAddress(slice: Slice): {
    $$type: "ChildAddress";
    address: Address;
};
export type Child$Data = {
    $$type: 'Child$Data';
    owner: Address;
};
export declare function storeChild$Data(src: Child$Data): (builder: Builder) => void;
export declare function loadChild$Data(slice: Slice): {
    $$type: "Child$Data";
    owner: Address;
};
export type Parent$Data = {
    $$type: 'Parent$Data';
    childMyAddress: Address;
};
export declare function storeParent$Data(src: Parent$Data): (builder: Builder) => void;
export declare function loadParent$Data(slice: Slice): {
    $$type: "Parent$Data";
    childMyAddress: Address;
};
export declare const Parent_getterMapping: {
    [key: string]: string;
};
export declare class Parent implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Parent>;
    static fromAddress(address: Address): Parent;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | ChildAddress): Promise<void>;
    getTestInitOfAddressChild(provider: ContractProvider): Promise<Address>;
    getTestMyAddressChild(provider: ContractProvider): Promise<Address>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/initof_Self.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/initof_Self.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Self$Data = {
    $$type: 'Self$Data';
};
export declare function storeSelf$Data(src: Self$Data): (builder: Builder) => void;
export declare function loadSelf$Data(slice: Slice): {
    $$type: "Self$Data";
};
export type ChildAddress = {
    $$type: 'ChildAddress';
    address: Address;
};
export declare function storeChildAddress(src: ChildAddress): (builder: Builder) => void;
export declare function loadChildAddress(slice: Slice): {
    $$type: "ChildAddress";
    address: Address;
};
export type Child$Data = {
    $$type: 'Child$Data';
    owner: Address;
};
export declare function storeChild$Data(src: Child$Data): (builder: Builder) => void;
export declare function loadChild$Data(slice: Slice): {
    $$type: "Child$Data";
    owner: Address;
};
export type Parent$Data = {
    $$type: 'Parent$Data';
    childMyAddress: Address;
};
export declare function storeParent$Data(src: Parent$Data): (builder: Builder) => void;
export declare function loadParent$Data(slice: Slice): {
    $$type: "Parent$Data";
    childMyAddress: Address;
};
export declare const Self_getterMapping: {
    [key: string]: string;
};
export declare class Self implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Self>;
    static fromAddress(address: Address): Self;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestInitOfAddress(provider: ContractProvider): Promise<Address>;
    getTestMyAddress(provider: ContractProvider): Promise<Address>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/integer-literals_IntegerLiteralsTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/integer-literals_IntegerLiteralsTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type IntegerLiteralsTester$Data = {
    $$type: 'IntegerLiteralsTester$Data';
};
export declare function storeIntegerLiteralsTester$Data(src: IntegerLiteralsTester$Data): (builder: Builder) => void;
export declare function loadIntegerLiteralsTester$Data(slice: Slice): {
    $$type: "IntegerLiteralsTester$Data";
};
export declare const IntegerLiteralsTester_getterMapping: {
    [key: string]: string;
};
export declare class IntegerLiteralsTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<IntegerLiteralsTester>;
    static fromAddress(address: Address): IntegerLiteralsTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getDecLiteral1(provider: ContractProvider): Promise<bigint>;
    getDecLiteral2(provider: ContractProvider): Promise<bigint>;
    getDecLiteral3(provider: ContractProvider): Promise<bigint>;
    getHexLiteral1(provider: ContractProvider): Promise<bigint>;
    getHexLiteral2(provider: ContractProvider): Promise<bigint>;
    getHexLiteral3(provider: ContractProvider): Promise<bigint>;
    getBinLiteral1(provider: ContractProvider): Promise<bigint>;
    getBinLiteral2(provider: ContractProvider): Promise<bigint>;
    getBinLiteral3(provider: ContractProvider): Promise<bigint>;
    getOctLiteral1(provider: ContractProvider): Promise<bigint>;
    getOctLiteral2(provider: ContractProvider): Promise<bigint>;
    getOctLiteral3(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/intrinsics_IntrinsicsTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/intrinsics_IntrinsicsTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type IntrinsicsTester$Data = {
    $$type: 'IntrinsicsTester$Data';
    a: bigint;
    b: string;
    c: Address;
    d: Cell;
    e: bigint;
    f: bigint;
    g: Slice;
    h: Slice;
    i: bigint;
    j: bigint;
    k: bigint;
    l: bigint;
    m: Slice;
    n: Slice;
    o: Slice;
    p: Slice;
    q: Slice;
    r: Slice;
    s: Slice;
    t: Slice;
    u: Slice;
    w: Slice;
    v: Slice;
};
export declare function storeIntrinsicsTester$Data(src: IntrinsicsTester$Data): (builder: Builder) => void;
export declare function loadIntrinsicsTester$Data(slice: Slice): {
    $$type: "IntrinsicsTester$Data";
    a: bigint;
    b: string;
    c: Address;
    d: Cell;
    e: bigint;
    f: bigint;
    g: Slice;
    h: Slice;
    i: bigint;
    j: bigint;
    k: bigint;
    l: bigint;
    m: Slice;
    n: Slice;
    o: Slice;
    p: Slice;
    q: Slice;
    r: Slice;
    s: Slice;
    t: Slice;
    u: Slice;
    w: Slice;
    v: Slice;
};
export declare const IntrinsicsTester_getterMapping: {
    [key: string]: string;
};
export declare class IntrinsicsTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<IntrinsicsTester>;
    static fromAddress(address: Address): IntrinsicsTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "Deploy" | "emit_1"): Promise<void>;
    getGetTons(provider: ContractProvider): Promise<bigint>;
    getGetTons2(provider: ContractProvider): Promise<bigint>;
    getGetString(provider: ContractProvider): Promise<string>;
    getGetString2(provider: ContractProvider): Promise<string>;
    getGetAddress(provider: ContractProvider): Promise<Address>;
    getGetAddress2(provider: ContractProvider): Promise<Address>;
    getGetCell(provider: ContractProvider): Promise<Cell>;
    getGetCell2(provider: ContractProvider): Promise<Cell>;
    getGetPow(provider: ContractProvider): Promise<bigint>;
    getGetPow2(provider: ContractProvider): Promise<bigint>;
    getGetComment(provider: ContractProvider): Promise<Cell>;
    getGetHash(provider: ContractProvider): Promise<bigint>;
    getGetHash2(provider: ContractProvider): Promise<bigint>;
    getGetHash3(provider: ContractProvider, src: Slice): Promise<bigint>;
    getGetHash4(provider: ContractProvider, src: string): Promise<bigint>;
    getGetHashLongComptime(provider: ContractProvider): Promise<bigint>;
    getGetHashLongRuntime(provider: ContractProvider, src: string): Promise<bigint>;
    getGetSlice(provider: ContractProvider): Promise<Slice>;
    getGetSlice2(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice2(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice3(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice4(provider: ContractProvider): Promise<Slice>;
    getGetAscii(provider: ContractProvider): Promise<bigint>;
    getGetAscii2(provider: ContractProvider): Promise<bigint>;
    getGetAscii3(provider: ContractProvider): Promise<bigint>;
    getGetAscii4(provider: ContractProvider): Promise<bigint>;
    getGetCrc32(provider: ContractProvider): Promise<bigint>;
    getGetCrc32_2(provider: ContractProvider): Promise<bigint>;
    getGetCrc32_3(provider: ContractProvider): Promise<bigint>;
    getGetCrc32_4(provider: ContractProvider): Promise<bigint>;
    getGetRawSlice5(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice6(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice7(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice8(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice9(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice10(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice11(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice12(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice13(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice14(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice15(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice16(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice17(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice18(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice19(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice20(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice21(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice22(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice23(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice24(provider: ContractProvider): Promise<Slice>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/local-type-inference_LocalTypeInferenceTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/local-type-inference_LocalTypeInferenceTester.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type MyStruct = {
    $$type: 'MyStruct';
    x: bigint;
    y: bigint;
};
export declare function storeMyStruct(src: MyStruct): (builder: Builder) => void;
export declare function loadMyStruct(slice: Slice): {
    $$type: "MyStruct";
    x: bigint;
    y: bigint;
};
export type LocalTypeInferenceTester$Data = {
    $$type: 'LocalTypeInferenceTester$Data';
};
export declare function storeLocalTypeInferenceTester$Data(src: LocalTypeInferenceTester$Data): (builder: Builder) => void;
export declare function loadLocalTypeInferenceTester$Data(slice: Slice): {
    $$type: "LocalTypeInferenceTester$Data";
};
export declare const LocalTypeInferenceTester_getterMapping: {
    [key: string]: string;
};
export declare class LocalTypeInferenceTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<LocalTypeInferenceTester>;
    static fromAddress(address: Address): LocalTypeInferenceTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Deploy): Promise<void>;
    getTest1(provider: ContractProvider): Promise<bigint>;
    getTest2(provider: ContractProvider): Promise<bigint>;
    getTest3(provider: ContractProvider): Promise<Address>;
    getTest4(provider: ContractProvider): Promise<Address>;
    getTest5(provider: ContractProvider): Promise<boolean>;
    getTest6(provider: ContractProvider): Promise<Slice>;
    getTest7(provider: ContractProvider): Promise<Cell>;
    getTest8(provider: ContractProvider): Promise<Builder>;
    getTest9(provider: ContractProvider): Promise<string>;
    getTest10(provider: ContractProvider): Promise<string>;
    getTest11(provider: ContractProvider): Promise<{
        $$type: "StateInit";
        code: Cell;
        data: Cell;
    }>;
    getTest12(provider: ContractProvider): Promise<Dictionary<bigint, bigint>>;
    getTest13(provider: ContractProvider): Promise<Dictionary<bigint, number>>;
    getTest14(provider: ContractProvider): Promise<{
        $$type: "MyStruct";
        x: bigint;
        y: bigint;
    }>;
    getTest15(provider: ContractProvider): Promise<{
        $$type: "MyStruct";
        x: bigint;
        y: bigint;
    }>;
    getTest16(provider: ContractProvider): Promise<bigint | null>;
    getTest17(provider: ContractProvider): Promise<bigint | null>;
    getTest18(provider: ContractProvider): Promise<bigint | null>;
    getTest19(provider: ContractProvider): Promise<bigint | null>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/map-comparison_MapComparisonTestContract.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/map-comparison_MapComparisonTestContract.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Compare = {
    $$type: 'Compare';
    m1: Dictionary<number, boolean>;
    m2: Dictionary<number, boolean>;
};
export declare function storeCompare(src: Compare): (builder: Builder) => void;
export declare function loadCompare(slice: Slice): {
    $$type: "Compare";
    m1: Dictionary<number, boolean>;
    m2: Dictionary<number, boolean>;
};
export type CompareDeep = {
    $$type: 'CompareDeep';
    m1: Dictionary<number, boolean>;
    m2: Dictionary<number, boolean>;
};
export declare function storeCompareDeep(src: CompareDeep): (builder: Builder) => void;
export declare function loadCompareDeep(slice: Slice): {
    $$type: "CompareDeep";
    m1: Dictionary<number, boolean>;
    m2: Dictionary<number, boolean>;
};
export type MapComparisonTestContract$Data = {
    $$type: 'MapComparisonTestContract$Data';
};
export declare function storeMapComparisonTestContract$Data(src: MapComparisonTestContract$Data): (builder: Builder) => void;
export declare function loadMapComparisonTestContract$Data(slice: Slice): {
    $$type: "MapComparisonTestContract$Data";
};
export declare const MapComparisonTestContract_getterMapping: {
    [key: string]: string;
};
export declare class MapComparisonTestContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapComparisonTestContract>;
    static fromAddress(address: Address): MapComparisonTestContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | Compare | CompareDeep): Promise<void>;
    getCompareIntInt(provider: ContractProvider, m1: Dictionary<bigint, bigint>, m2: Dictionary<bigint, bigint>): Promise<boolean>;
    getCompareIntCell(provider: ContractProvider, m1: Dictionary<bigint, Cell>, m2: Dictionary<bigint, Cell>): Promise<boolean>;
    getCompareIntAddress(provider: ContractProvider, m1: Dictionary<bigint, Address>, m2: Dictionary<bigint, Address>): Promise<boolean>;
    getCompareAddressInt(provider: ContractProvider, m1: Dictionary<Address, bigint>, m2: Dictionary<Address, bigint>): Promise<boolean>;
    getCompareAddressCell(provider: ContractProvider, m1: Dictionary<Address, Cell>, m2: Dictionary<Address, Cell>): Promise<boolean>;
    getCompareAddressAddress(provider: ContractProvider, m1: Dictionary<Address, Address>, m2: Dictionary<Address, Address>): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/map-traverse_MapTraverseTestContract.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/map-traverse_MapTraverseTestContract.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyStruct = {
    $$type: 'MyStruct';
    a: bigint;
    b: boolean;
};
export declare function storeMyStruct(src: MyStruct): (builder: Builder) => void;
export declare function loadMyStruct(slice: Slice): {
    $$type: "MyStruct";
    a: bigint;
    b: boolean;
};
export type MyStructWithMap = {
    $$type: 'MyStructWithMap';
    m: Dictionary<bigint, bigint>;
};
export declare function storeMyStructWithMap(src: MyStructWithMap): (builder: Builder) => void;
export declare function loadMyStructWithMap(slice: Slice): {
    $$type: "MyStructWithMap";
    m: Dictionary<bigint, bigint>;
};
export type MapTraverseTestContract$Data = {
    $$type: 'MapTraverseTestContract$Data';
    m: Dictionary<bigint, bigint>;
    s: MyStructWithMap;
};
export declare function storeMapTraverseTestContract$Data(src: MapTraverseTestContract$Data): (builder: Builder) => void;
export declare function loadMapTraverseTestContract$Data(slice: Slice): {
    $$type: "MapTraverseTestContract$Data";
    m: Dictionary<bigint, bigint>;
    s: {
        $$type: "MyStructWithMap";
        m: Dictionary<bigint, bigint>;
    };
};
export declare const MapTraverseTestContract_getterMapping: {
    [key: string]: string;
};
export declare class MapTraverseTestContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapTraverseTestContract>;
    static fromAddress(address: Address): MapTraverseTestContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestIntInt(provider: ContractProvider): Promise<bigint>;
    getTestIntCoins(provider: ContractProvider): Promise<bigint>;
    getTestIntVarint16(provider: ContractProvider): Promise<bigint>;
    getTestIntBool(provider: ContractProvider): Promise<bigint>;
    getTestIntCell(provider: ContractProvider): Promise<bigint>;
    getTestIntAddress(provider: ContractProvider): Promise<bigint>;
    getTestIntStruct(provider: ContractProvider): Promise<bigint>;
    getTestAddressInt(provider: ContractProvider): Promise<bigint>;
    getTestAddressCoins(provider: ContractProvider): Promise<bigint>;
    getTestAddressVarint16(provider: ContractProvider): Promise<bigint>;
    getTestAddressBool(provider: ContractProvider): Promise<bigint>;
    getTestAddressCell(provider: ContractProvider): Promise<bigint>;
    getTestAddressAddress(provider: ContractProvider): Promise<bigint>;
    getTestAddressStruct(provider: ContractProvider): Promise<bigint>;
    getTestEmptyMap(provider: ContractProvider): Promise<bigint>;
    getTestNull(provider: ContractProvider): Promise<bigint>;
    getTestMapModificationDuringTraversal1(provider: ContractProvider): Promise<bigint>;
    getTestMapModificationDuringTraversal2(provider: ContractProvider): Promise<void>;
    getTestMapSize(provider: ContractProvider): Promise<bigint>;
    getTestMapAsField(provider: ContractProvider): Promise<bigint>;
    getTestMapAsStructField(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/maps1_MapTestContract.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/maps1_MapTestContract.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    int: bigint;
    bool: boolean;
    address: Address;
    a: bigint;
    b: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    int: bigint;
    bool: boolean;
    address: Address;
    a: bigint;
    b: bigint;
};
export type GetAllMapsResult = {
    $$type: 'GetAllMapsResult';
    int_varint16: bigint | null;
    int_varint32: bigint | null;
    int_varuint16: bigint | null;
    int_varuint32: bigint | null;
    int_bool: boolean | null;
    int_cell: Cell | null;
    int_address: Address | null;
    int_struct: SomeStruct | null;
    int8_varint16: bigint | null;
    int8_varint32: bigint | null;
    int8_varuint16: bigint | null;
    int8_varuint32: bigint | null;
    int8_bool: boolean | null;
    int8_cell: Cell | null;
    int8_address: Address | null;
    int8_struct: SomeStruct | null;
    int42_varint16: bigint | null;
    int42_varint32: bigint | null;
    int42_varuint16: bigint | null;
    int42_varuint32: bigint | null;
    int42_bool: boolean | null;
    int42_cell: Cell | null;
    int42_address: Address | null;
    int42_struct: SomeStruct | null;
    int256_varint16: bigint | null;
    int256_varint32: bigint | null;
    int256_varuint16: bigint | null;
    int256_varuint32: bigint | null;
    int256_bool: boolean | null;
    int256_cell: Cell | null;
    int256_address: Address | null;
    int256_struct: SomeStruct | null;
    uint8_varint16: bigint | null;
    uint8_varint32: bigint | null;
    uint8_varuint16: bigint | null;
    uint8_varuint32: bigint | null;
    uint8_bool: boolean | null;
    uint8_cell: Cell | null;
    uint8_address: Address | null;
    uint8_struct: SomeStruct | null;
    uint42_varint16: bigint | null;
    uint42_varint32: bigint | null;
    uint42_varuint16: bigint | null;
    uint42_varuint32: bigint | null;
    uint42_bool: boolean | null;
    uint42_cell: Cell | null;
    uint42_address: Address | null;
    uint42_struct: SomeStruct | null;
    uint256_varint16: bigint | null;
    uint256_varint32: bigint | null;
    uint256_varuint16: bigint | null;
    uint256_varuint32: bigint | null;
    uint256_bool: boolean | null;
    uint256_cell: Cell | null;
    uint256_address: Address | null;
    uint256_struct: SomeStruct | null;
    address_varint16: bigint | null;
    address_varint32: bigint | null;
    address_varuint16: bigint | null;
    address_varuint32: bigint | null;
    address_bool: boolean | null;
    address_cell: Cell | null;
    address_address: Address | null;
    address_struct: SomeStruct | null;
};
export declare function storeGetAllMapsResult(src: GetAllMapsResult): (builder: Builder) => void;
export declare function loadGetAllMapsResult(slice: Slice): {
    $$type: "GetAllMapsResult";
    int_varint16: bigint | null;
    int_varint32: bigint | null;
    int_varuint16: bigint | null;
    int_varuint32: bigint | null;
    int_bool: boolean | null;
    int_cell: Cell | null;
    int_address: Address | null;
    int_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    int8_varint16: bigint | null;
    int8_varint32: bigint | null;
    int8_varuint16: bigint | null;
    int8_varuint32: bigint | null;
    int8_bool: boolean | null;
    int8_cell: Cell | null;
    int8_address: Address | null;
    int8_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    int42_varint16: bigint | null;
    int42_varint32: bigint | null;
    int42_varuint16: bigint | null;
    int42_varuint32: bigint | null;
    int42_bool: boolean | null;
    int42_cell: Cell | null;
    int42_address: Address | null;
    int42_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    int256_varint16: bigint | null;
    int256_varint32: bigint | null;
    int256_varuint16: bigint | null;
    int256_varuint32: bigint | null;
    int256_bool: boolean | null;
    int256_cell: Cell | null;
    int256_address: Address | null;
    int256_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    uint8_varint16: bigint | null;
    uint8_varint32: bigint | null;
    uint8_varuint16: bigint | null;
    uint8_varuint32: bigint | null;
    uint8_bool: boolean | null;
    uint8_cell: Cell | null;
    uint8_address: Address | null;
    uint8_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    uint42_varint16: bigint | null;
    uint42_varint32: bigint | null;
    uint42_varuint16: bigint | null;
    uint42_varuint32: bigint | null;
    uint42_bool: boolean | null;
    uint42_cell: Cell | null;
    uint42_address: Address | null;
    uint42_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    uint256_varint16: bigint | null;
    uint256_varint32: bigint | null;
    uint256_varuint16: bigint | null;
    uint256_varuint32: bigint | null;
    uint256_bool: boolean | null;
    uint256_cell: Cell | null;
    uint256_address: Address | null;
    uint256_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    address_varint16: bigint | null;
    address_varint32: bigint | null;
    address_varuint16: bigint | null;
    address_varuint32: bigint | null;
    address_bool: boolean | null;
    address_cell: Cell | null;
    address_address: Address | null;
    address_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
};
export type ReplaceAllMapsResult = {
    $$type: 'ReplaceAllMapsResult';
    int_varint16: boolean;
    int_varint32: boolean;
    int_varuint16: boolean;
    int_varuint32: boolean;
    int_bool: boolean;
    int_cell: boolean;
    int_address: boolean;
    int_struct: boolean;
    int8_varint16: boolean;
    int8_varint32: boolean;
    int8_varuint16: boolean;
    int8_varuint32: boolean;
    int8_bool: boolean;
    int8_cell: boolean;
    int8_address: boolean;
    int8_struct: boolean;
    int42_varint16: boolean;
    int42_varint32: boolean;
    int42_varuint16: boolean;
    int42_varuint32: boolean;
    int42_bool: boolean;
    int42_cell: boolean;
    int42_address: boolean;
    int42_struct: boolean;
    int256_varint16: boolean;
    int256_varint32: boolean;
    int256_varuint16: boolean;
    int256_varuint32: boolean;
    int256_bool: boolean;
    int256_cell: boolean;
    int256_address: boolean;
    int256_struct: boolean;
    uint8_varint16: boolean;
    uint8_varint32: boolean;
    uint8_varuint16: boolean;
    uint8_varuint32: boolean;
    uint8_bool: boolean;
    uint8_cell: boolean;
    uint8_address: boolean;
    uint8_struct: boolean;
    uint42_varint16: boolean;
    uint42_varint32: boolean;
    uint42_varuint16: boolean;
    uint42_varuint32: boolean;
    uint42_bool: boolean;
    uint42_cell: boolean;
    uint42_address: boolean;
    uint42_struct: boolean;
    uint256_varint16: boolean;
    uint256_varint32: boolean;
    uint256_varuint16: boolean;
    uint256_varuint32: boolean;
    uint256_bool: boolean;
    uint256_cell: boolean;
    uint256_address: boolean;
    uint256_struct: boolean;
    address_varint16: boolean;
    address_varint32: boolean;
    address_varuint16: boolean;
    address_varuint32: boolean;
    address_bool: boolean;
    address_cell: boolean;
    address_address: boolean;
    address_struct: boolean;
};
export declare function storeReplaceAllMapsResult(src: ReplaceAllMapsResult): (builder: Builder) => void;
export declare function loadReplaceAllMapsResult(slice: Slice): {
    $$type: "ReplaceAllMapsResult";
    int_varint16: boolean;
    int_varint32: boolean;
    int_varuint16: boolean;
    int_varuint32: boolean;
    int_bool: boolean;
    int_cell: boolean;
    int_address: boolean;
    int_struct: boolean;
    int8_varint16: boolean;
    int8_varint32: boolean;
    int8_varuint16: boolean;
    int8_varuint32: boolean;
    int8_bool: boolean;
    int8_cell: boolean;
    int8_address: boolean;
    int8_struct: boolean;
    int42_varint16: boolean;
    int42_varint32: boolean;
    int42_varuint16: boolean;
    int42_varuint32: boolean;
    int42_bool: boolean;
    int42_cell: boolean;
    int42_address: boolean;
    int42_struct: boolean;
    int256_varint16: boolean;
    int256_varint32: boolean;
    int256_varuint16: boolean;
    int256_varuint32: boolean;
    int256_bool: boolean;
    int256_cell: boolean;
    int256_address: boolean;
    int256_struct: boolean;
    uint8_varint16: boolean;
    uint8_varint32: boolean;
    uint8_varuint16: boolean;
    uint8_varuint32: boolean;
    uint8_bool: boolean;
    uint8_cell: boolean;
    uint8_address: boolean;
    uint8_struct: boolean;
    uint42_varint16: boolean;
    uint42_varint32: boolean;
    uint42_varuint16: boolean;
    uint42_varuint32: boolean;
    uint42_bool: boolean;
    uint42_cell: boolean;
    uint42_address: boolean;
    uint42_struct: boolean;
    uint256_varint16: boolean;
    uint256_varint32: boolean;
    uint256_varuint16: boolean;
    uint256_varuint32: boolean;
    uint256_bool: boolean;
    uint256_cell: boolean;
    uint256_address: boolean;
    uint256_struct: boolean;
    address_varint16: boolean;
    address_varint32: boolean;
    address_varuint16: boolean;
    address_varuint32: boolean;
    address_bool: boolean;
    address_cell: boolean;
    address_address: boolean;
    address_struct: boolean;
};
export type ReplaceGetAllMapsResult = {
    $$type: 'ReplaceGetAllMapsResult';
    int_varint16: bigint | null;
    int_varint32: bigint | null;
    int_varuint16: bigint | null;
    int_varuint32: bigint | null;
    int_bool: boolean | null;
    int_cell: Cell | null;
    int_address: Address | null;
    int_struct: SomeStruct | null;
    int8_varint16: bigint | null;
    int8_varint32: bigint | null;
    int8_varuint16: bigint | null;
    int8_varuint32: bigint | null;
    int8_bool: boolean | null;
    int8_cell: Cell | null;
    int8_address: Address | null;
    int8_struct: SomeStruct | null;
    int42_varint16: bigint | null;
    int42_varint32: bigint | null;
    int42_varuint16: bigint | null;
    int42_varuint32: bigint | null;
    int42_bool: boolean | null;
    int42_cell: Cell | null;
    int42_address: Address | null;
    int42_struct: SomeStruct | null;
    int256_varint16: bigint | null;
    int256_varint32: bigint | null;
    int256_varuint16: bigint | null;
    int256_varuint32: bigint | null;
    int256_bool: boolean | null;
    int256_cell: Cell | null;
    int256_address: Address | null;
    int256_struct: SomeStruct | null;
    uint8_varint16: bigint | null;
    uint8_varint32: bigint | null;
    uint8_varuint16: bigint | null;
    uint8_varuint32: bigint | null;
    uint8_bool: boolean | null;
    uint8_cell: Cell | null;
    uint8_address: Address | null;
    uint8_struct: SomeStruct | null;
    uint42_varint16: bigint | null;
    uint42_varint32: bigint | null;
    uint42_varuint16: bigint | null;
    uint42_varuint32: bigint | null;
    uint42_bool: boolean | null;
    uint42_cell: Cell | null;
    uint42_address: Address | null;
    uint42_struct: SomeStruct | null;
    uint256_varint16: bigint | null;
    uint256_varint32: bigint | null;
    uint256_varuint16: bigint | null;
    uint256_varuint32: bigint | null;
    uint256_bool: boolean | null;
    uint256_cell: Cell | null;
    uint256_address: Address | null;
    uint256_struct: SomeStruct | null;
    address_varint16: bigint | null;
    address_varint32: bigint | null;
    address_varuint16: bigint | null;
    address_varuint32: bigint | null;
    address_bool: boolean | null;
    address_cell: Cell | null;
    address_address: Address | null;
    address_struct: SomeStruct | null;
};
export declare function storeReplaceGetAllMapsResult(src: ReplaceGetAllMapsResult): (builder: Builder) => void;
export declare function loadReplaceGetAllMapsResult(slice: Slice): {
    $$type: "ReplaceGetAllMapsResult";
    int_varint16: bigint | null;
    int_varint32: bigint | null;
    int_varuint16: bigint | null;
    int_varuint32: bigint | null;
    int_bool: boolean | null;
    int_cell: Cell | null;
    int_address: Address | null;
    int_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    int8_varint16: bigint | null;
    int8_varint32: bigint | null;
    int8_varuint16: bigint | null;
    int8_varuint32: bigint | null;
    int8_bool: boolean | null;
    int8_cell: Cell | null;
    int8_address: Address | null;
    int8_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    int42_varint16: bigint | null;
    int42_varint32: bigint | null;
    int42_varuint16: bigint | null;
    int42_varuint32: bigint | null;
    int42_bool: boolean | null;
    int42_cell: Cell | null;
    int42_address: Address | null;
    int42_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    int256_varint16: bigint | null;
    int256_varint32: bigint | null;
    int256_varuint16: bigint | null;
    int256_varuint32: bigint | null;
    int256_bool: boolean | null;
    int256_cell: Cell | null;
    int256_address: Address | null;
    int256_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    uint8_varint16: bigint | null;
    uint8_varint32: bigint | null;
    uint8_varuint16: bigint | null;
    uint8_varuint32: bigint | null;
    uint8_bool: boolean | null;
    uint8_cell: Cell | null;
    uint8_address: Address | null;
    uint8_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    uint42_varint16: bigint | null;
    uint42_varint32: bigint | null;
    uint42_varuint16: bigint | null;
    uint42_varuint32: bigint | null;
    uint42_bool: boolean | null;
    uint42_cell: Cell | null;
    uint42_address: Address | null;
    uint42_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    uint256_varint16: bigint | null;
    uint256_varint32: bigint | null;
    uint256_varuint16: bigint | null;
    uint256_varuint32: bigint | null;
    uint256_bool: boolean | null;
    uint256_cell: Cell | null;
    uint256_address: Address | null;
    uint256_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    address_varint16: bigint | null;
    address_varint32: bigint | null;
    address_varuint16: bigint | null;
    address_varuint32: bigint | null;
    address_bool: boolean | null;
    address_cell: Cell | null;
    address_address: Address | null;
    address_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
};
export type ExistsAllMapsResult = {
    $$type: 'ExistsAllMapsResult';
    int_varint16: boolean;
    int_varint32: boolean;
    int_varuint16: boolean;
    int_varuint32: boolean;
    int_bool: boolean;
    int_cell: boolean;
    int_address: boolean;
    int_struct: boolean;
    int8_varint16: boolean;
    int8_varint32: boolean;
    int8_varuint16: boolean;
    int8_varuint32: boolean;
    int8_bool: boolean;
    int8_cell: boolean;
    int8_address: boolean;
    int8_struct: boolean;
    int42_varint16: boolean;
    int42_varint32: boolean;
    int42_varuint16: boolean;
    int42_varuint32: boolean;
    int42_bool: boolean;
    int42_cell: boolean;
    int42_address: boolean;
    int42_struct: boolean;
    int256_varint16: boolean;
    int256_varint32: boolean;
    int256_varuint16: boolean;
    int256_varuint32: boolean;
    int256_bool: boolean;
    int256_cell: boolean;
    int256_address: boolean;
    int256_struct: boolean;
    uint8_varint16: boolean;
    uint8_varint32: boolean;
    uint8_varuint16: boolean;
    uint8_varuint32: boolean;
    uint8_bool: boolean;
    uint8_cell: boolean;
    uint8_address: boolean;
    uint8_struct: boolean;
    uint42_varint16: boolean;
    uint42_varint32: boolean;
    uint42_varuint16: boolean;
    uint42_varuint32: boolean;
    uint42_bool: boolean;
    uint42_cell: boolean;
    uint42_address: boolean;
    uint42_struct: boolean;
    uint256_varint16: boolean;
    uint256_varint32: boolean;
    uint256_varuint16: boolean;
    uint256_varuint32: boolean;
    uint256_bool: boolean;
    uint256_cell: boolean;
    uint256_address: boolean;
    uint256_struct: boolean;
    address_varint16: boolean;
    address_varint32: boolean;
    address_varuint16: boolean;
    address_varuint32: boolean;
    address_bool: boolean;
    address_cell: boolean;
    address_address: boolean;
    address_struct: boolean;
};
export declare function storeExistsAllMapsResult(src: ExistsAllMapsResult): (builder: Builder) => void;
export declare function loadExistsAllMapsResult(slice: Slice): {
    $$type: "ExistsAllMapsResult";
    int_varint16: boolean;
    int_varint32: boolean;
    int_varuint16: boolean;
    int_varuint32: boolean;
    int_bool: boolean;
    int_cell: boolean;
    int_address: boolean;
    int_struct: boolean;
    int8_varint16: boolean;
    int8_varint32: boolean;
    int8_varuint16: boolean;
    int8_varuint32: boolean;
    int8_bool: boolean;
    int8_cell: boolean;
    int8_address: boolean;
    int8_struct: boolean;
    int42_varint16: boolean;
    int42_varint32: boolean;
    int42_varuint16: boolean;
    int42_varuint32: boolean;
    int42_bool: boolean;
    int42_cell: boolean;
    int42_address: boolean;
    int42_struct: boolean;
    int256_varint16: boolean;
    int256_varint32: boolean;
    int256_varuint16: boolean;
    int256_varuint32: boolean;
    int256_bool: boolean;
    int256_cell: boolean;
    int256_address: boolean;
    int256_struct: boolean;
    uint8_varint16: boolean;
    uint8_varint32: boolean;
    uint8_varuint16: boolean;
    uint8_varuint32: boolean;
    uint8_bool: boolean;
    uint8_cell: boolean;
    uint8_address: boolean;
    uint8_struct: boolean;
    uint42_varint16: boolean;
    uint42_varint32: boolean;
    uint42_varuint16: boolean;
    uint42_varuint32: boolean;
    uint42_bool: boolean;
    uint42_cell: boolean;
    uint42_address: boolean;
    uint42_struct: boolean;
    uint256_varint16: boolean;
    uint256_varint32: boolean;
    uint256_varuint16: boolean;
    uint256_varuint32: boolean;
    uint256_bool: boolean;
    uint256_cell: boolean;
    uint256_address: boolean;
    uint256_struct: boolean;
    address_varint16: boolean;
    address_varint32: boolean;
    address_varuint16: boolean;
    address_varuint32: boolean;
    address_bool: boolean;
    address_cell: boolean;
    address_address: boolean;
    address_struct: boolean;
};
export type IsEmptyAllMapsResult = {
    $$type: 'IsEmptyAllMapsResult';
    int_varint16: boolean;
    int_varint32: boolean;
    int_varuint16: boolean;
    int_varuint32: boolean;
    int_bool: boolean;
    int_cell: boolean;
    int_address: boolean;
    int_struct: boolean;
    int8_varint16: boolean;
    int8_varint32: boolean;
    int8_varuint16: boolean;
    int8_varuint32: boolean;
    int8_bool: boolean;
    int8_cell: boolean;
    int8_address: boolean;
    int8_struct: boolean;
    int42_varint16: boolean;
    int42_varint32: boolean;
    int42_varuint16: boolean;
    int42_varuint32: boolean;
    int42_bool: boolean;
    int42_cell: boolean;
    int42_address: boolean;
    int42_struct: boolean;
    int256_varint16: boolean;
    int256_varint32: boolean;
    int256_varuint16: boolean;
    int256_varuint32: boolean;
    int256_bool: boolean;
    int256_cell: boolean;
    int256_address: boolean;
    int256_struct: boolean;
    uint8_varint16: boolean;
    uint8_varint32: boolean;
    uint8_varuint16: boolean;
    uint8_varuint32: boolean;
    uint8_bool: boolean;
    uint8_cell: boolean;
    uint8_address: boolean;
    uint8_struct: boolean;
    uint42_varint16: boolean;
    uint42_varint32: boolean;
    uint42_varuint16: boolean;
    uint42_varuint32: boolean;
    uint42_bool: boolean;
    uint42_cell: boolean;
    uint42_address: boolean;
    uint42_struct: boolean;
    uint256_varint16: boolean;
    uint256_varint32: boolean;
    uint256_varuint16: boolean;
    uint256_varuint32: boolean;
    uint256_bool: boolean;
    uint256_cell: boolean;
    uint256_address: boolean;
    uint256_struct: boolean;
    address_varint16: boolean;
    address_varint32: boolean;
    address_varuint16: boolean;
    address_varuint32: boolean;
    address_bool: boolean;
    address_cell: boolean;
    address_address: boolean;
    address_struct: boolean;
};
export declare function storeIsEmptyAllMapsResult(src: IsEmptyAllMapsResult): (builder: Builder) => void;
export declare function loadIsEmptyAllMapsResult(slice: Slice): {
    $$type: "IsEmptyAllMapsResult";
    int_varint16: boolean;
    int_varint32: boolean;
    int_varuint16: boolean;
    int_varuint32: boolean;
    int_bool: boolean;
    int_cell: boolean;
    int_address: boolean;
    int_struct: boolean;
    int8_varint16: boolean;
    int8_varint32: boolean;
    int8_varuint16: boolean;
    int8_varuint32: boolean;
    int8_bool: boolean;
    int8_cell: boolean;
    int8_address: boolean;
    int8_struct: boolean;
    int42_varint16: boolean;
    int42_varint32: boolean;
    int42_varuint16: boolean;
    int42_varuint32: boolean;
    int42_bool: boolean;
    int42_cell: boolean;
    int42_address: boolean;
    int42_struct: boolean;
    int256_varint16: boolean;
    int256_varint32: boolean;
    int256_varuint16: boolean;
    int256_varuint32: boolean;
    int256_bool: boolean;
    int256_cell: boolean;
    int256_address: boolean;
    int256_struct: boolean;
    uint8_varint16: boolean;
    uint8_varint32: boolean;
    uint8_varuint16: boolean;
    uint8_varuint32: boolean;
    uint8_bool: boolean;
    uint8_cell: boolean;
    uint8_address: boolean;
    uint8_struct: boolean;
    uint42_varint16: boolean;
    uint42_varint32: boolean;
    uint42_varuint16: boolean;
    uint42_varuint32: boolean;
    uint42_bool: boolean;
    uint42_cell: boolean;
    uint42_address: boolean;
    uint42_struct: boolean;
    uint256_varint16: boolean;
    uint256_varint32: boolean;
    uint256_varuint16: boolean;
    uint256_varuint32: boolean;
    uint256_bool: boolean;
    uint256_cell: boolean;
    uint256_address: boolean;
    uint256_struct: boolean;
    address_varint16: boolean;
    address_varint32: boolean;
    address_varuint16: boolean;
    address_varuint32: boolean;
    address_bool: boolean;
    address_cell: boolean;
    address_address: boolean;
    address_struct: boolean;
};
export type AsCellAllMapsResult = {
    $$type: 'AsCellAllMapsResult';
    int_varint16: Cell | null;
    int_varint32: Cell | null;
    int_varuint16: Cell | null;
    int_varuint32: Cell | null;
    int_bool: Cell | null;
    int_cell: Cell | null;
    int_address: Cell | null;
    int_struct: Cell | null;
    int8_varint16: Cell | null;
    int8_varint32: Cell | null;
    int8_varuint16: Cell | null;
    int8_varuint32: Cell | null;
    int8_bool: Cell | null;
    int8_cell: Cell | null;
    int8_address: Cell | null;
    int8_struct: Cell | null;
    int42_varint16: Cell | null;
    int42_varint32: Cell | null;
    int42_varuint16: Cell | null;
    int42_varuint32: Cell | null;
    int42_bool: Cell | null;
    int42_cell: Cell | null;
    int42_address: Cell | null;
    int42_struct: Cell | null;
    int256_varint16: Cell | null;
    int256_varint32: Cell | null;
    int256_varuint16: Cell | null;
    int256_varuint32: Cell | null;
    int256_bool: Cell | null;
    int256_cell: Cell | null;
    int256_address: Cell | null;
    int256_struct: Cell | null;
    uint8_varint16: Cell | null;
    uint8_varint32: Cell | null;
    uint8_varuint16: Cell | null;
    uint8_varuint32: Cell | null;
    uint8_bool: Cell | null;
    uint8_cell: Cell | null;
    uint8_address: Cell | null;
    uint8_struct: Cell | null;
    uint42_varint16: Cell | null;
    uint42_varint32: Cell | null;
    uint42_varuint16: Cell | null;
    uint42_varuint32: Cell | null;
    uint42_bool: Cell | null;
    uint42_cell: Cell | null;
    uint42_address: Cell | null;
    uint42_struct: Cell | null;
    uint256_varint16: Cell | null;
    uint256_varint32: Cell | null;
    uint256_varuint16: Cell | null;
    uint256_varuint32: Cell | null;
    uint256_bool: Cell | null;
    uint256_cell: Cell | null;
    uint256_address: Cell | null;
    uint256_struct: Cell | null;
    address_varint16: Cell | null;
    address_varint32: Cell | null;
    address_varuint16: Cell | null;
    address_varuint32: Cell | null;
    address_bool: Cell | null;
    address_cell: Cell | null;
    address_address: Cell | null;
    address_struct: Cell | null;
};
export declare function storeAsCellAllMapsResult(src: AsCellAllMapsResult): (builder: Builder) => void;
export declare function loadAsCellAllMapsResult(slice: Slice): {
    $$type: "AsCellAllMapsResult";
    int_varint16: Cell | null;
    int_varint32: Cell | null;
    int_varuint16: Cell | null;
    int_varuint32: Cell | null;
    int_bool: Cell | null;
    int_cell: Cell | null;
    int_address: Cell | null;
    int_struct: Cell | null;
    int8_varint16: Cell | null;
    int8_varint32: Cell | null;
    int8_varuint16: Cell | null;
    int8_varuint32: Cell | null;
    int8_bool: Cell | null;
    int8_cell: Cell | null;
    int8_address: Cell | null;
    int8_struct: Cell | null;
    int42_varint16: Cell | null;
    int42_varint32: Cell | null;
    int42_varuint16: Cell | null;
    int42_varuint32: Cell | null;
    int42_bool: Cell | null;
    int42_cell: Cell | null;
    int42_address: Cell | null;
    int42_struct: Cell | null;
    int256_varint16: Cell | null;
    int256_varint32: Cell | null;
    int256_varuint16: Cell | null;
    int256_varuint32: Cell | null;
    int256_bool: Cell | null;
    int256_cell: Cell | null;
    int256_address: Cell | null;
    int256_struct: Cell | null;
    uint8_varint16: Cell | null;
    uint8_varint32: Cell | null;
    uint8_varuint16: Cell | null;
    uint8_varuint32: Cell | null;
    uint8_bool: Cell | null;
    uint8_cell: Cell | null;
    uint8_address: Cell | null;
    uint8_struct: Cell | null;
    uint42_varint16: Cell | null;
    uint42_varint32: Cell | null;
    uint42_varuint16: Cell | null;
    uint42_varuint32: Cell | null;
    uint42_bool: Cell | null;
    uint42_cell: Cell | null;
    uint42_address: Cell | null;
    uint42_struct: Cell | null;
    uint256_varint16: Cell | null;
    uint256_varint32: Cell | null;
    uint256_varuint16: Cell | null;
    uint256_varuint32: Cell | null;
    uint256_bool: Cell | null;
    uint256_cell: Cell | null;
    uint256_address: Cell | null;
    uint256_struct: Cell | null;
    address_varint16: Cell | null;
    address_varint32: Cell | null;
    address_varuint16: Cell | null;
    address_varuint32: Cell | null;
    address_bool: Cell | null;
    address_cell: Cell | null;
    address_address: Cell | null;
    address_struct: Cell | null;
};
export type SetAllMaps = {
    $$type: 'SetAllMaps';
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueVarint16: bigint | null;
    valueVarint32: bigint | null;
    valueVaruint16: bigint | null;
    valueVaruint32: bigint | null;
    valueBool: boolean | null;
    valueCell: Cell | null;
    valueAddress: Address | null;
    valueStruct: SomeStruct | null;
};
export declare function storeSetAllMaps(src: SetAllMaps): (builder: Builder) => void;
export declare function loadSetAllMaps(slice: Slice): {
    $$type: "SetAllMaps";
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueVarint16: bigint | null;
    valueVarint32: bigint | null;
    valueVaruint16: bigint | null;
    valueVaruint32: bigint | null;
    valueBool: boolean | null;
    valueCell: Cell | null;
    valueAddress: Address | null;
    valueStruct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
};
export type DelAllMaps = {
    $$type: 'DelAllMaps';
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
};
export declare function storeDelAllMaps(src: DelAllMaps): (builder: Builder) => void;
export declare function loadDelAllMaps(slice: Slice): {
    $$type: "DelAllMaps";
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
};
export type ReplaceAllMaps = {
    $$type: 'ReplaceAllMaps';
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueVarint16: bigint | null;
    valueVarint32: bigint | null;
    valueVaruint16: bigint | null;
    valueVaruint32: bigint | null;
    valueBool: boolean | null;
    valueCell: Cell | null;
    valueAddress: Address | null;
    valueStruct: SomeStruct | null;
};
export declare function storeReplaceAllMaps(src: ReplaceAllMaps): (builder: Builder) => void;
export declare function loadReplaceAllMaps(slice: Slice): {
    $$type: "ReplaceAllMaps";
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueVarint16: bigint | null;
    valueVarint32: bigint | null;
    valueVaruint16: bigint | null;
    valueVaruint32: bigint | null;
    valueBool: boolean | null;
    valueCell: Cell | null;
    valueAddress: Address | null;
    valueStruct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
};
export type ReplaceGetAllMaps = {
    $$type: 'ReplaceGetAllMaps';
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueVarint16: bigint | null;
    valueVarint32: bigint | null;
    valueVaruint16: bigint | null;
    valueVaruint32: bigint | null;
    valueBool: boolean | null;
    valueCell: Cell | null;
    valueAddress: Address | null;
    valueStruct: SomeStruct | null;
};
export declare function storeReplaceGetAllMaps(src: ReplaceGetAllMaps): (builder: Builder) => void;
export declare function loadReplaceGetAllMaps(slice: Slice): {
    $$type: "ReplaceGetAllMaps";
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueVarint16: bigint | null;
    valueVarint32: bigint | null;
    valueVaruint16: bigint | null;
    valueVaruint32: bigint | null;
    valueBool: boolean | null;
    valueCell: Cell | null;
    valueAddress: Address | null;
    valueStruct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
};
export type CheckNullReference = {
    $$type: 'CheckNullReference';
};
export declare function storeCheckNullReference(src: CheckNullReference): (builder: Builder) => void;
export declare function loadCheckNullReference(slice: Slice): {
    $$type: "CheckNullReference";
};
export type MapTestContract$Data = {
    $$type: 'MapTestContract$Data';
    int_varint16: Dictionary<bigint, bigint>;
    int_varint32: Dictionary<bigint, bigint>;
    int_varuint16: Dictionary<bigint, bigint>;
    int_varuint32: Dictionary<bigint, bigint>;
    int_bool: Dictionary<bigint, boolean>;
    int_cell: Dictionary<bigint, Cell>;
    int_address: Dictionary<bigint, Address>;
    int_struct: Dictionary<bigint, SomeStruct>;
    int8_varint16: Dictionary<number, bigint>;
    int8_varint32: Dictionary<number, bigint>;
    int8_varuint16: Dictionary<number, bigint>;
    int8_varuint32: Dictionary<number, bigint>;
    int8_bool: Dictionary<number, boolean>;
    int8_cell: Dictionary<number, Cell>;
    int8_address: Dictionary<number, Address>;
    int8_struct: Dictionary<number, SomeStruct>;
    int42_varint16: Dictionary<bigint, bigint>;
    int42_varint32: Dictionary<bigint, bigint>;
    int42_varuint16: Dictionary<bigint, bigint>;
    int42_varuint32: Dictionary<bigint, bigint>;
    int42_bool: Dictionary<bigint, boolean>;
    int42_cell: Dictionary<bigint, Cell>;
    int42_address: Dictionary<bigint, Address>;
    int42_struct: Dictionary<bigint, SomeStruct>;
    int256_varint16: Dictionary<bigint, bigint>;
    int256_varint32: Dictionary<bigint, bigint>;
    int256_varuint16: Dictionary<bigint, bigint>;
    int256_varuint32: Dictionary<bigint, bigint>;
    int256_bool: Dictionary<bigint, boolean>;
    int256_cell: Dictionary<bigint, Cell>;
    int256_address: Dictionary<bigint, Address>;
    int256_struct: Dictionary<bigint, SomeStruct>;
    uint8_varint16: Dictionary<number, bigint>;
    uint8_varint32: Dictionary<number, bigint>;
    uint8_varuint16: Dictionary<number, bigint>;
    uint8_varuint32: Dictionary<number, bigint>;
    uint8_bool: Dictionary<number, boolean>;
    uint8_cell: Dictionary<number, Cell>;
    uint8_address: Dictionary<number, Address>;
    uint8_struct: Dictionary<number, SomeStruct>;
    uint42_varint16: Dictionary<bigint, bigint>;
    uint42_varint32: Dictionary<bigint, bigint>;
    uint42_varuint16: Dictionary<bigint, bigint>;
    uint42_varuint32: Dictionary<bigint, bigint>;
    uint42_bool: Dictionary<bigint, boolean>;
    uint42_cell: Dictionary<bigint, Cell>;
    uint42_address: Dictionary<bigint, Address>;
    uint42_struct: Dictionary<bigint, SomeStruct>;
    uint256_varint16: Dictionary<bigint, bigint>;
    uint256_varint32: Dictionary<bigint, bigint>;
    uint256_varuint16: Dictionary<bigint, bigint>;
    uint256_varuint32: Dictionary<bigint, bigint>;
    uint256_bool: Dictionary<bigint, boolean>;
    uint256_cell: Dictionary<bigint, Cell>;
    uint256_address: Dictionary<bigint, Address>;
    uint256_struct: Dictionary<bigint, SomeStruct>;
    address_varint16: Dictionary<Address, bigint>;
    address_varint32: Dictionary<Address, bigint>;
    address_varuint16: Dictionary<Address, bigint>;
    address_varuint32: Dictionary<Address, bigint>;
    address_bool: Dictionary<Address, boolean>;
    address_cell: Dictionary<Address, Cell>;
    address_address: Dictionary<Address, Address>;
    address_struct: Dictionary<Address, SomeStruct>;
};
export declare function storeMapTestContract$Data(src: MapTestContract$Data): (builder: Builder) => void;
export declare function loadMapTestContract$Data(slice: Slice): {
    $$type: "MapTestContract$Data";
    int_varint16: Dictionary<bigint, bigint>;
    int_varint32: Dictionary<bigint, bigint>;
    int_varuint16: Dictionary<bigint, bigint>;
    int_varuint32: Dictionary<bigint, bigint>;
    int_bool: Dictionary<bigint, boolean>;
    int_cell: Dictionary<bigint, Cell>;
    int_address: Dictionary<bigint, Address>;
    int_struct: Dictionary<bigint, SomeStruct>;
    int8_varint16: Dictionary<number, bigint>;
    int8_varint32: Dictionary<number, bigint>;
    int8_varuint16: Dictionary<number, bigint>;
    int8_varuint32: Dictionary<number, bigint>;
    int8_bool: Dictionary<number, boolean>;
    int8_cell: Dictionary<number, Cell>;
    int8_address: Dictionary<number, Address>;
    int8_struct: Dictionary<number, SomeStruct>;
    int42_varint16: Dictionary<bigint, bigint>;
    int42_varint32: Dictionary<bigint, bigint>;
    int42_varuint16: Dictionary<bigint, bigint>;
    int42_varuint32: Dictionary<bigint, bigint>;
    int42_bool: Dictionary<bigint, boolean>;
    int42_cell: Dictionary<bigint, Cell>;
    int42_address: Dictionary<bigint, Address>;
    int42_struct: Dictionary<bigint, SomeStruct>;
    int256_varint16: Dictionary<bigint, bigint>;
    int256_varint32: Dictionary<bigint, bigint>;
    int256_varuint16: Dictionary<bigint, bigint>;
    int256_varuint32: Dictionary<bigint, bigint>;
    int256_bool: Dictionary<bigint, boolean>;
    int256_cell: Dictionary<bigint, Cell>;
    int256_address: Dictionary<bigint, Address>;
    int256_struct: Dictionary<bigint, SomeStruct>;
    uint8_varint16: Dictionary<number, bigint>;
    uint8_varint32: Dictionary<number, bigint>;
    uint8_varuint16: Dictionary<number, bigint>;
    uint8_varuint32: Dictionary<number, bigint>;
    uint8_bool: Dictionary<number, boolean>;
    uint8_cell: Dictionary<number, Cell>;
    uint8_address: Dictionary<number, Address>;
    uint8_struct: Dictionary<number, SomeStruct>;
    uint42_varint16: Dictionary<bigint, bigint>;
    uint42_varint32: Dictionary<bigint, bigint>;
    uint42_varuint16: Dictionary<bigint, bigint>;
    uint42_varuint32: Dictionary<bigint, bigint>;
    uint42_bool: Dictionary<bigint, boolean>;
    uint42_cell: Dictionary<bigint, Cell>;
    uint42_address: Dictionary<bigint, Address>;
    uint42_struct: Dictionary<bigint, SomeStruct>;
    uint256_varint16: Dictionary<bigint, bigint>;
    uint256_varint32: Dictionary<bigint, bigint>;
    uint256_varuint16: Dictionary<bigint, bigint>;
    uint256_varuint32: Dictionary<bigint, bigint>;
    uint256_bool: Dictionary<bigint, boolean>;
    uint256_cell: Dictionary<bigint, Cell>;
    uint256_address: Dictionary<bigint, Address>;
    uint256_struct: Dictionary<bigint, SomeStruct>;
    address_varint16: Dictionary<Address, bigint>;
    address_varint32: Dictionary<Address, bigint>;
    address_varuint16: Dictionary<Address, bigint>;
    address_varuint32: Dictionary<Address, bigint>;
    address_bool: Dictionary<Address, boolean>;
    address_cell: Dictionary<Address, Cell>;
    address_address: Dictionary<Address, Address>;
    address_struct: Dictionary<Address, SomeStruct>;
};
export declare const MapTestContract_getterMapping: {
    [key: string]: string;
};
export declare class MapTestContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapTestContract>;
    static fromAddress(address: Address): MapTestContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | SetAllMaps | DelAllMaps | ReplaceAllMaps | ReplaceGetAllMaps | CheckNullReference): Promise<void>;
    getAllMaps(provider: ContractProvider): Promise<{
        $$type: "MapTestContract$Data";
        int_varint16: Dictionary<bigint, bigint>;
        int_varint32: Dictionary<bigint, bigint>;
        int_varuint16: Dictionary<bigint, bigint>;
        int_varuint32: Dictionary<bigint, bigint>;
        int_bool: Dictionary<bigint, boolean>;
        int_cell: Dictionary<bigint, Cell>;
        int_address: Dictionary<bigint, Address>;
        int_struct: Dictionary<bigint, SomeStruct>;
        int8_varint16: Dictionary<number, bigint>;
        int8_varint32: Dictionary<number, bigint>;
        int8_varuint16: Dictionary<number, bigint>;
        int8_varuint32: Dictionary<number, bigint>;
        int8_bool: Dictionary<number, boolean>;
        int8_cell: Dictionary<number, Cell>;
        int8_address: Dictionary<number, Address>;
        int8_struct: Dictionary<number, SomeStruct>;
        int42_varint16: Dictionary<bigint, bigint>;
        int42_varint32: Dictionary<bigint, bigint>;
        int42_varuint16: Dictionary<bigint, bigint>;
        int42_varuint32: Dictionary<bigint, bigint>;
        int42_bool: Dictionary<bigint, boolean>;
        int42_cell: Dictionary<bigint, Cell>;
        int42_address: Dictionary<bigint, Address>;
        int42_struct: Dictionary<bigint, SomeStruct>;
        int256_varint16: Dictionary<bigint, bigint>;
        int256_varint32: Dictionary<bigint, bigint>;
        int256_varuint16: Dictionary<bigint, bigint>;
        int256_varuint32: Dictionary<bigint, bigint>;
        int256_bool: Dictionary<bigint, boolean>;
        int256_cell: Dictionary<bigint, Cell>;
        int256_address: Dictionary<bigint, Address>;
        int256_struct: Dictionary<bigint, SomeStruct>;
        uint8_varint16: Dictionary<number, bigint>;
        uint8_varint32: Dictionary<number, bigint>;
        uint8_varuint16: Dictionary<number, bigint>;
        uint8_varuint32: Dictionary<number, bigint>;
        uint8_bool: Dictionary<number, boolean>;
        uint8_cell: Dictionary<number, Cell>;
        uint8_address: Dictionary<number, Address>;
        uint8_struct: Dictionary<number, SomeStruct>;
        uint42_varint16: Dictionary<bigint, bigint>;
        uint42_varint32: Dictionary<bigint, bigint>;
        uint42_varuint16: Dictionary<bigint, bigint>;
        uint42_varuint32: Dictionary<bigint, bigint>;
        uint42_bool: Dictionary<bigint, boolean>;
        uint42_cell: Dictionary<bigint, Cell>;
        uint42_address: Dictionary<bigint, Address>;
        uint42_struct: Dictionary<bigint, SomeStruct>;
        uint256_varint16: Dictionary<bigint, bigint>;
        uint256_varint32: Dictionary<bigint, bigint>;
        uint256_varuint16: Dictionary<bigint, bigint>;
        uint256_varuint32: Dictionary<bigint, bigint>;
        uint256_bool: Dictionary<bigint, boolean>;
        uint256_cell: Dictionary<bigint, Cell>;
        uint256_address: Dictionary<bigint, Address>;
        uint256_struct: Dictionary<bigint, SomeStruct>;
        address_varint16: Dictionary<Address, bigint>;
        address_varint32: Dictionary<Address, bigint>;
        address_varuint16: Dictionary<Address, bigint>;
        address_varuint32: Dictionary<Address, bigint>;
        address_bool: Dictionary<Address, boolean>;
        address_cell: Dictionary<Address, Cell>;
        address_address: Dictionary<Address, Address>;
        address_struct: Dictionary<Address, SomeStruct>;
    }>;
    getGetAllMaps(provider: ContractProvider, keyInt: bigint, keyInt8: bigint, keyInt42: bigint, keyInt256: bigint, keyUint8: bigint, keyUint42: bigint, keyUint256: bigint, keyAddress: Address): Promise<{
        $$type: "GetAllMapsResult";
        int_varint16: bigint | null;
        int_varint32: bigint | null;
        int_varuint16: bigint | null;
        int_varuint32: bigint | null;
        int_bool: boolean | null;
        int_cell: Cell | null;
        int_address: Address | null;
        int_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        int8_varint16: bigint | null;
        int8_varint32: bigint | null;
        int8_varuint16: bigint | null;
        int8_varuint32: bigint | null;
        int8_bool: boolean | null;
        int8_cell: Cell | null;
        int8_address: Address | null;
        int8_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        int42_varint16: bigint | null;
        int42_varint32: bigint | null;
        int42_varuint16: bigint | null;
        int42_varuint32: bigint | null;
        int42_bool: boolean | null;
        int42_cell: Cell | null;
        int42_address: Address | null;
        int42_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        int256_varint16: bigint | null;
        int256_varint32: bigint | null;
        int256_varuint16: bigint | null;
        int256_varuint32: bigint | null;
        int256_bool: boolean | null;
        int256_cell: Cell | null;
        int256_address: Address | null;
        int256_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        uint8_varint16: bigint | null;
        uint8_varint32: bigint | null;
        uint8_varuint16: bigint | null;
        uint8_varuint32: bigint | null;
        uint8_bool: boolean | null;
        uint8_cell: Cell | null;
        uint8_address: Address | null;
        uint8_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        uint42_varint16: bigint | null;
        uint42_varint32: bigint | null;
        uint42_varuint16: bigint | null;
        uint42_varuint32: bigint | null;
        uint42_bool: boolean | null;
        uint42_cell: Cell | null;
        uint42_address: Address | null;
        uint42_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        uint256_varint16: bigint | null;
        uint256_varint32: bigint | null;
        uint256_varuint16: bigint | null;
        uint256_varuint32: bigint | null;
        uint256_bool: boolean | null;
        uint256_cell: Cell | null;
        uint256_address: Address | null;
        uint256_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        address_varint16: bigint | null;
        address_varint32: bigint | null;
        address_varuint16: bigint | null;
        address_varuint32: bigint | null;
        address_bool: boolean | null;
        address_cell: Cell | null;
        address_address: Address | null;
        address_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
    }>;
    getReplaceAllMaps(provider: ContractProvider, keyInt: bigint, keyInt8: bigint, keyInt42: bigint, keyInt256: bigint, keyUint8: bigint, keyUint42: bigint, keyUint256: bigint, keyAddress: Address, valueVarint16: bigint, valueVarint32: bigint, valueVaruint16: bigint, valueVaruint32: bigint, valueBool: boolean, valueCell: Cell, valueAddress: Address, valueStruct: SomeStruct): Promise<{
        $$type: "ReplaceAllMapsResult";
        int_varint16: boolean;
        int_varint32: boolean;
        int_varuint16: boolean;
        int_varuint32: boolean;
        int_bool: boolean;
        int_cell: boolean;
        int_address: boolean;
        int_struct: boolean;
        int8_varint16: boolean;
        int8_varint32: boolean;
        int8_varuint16: boolean;
        int8_varuint32: boolean;
        int8_bool: boolean;
        int8_cell: boolean;
        int8_address: boolean;
        int8_struct: boolean;
        int42_varint16: boolean;
        int42_varint32: boolean;
        int42_varuint16: boolean;
        int42_varuint32: boolean;
        int42_bool: boolean;
        int42_cell: boolean;
        int42_address: boolean;
        int42_struct: boolean;
        int256_varint16: boolean;
        int256_varint32: boolean;
        int256_varuint16: boolean;
        int256_varuint32: boolean;
        int256_bool: boolean;
        int256_cell: boolean;
        int256_address: boolean;
        int256_struct: boolean;
        uint8_varint16: boolean;
        uint8_varint32: boolean;
        uint8_varuint16: boolean;
        uint8_varuint32: boolean;
        uint8_bool: boolean;
        uint8_cell: boolean;
        uint8_address: boolean;
        uint8_struct: boolean;
        uint42_varint16: boolean;
        uint42_varint32: boolean;
        uint42_varuint16: boolean;
        uint42_varuint32: boolean;
        uint42_bool: boolean;
        uint42_cell: boolean;
        uint42_address: boolean;
        uint42_struct: boolean;
        uint256_varint16: boolean;
        uint256_varint32: boolean;
        uint256_varuint16: boolean;
        uint256_varuint32: boolean;
        uint256_bool: boolean;
        uint256_cell: boolean;
        uint256_address: boolean;
        uint256_struct: boolean;
        address_varint16: boolean;
        address_varint32: boolean;
        address_varuint16: boolean;
        address_varuint32: boolean;
        address_bool: boolean;
        address_cell: boolean;
        address_address: boolean;
        address_struct: boolean;
    }>;
    getReplaceGetAllMaps(provider: ContractProvider, keyInt: bigint, keyInt8: bigint, keyInt42: bigint, keyInt256: bigint, keyUint8: bigint, keyUint42: bigint, keyUint256: bigint, keyAddress: Address, valueVarint16: bigint, valueVarint32: bigint, valueVaruint16: bigint, valueVaruint32: bigint, valueBool: boolean, valueCell: Cell, valueAddress: Address, valueStruct: SomeStruct): Promise<{
        $$type: "ReplaceGetAllMapsResult";
        int_varint16: bigint | null;
        int_varint32: bigint | null;
        int_varuint16: bigint | null;
        int_varuint32: bigint | null;
        int_bool: boolean | null;
        int_cell: Cell | null;
        int_address: Address | null;
        int_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        int8_varint16: bigint | null;
        int8_varint32: bigint | null;
        int8_varuint16: bigint | null;
        int8_varuint32: bigint | null;
        int8_bool: boolean | null;
        int8_cell: Cell | null;
        int8_address: Address | null;
        int8_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        int42_varint16: bigint | null;
        int42_varint32: bigint | null;
        int42_varuint16: bigint | null;
        int42_varuint32: bigint | null;
        int42_bool: boolean | null;
        int42_cell: Cell | null;
        int42_address: Address | null;
        int42_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        int256_varint16: bigint | null;
        int256_varint32: bigint | null;
        int256_varuint16: bigint | null;
        int256_varuint32: bigint | null;
        int256_bool: boolean | null;
        int256_cell: Cell | null;
        int256_address: Address | null;
        int256_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        uint8_varint16: bigint | null;
        uint8_varint32: bigint | null;
        uint8_varuint16: bigint | null;
        uint8_varuint32: bigint | null;
        uint8_bool: boolean | null;
        uint8_cell: Cell | null;
        uint8_address: Address | null;
        uint8_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        uint42_varint16: bigint | null;
        uint42_varint32: bigint | null;
        uint42_varuint16: bigint | null;
        uint42_varuint32: bigint | null;
        uint42_bool: boolean | null;
        uint42_cell: Cell | null;
        uint42_address: Address | null;
        uint42_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        uint256_varint16: bigint | null;
        uint256_varint32: bigint | null;
        uint256_varuint16: bigint | null;
        uint256_varuint32: bigint | null;
        uint256_bool: boolean | null;
        uint256_cell: Cell | null;
        uint256_address: Address | null;
        uint256_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        address_varint16: bigint | null;
        address_varint32: bigint | null;
        address_varuint16: bigint | null;
        address_varuint32: bigint | null;
        address_bool: boolean | null;
        address_cell: Cell | null;
        address_address: Address | null;
        address_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
    }>;
    getExistsAllMaps(provider: ContractProvider, keyInt: bigint, keyInt8: bigint, keyInt42: bigint, keyInt256: bigint, keyUint8: bigint, keyUint42: bigint, keyUint256: bigint, keyAddress: Address): Promise<{
        $$type: "ExistsAllMapsResult";
        int_varint16: boolean;
        int_varint32: boolean;
        int_varuint16: boolean;
        int_varuint32: boolean;
        int_bool: boolean;
        int_cell: boolean;
        int_address: boolean;
        int_struct: boolean;
        int8_varint16: boolean;
        int8_varint32: boolean;
        int8_varuint16: boolean;
        int8_varuint32: boolean;
        int8_bool: boolean;
        int8_cell: boolean;
        int8_address: boolean;
        int8_struct: boolean;
        int42_varint16: boolean;
        int42_varint32: boolean;
        int42_varuint16: boolean;
        int42_varuint32: boolean;
        int42_bool: boolean;
        int42_cell: boolean;
        int42_address: boolean;
        int42_struct: boolean;
        int256_varint16: boolean;
        int256_varint32: boolean;
        int256_varuint16: boolean;
        int256_varuint32: boolean;
        int256_bool: boolean;
        int256_cell: boolean;
        int256_address: boolean;
        int256_struct: boolean;
        uint8_varint16: boolean;
        uint8_varint32: boolean;
        uint8_varuint16: boolean;
        uint8_varuint32: boolean;
        uint8_bool: boolean;
        uint8_cell: boolean;
        uint8_address: boolean;
        uint8_struct: boolean;
        uint42_varint16: boolean;
        uint42_varint32: boolean;
        uint42_varuint16: boolean;
        uint42_varuint32: boolean;
        uint42_bool: boolean;
        uint42_cell: boolean;
        uint42_address: boolean;
        uint42_struct: boolean;
        uint256_varint16: boolean;
        uint256_varint32: boolean;
        uint256_varuint16: boolean;
        uint256_varuint32: boolean;
        uint256_bool: boolean;
        uint256_cell: boolean;
        uint256_address: boolean;
        uint256_struct: boolean;
        address_varint16: boolean;
        address_varint32: boolean;
        address_varuint16: boolean;
        address_varuint32: boolean;
        address_bool: boolean;
        address_cell: boolean;
        address_address: boolean;
        address_struct: boolean;
    }>;
    getIsEmptyAllMaps(provider: ContractProvider): Promise<{
        $$type: "IsEmptyAllMapsResult";
        int_varint16: boolean;
        int_varint32: boolean;
        int_varuint16: boolean;
        int_varuint32: boolean;
        int_bool: boolean;
        int_cell: boolean;
        int_address: boolean;
        int_struct: boolean;
        int8_varint16: boolean;
        int8_varint32: boolean;
        int8_varuint16: boolean;
        int8_varuint32: boolean;
        int8_bool: boolean;
        int8_cell: boolean;
        int8_address: boolean;
        int8_struct: boolean;
        int42_varint16: boolean;
        int42_varint32: boolean;
        int42_varuint16: boolean;
        int42_varuint32: boolean;
        int42_bool: boolean;
        int42_cell: boolean;
        int42_address: boolean;
        int42_struct: boolean;
        int256_varint16: boolean;
        int256_varint32: boolean;
        int256_varuint16: boolean;
        int256_varuint32: boolean;
        int256_bool: boolean;
        int256_cell: boolean;
        int256_address: boolean;
        int256_struct: boolean;
        uint8_varint16: boolean;
        uint8_varint32: boolean;
        uint8_varuint16: boolean;
        uint8_varuint32: boolean;
        uint8_bool: boolean;
        uint8_cell: boolean;
        uint8_address: boolean;
        uint8_struct: boolean;
        uint42_varint16: boolean;
        uint42_varint32: boolean;
        uint42_varuint16: boolean;
        uint42_varuint32: boolean;
        uint42_bool: boolean;
        uint42_cell: boolean;
        uint42_address: boolean;
        uint42_struct: boolean;
        uint256_varint16: boolean;
        uint256_varint32: boolean;
        uint256_varuint16: boolean;
        uint256_varuint32: boolean;
        uint256_bool: boolean;
        uint256_cell: boolean;
        uint256_address: boolean;
        uint256_struct: boolean;
        address_varint16: boolean;
        address_varint32: boolean;
        address_varuint16: boolean;
        address_varuint32: boolean;
        address_bool: boolean;
        address_cell: boolean;
        address_address: boolean;
        address_struct: boolean;
    }>;
    getAsCellAllMaps(provider: ContractProvider): Promise<{
        $$type: "AsCellAllMapsResult";
        int_varint16: Cell | null;
        int_varint32: Cell | null;
        int_varuint16: Cell | null;
        int_varuint32: Cell | null;
        int_bool: Cell | null;
        int_cell: Cell | null;
        int_address: Cell | null;
        int_struct: Cell | null;
        int8_varint16: Cell | null;
        int8_varint32: Cell | null;
        int8_varuint16: Cell | null;
        int8_varuint32: Cell | null;
        int8_bool: Cell | null;
        int8_cell: Cell | null;
        int8_address: Cell | null;
        int8_struct: Cell | null;
        int42_varint16: Cell | null;
        int42_varint32: Cell | null;
        int42_varuint16: Cell | null;
        int42_varuint32: Cell | null;
        int42_bool: Cell | null;
        int42_cell: Cell | null;
        int42_address: Cell | null;
        int42_struct: Cell | null;
        int256_varint16: Cell | null;
        int256_varint32: Cell | null;
        int256_varuint16: Cell | null;
        int256_varuint32: Cell | null;
        int256_bool: Cell | null;
        int256_cell: Cell | null;
        int256_address: Cell | null;
        int256_struct: Cell | null;
        uint8_varint16: Cell | null;
        uint8_varint32: Cell | null;
        uint8_varuint16: Cell | null;
        uint8_varuint32: Cell | null;
        uint8_bool: Cell | null;
        uint8_cell: Cell | null;
        uint8_address: Cell | null;
        uint8_struct: Cell | null;
        uint42_varint16: Cell | null;
        uint42_varint32: Cell | null;
        uint42_varuint16: Cell | null;
        uint42_varuint32: Cell | null;
        uint42_bool: Cell | null;
        uint42_cell: Cell | null;
        uint42_address: Cell | null;
        uint42_struct: Cell | null;
        uint256_varint16: Cell | null;
        uint256_varint32: Cell | null;
        uint256_varuint16: Cell | null;
        uint256_varuint32: Cell | null;
        uint256_bool: Cell | null;
        uint256_cell: Cell | null;
        uint256_address: Cell | null;
        uint256_struct: Cell | null;
        address_varint16: Cell | null;
        address_varint32: Cell | null;
        address_varuint16: Cell | null;
        address_varuint32: Cell | null;
        address_bool: Cell | null;
        address_cell: Cell | null;
        address_address: Cell | null;
        address_struct: Cell | null;
    }>;
    getCheckNullReference(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/maps2_MapTestContract.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/maps2_MapTestContract.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    int: bigint;
    bool: boolean;
    address: Address;
    a: bigint;
    b: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    int: bigint;
    bool: boolean;
    address: Address;
    a: bigint;
    b: bigint;
};
export type GetAllMapsResult = {
    $$type: 'GetAllMapsResult';
    int_int: bigint | null;
    int_int8: bigint | null;
    int_int42: bigint | null;
    int_int256: bigint | null;
    int_uint8: bigint | null;
    int_uint42: bigint | null;
    int_uint256: bigint | null;
    int_coins: bigint | null;
    int8_int: bigint | null;
    int8_int8: bigint | null;
    int8_int42: bigint | null;
    int8_int256: bigint | null;
    int8_uint8: bigint | null;
    int8_uint42: bigint | null;
    int8_uint256: bigint | null;
    int8_coins: bigint | null;
    int42_int: bigint | null;
    int42_int8: bigint | null;
    int42_int42: bigint | null;
    int42_int256: bigint | null;
    int42_uint8: bigint | null;
    int42_uint42: bigint | null;
    int42_uint256: bigint | null;
    int42_coins: bigint | null;
    int256_int: bigint | null;
    int256_int8: bigint | null;
    int256_int42: bigint | null;
    int256_int256: bigint | null;
    int256_uint8: bigint | null;
    int256_uint42: bigint | null;
    int256_uint256: bigint | null;
    int256_coins: bigint | null;
    uint8_int: bigint | null;
    uint8_int8: bigint | null;
    uint8_int42: bigint | null;
    uint8_int256: bigint | null;
    uint8_uint8: bigint | null;
    uint8_uint42: bigint | null;
    uint8_uint256: bigint | null;
    uint8_coins: bigint | null;
    uint42_int: bigint | null;
    uint42_int8: bigint | null;
    uint42_int42: bigint | null;
    uint42_int256: bigint | null;
    uint42_uint8: bigint | null;
    uint42_uint42: bigint | null;
    uint42_uint256: bigint | null;
    uint42_coins: bigint | null;
    uint256_int: bigint | null;
    uint256_int8: bigint | null;
    uint256_int42: bigint | null;
    uint256_int256: bigint | null;
    uint256_uint8: bigint | null;
    uint256_uint42: bigint | null;
    uint256_uint256: bigint | null;
    uint256_coins: bigint | null;
    address_int: bigint | null;
    address_int8: bigint | null;
    address_int42: bigint | null;
    address_int256: bigint | null;
    address_uint8: bigint | null;
    address_uint42: bigint | null;
    address_uint256: bigint | null;
    address_coins: bigint | null;
};
export declare function storeGetAllMapsResult(src: GetAllMapsResult): (builder: Builder) => void;
export declare function loadGetAllMapsResult(slice: Slice): {
    $$type: "GetAllMapsResult";
    int_int: bigint | null;
    int_int8: bigint | null;
    int_int42: bigint | null;
    int_int256: bigint | null;
    int_uint8: bigint | null;
    int_uint42: bigint | null;
    int_uint256: bigint | null;
    int_coins: bigint | null;
    int8_int: bigint | null;
    int8_int8: bigint | null;
    int8_int42: bigint | null;
    int8_int256: bigint | null;
    int8_uint8: bigint | null;
    int8_uint42: bigint | null;
    int8_uint256: bigint | null;
    int8_coins: bigint | null;
    int42_int: bigint | null;
    int42_int8: bigint | null;
    int42_int42: bigint | null;
    int42_int256: bigint | null;
    int42_uint8: bigint | null;
    int42_uint42: bigint | null;
    int42_uint256: bigint | null;
    int42_coins: bigint | null;
    int256_int: bigint | null;
    int256_int8: bigint | null;
    int256_int42: bigint | null;
    int256_int256: bigint | null;
    int256_uint8: bigint | null;
    int256_uint42: bigint | null;
    int256_uint256: bigint | null;
    int256_coins: bigint | null;
    uint8_int: bigint | null;
    uint8_int8: bigint | null;
    uint8_int42: bigint | null;
    uint8_int256: bigint | null;
    uint8_uint8: bigint | null;
    uint8_uint42: bigint | null;
    uint8_uint256: bigint | null;
    uint8_coins: bigint | null;
    uint42_int: bigint | null;
    uint42_int8: bigint | null;
    uint42_int42: bigint | null;
    uint42_int256: bigint | null;
    uint42_uint8: bigint | null;
    uint42_uint42: bigint | null;
    uint42_uint256: bigint | null;
    uint42_coins: bigint | null;
    uint256_int: bigint | null;
    uint256_int8: bigint | null;
    uint256_int42: bigint | null;
    uint256_int256: bigint | null;
    uint256_uint8: bigint | null;
    uint256_uint42: bigint | null;
    uint256_uint256: bigint | null;
    uint256_coins: bigint | null;
    address_int: bigint | null;
    address_int8: bigint | null;
    address_int42: bigint | null;
    address_int256: bigint | null;
    address_uint8: bigint | null;
    address_uint42: bigint | null;
    address_uint256: bigint | null;
    address_coins: bigint | null;
};
export type ReplaceAllMapsResult = {
    $$type: 'ReplaceAllMapsResult';
    int_int: boolean;
    int_int8: boolean;
    int_int42: boolean;
    int_int256: boolean;
    int_uint8: boolean;
    int_uint42: boolean;
    int_uint256: boolean;
    int_coins: boolean;
    int8_int: boolean;
    int8_int8: boolean;
    int8_int42: boolean;
    int8_int256: boolean;
    int8_uint8: boolean;
    int8_uint42: boolean;
    int8_uint256: boolean;
    int8_coins: boolean;
    int42_int: boolean;
    int42_int8: boolean;
    int42_int42: boolean;
    int42_int256: boolean;
    int42_uint8: boolean;
    int42_uint42: boolean;
    int42_uint256: boolean;
    int42_coins: boolean;
    int256_int: boolean;
    int256_int8: boolean;
    int256_int42: boolean;
    int256_int256: boolean;
    int256_uint8: boolean;
    int256_uint42: boolean;
    int256_uint256: boolean;
    int256_coins: boolean;
    uint8_int: boolean;
    uint8_int8: boolean;
    uint8_int42: boolean;
    uint8_int256: boolean;
    uint8_uint8: boolean;
    uint8_uint42: boolean;
    uint8_uint256: boolean;
    uint8_coins: boolean;
    uint42_int: boolean;
    uint42_int8: boolean;
    uint42_int42: boolean;
    uint42_int256: boolean;
    uint42_uint8: boolean;
    uint42_uint42: boolean;
    uint42_uint256: boolean;
    uint42_coins: boolean;
    uint256_int: boolean;
    uint256_int8: boolean;
    uint256_int42: boolean;
    uint256_int256: boolean;
    uint256_uint8: boolean;
    uint256_uint42: boolean;
    uint256_uint256: boolean;
    uint256_coins: boolean;
    address_int: boolean;
    address_int8: boolean;
    address_int42: boolean;
    address_int256: boolean;
    address_uint8: boolean;
    address_uint42: boolean;
    address_uint256: boolean;
    address_coins: boolean;
};
export declare function storeReplaceAllMapsResult(src: ReplaceAllMapsResult): (builder: Builder) => void;
export declare function loadReplaceAllMapsResult(slice: Slice): {
    $$type: "ReplaceAllMapsResult";
    int_int: boolean;
    int_int8: boolean;
    int_int42: boolean;
    int_int256: boolean;
    int_uint8: boolean;
    int_uint42: boolean;
    int_uint256: boolean;
    int_coins: boolean;
    int8_int: boolean;
    int8_int8: boolean;
    int8_int42: boolean;
    int8_int256: boolean;
    int8_uint8: boolean;
    int8_uint42: boolean;
    int8_uint256: boolean;
    int8_coins: boolean;
    int42_int: boolean;
    int42_int8: boolean;
    int42_int42: boolean;
    int42_int256: boolean;
    int42_uint8: boolean;
    int42_uint42: boolean;
    int42_uint256: boolean;
    int42_coins: boolean;
    int256_int: boolean;
    int256_int8: boolean;
    int256_int42: boolean;
    int256_int256: boolean;
    int256_uint8: boolean;
    int256_uint42: boolean;
    int256_uint256: boolean;
    int256_coins: boolean;
    uint8_int: boolean;
    uint8_int8: boolean;
    uint8_int42: boolean;
    uint8_int256: boolean;
    uint8_uint8: boolean;
    uint8_uint42: boolean;
    uint8_uint256: boolean;
    uint8_coins: boolean;
    uint42_int: boolean;
    uint42_int8: boolean;
    uint42_int42: boolean;
    uint42_int256: boolean;
    uint42_uint8: boolean;
    uint42_uint42: boolean;
    uint42_uint256: boolean;
    uint42_coins: boolean;
    uint256_int: boolean;
    uint256_int8: boolean;
    uint256_int42: boolean;
    uint256_int256: boolean;
    uint256_uint8: boolean;
    uint256_uint42: boolean;
    uint256_uint256: boolean;
    uint256_coins: boolean;
    address_int: boolean;
    address_int8: boolean;
    address_int42: boolean;
    address_int256: boolean;
    address_uint8: boolean;
    address_uint42: boolean;
    address_uint256: boolean;
    address_coins: boolean;
};
export type ReplaceGetAllMapsResult = {
    $$type: 'ReplaceGetAllMapsResult';
    int_int: bigint | null;
    int_int8: bigint | null;
    int_int42: bigint | null;
    int_int256: bigint | null;
    int_uint8: bigint | null;
    int_uint42: bigint | null;
    int_uint256: bigint | null;
    int_coins: bigint | null;
    int8_int: bigint | null;
    int8_int8: bigint | null;
    int8_int42: bigint | null;
    int8_int256: bigint | null;
    int8_uint8: bigint | null;
    int8_uint42: bigint | null;
    int8_uint256: bigint | null;
    int8_coins: bigint | null;
    int42_int: bigint | null;
    int42_int8: bigint | null;
    int42_int42: bigint | null;
    int42_int256: bigint | null;
    int42_uint8: bigint | null;
    int42_uint42: bigint | null;
    int42_uint256: bigint | null;
    int42_coins: bigint | null;
    int256_int: bigint | null;
    int256_int8: bigint | null;
    int256_int42: bigint | null;
    int256_int256: bigint | null;
    int256_uint8: bigint | null;
    int256_uint42: bigint | null;
    int256_uint256: bigint | null;
    int256_coins: bigint | null;
    uint8_int: bigint | null;
    uint8_int8: bigint | null;
    uint8_int42: bigint | null;
    uint8_int256: bigint | null;
    uint8_uint8: bigint | null;
    uint8_uint42: bigint | null;
    uint8_uint256: bigint | null;
    uint8_coins: bigint | null;
    uint42_int: bigint | null;
    uint42_int8: bigint | null;
    uint42_int42: bigint | null;
    uint42_int256: bigint | null;
    uint42_uint8: bigint | null;
    uint42_uint42: bigint | null;
    uint42_uint256: bigint | null;
    uint42_coins: bigint | null;
    uint256_int: bigint | null;
    uint256_int8: bigint | null;
    uint256_int42: bigint | null;
    uint256_int256: bigint | null;
    uint256_uint8: bigint | null;
    uint256_uint42: bigint | null;
    uint256_uint256: bigint | null;
    uint256_coins: bigint | null;
    address_int: bigint | null;
    address_int8: bigint | null;
    address_int42: bigint | null;
    address_int256: bigint | null;
    address_uint8: bigint | null;
    address_uint42: bigint | null;
    address_uint256: bigint | null;
    address_coins: bigint | null;
};
export declare function storeReplaceGetAllMapsResult(src: ReplaceGetAllMapsResult): (builder: Builder) => void;
export declare function loadReplaceGetAllMapsResult(slice: Slice): {
    $$type: "ReplaceGetAllMapsResult";
    int_int: bigint | null;
    int_int8: bigint | null;
    int_int42: bigint | null;
    int_int256: bigint | null;
    int_uint8: bigint | null;
    int_uint42: bigint | null;
    int_uint256: bigint | null;
    int_coins: bigint | null;
    int8_int: bigint | null;
    int8_int8: bigint | null;
    int8_int42: bigint | null;
    int8_int256: bigint | null;
    int8_uint8: bigint | null;
    int8_uint42: bigint | null;
    int8_uint256: bigint | null;
    int8_coins: bigint | null;
    int42_int: bigint | null;
    int42_int8: bigint | null;
    int42_int42: bigint | null;
    int42_int256: bigint | null;
    int42_uint8: bigint | null;
    int42_uint42: bigint | null;
    int42_uint256: bigint | null;
    int42_coins: bigint | null;
    int256_int: bigint | null;
    int256_int8: bigint | null;
    int256_int42: bigint | null;
    int256_int256: bigint | null;
    int256_uint8: bigint | null;
    int256_uint42: bigint | null;
    int256_uint256: bigint | null;
    int256_coins: bigint | null;
    uint8_int: bigint | null;
    uint8_int8: bigint | null;
    uint8_int42: bigint | null;
    uint8_int256: bigint | null;
    uint8_uint8: bigint | null;
    uint8_uint42: bigint | null;
    uint8_uint256: bigint | null;
    uint8_coins: bigint | null;
    uint42_int: bigint | null;
    uint42_int8: bigint | null;
    uint42_int42: bigint | null;
    uint42_int256: bigint | null;
    uint42_uint8: bigint | null;
    uint42_uint42: bigint | null;
    uint42_uint256: bigint | null;
    uint42_coins: bigint | null;
    uint256_int: bigint | null;
    uint256_int8: bigint | null;
    uint256_int42: bigint | null;
    uint256_int256: bigint | null;
    uint256_uint8: bigint | null;
    uint256_uint42: bigint | null;
    uint256_uint256: bigint | null;
    uint256_coins: bigint | null;
    address_int: bigint | null;
    address_int8: bigint | null;
    address_int42: bigint | null;
    address_int256: bigint | null;
    address_uint8: bigint | null;
    address_uint42: bigint | null;
    address_uint256: bigint | null;
    address_coins: bigint | null;
};
export type ExistsAllMapsResult = {
    $$type: 'ExistsAllMapsResult';
    int_int: boolean;
    int_int8: boolean;
    int_int42: boolean;
    int_int256: boolean;
    int_uint8: boolean;
    int_uint42: boolean;
    int_uint256: boolean;
    int_coins: boolean;
    int8_int: boolean;
    int8_int8: boolean;
    int8_int42: boolean;
    int8_int256: boolean;
    int8_uint8: boolean;
    int8_uint42: boolean;
    int8_uint256: boolean;
    int8_coins: boolean;
    int42_int: boolean;
    int42_int8: boolean;
    int42_int42: boolean;
    int42_int256: boolean;
    int42_uint8: boolean;
    int42_uint42: boolean;
    int42_uint256: boolean;
    int42_coins: boolean;
    int256_int: boolean;
    int256_int8: boolean;
    int256_int42: boolean;
    int256_int256: boolean;
    int256_uint8: boolean;
    int256_uint42: boolean;
    int256_uint256: boolean;
    int256_coins: boolean;
    uint8_int: boolean;
    uint8_int8: boolean;
    uint8_int42: boolean;
    uint8_int256: boolean;
    uint8_uint8: boolean;
    uint8_uint42: boolean;
    uint8_uint256: boolean;
    uint8_coins: boolean;
    uint42_int: boolean;
    uint42_int8: boolean;
    uint42_int42: boolean;
    uint42_int256: boolean;
    uint42_uint8: boolean;
    uint42_uint42: boolean;
    uint42_uint256: boolean;
    uint42_coins: boolean;
    uint256_int: boolean;
    uint256_int8: boolean;
    uint256_int42: boolean;
    uint256_int256: boolean;
    uint256_uint8: boolean;
    uint256_uint42: boolean;
    uint256_uint256: boolean;
    uint256_coins: boolean;
    address_int: boolean;
    address_int8: boolean;
    address_int42: boolean;
    address_int256: boolean;
    address_uint8: boolean;
    address_uint42: boolean;
    address_uint256: boolean;
    address_coins: boolean;
};
export declare function storeExistsAllMapsResult(src: ExistsAllMapsResult): (builder: Builder) => void;
export declare function loadExistsAllMapsResult(slice: Slice): {
    $$type: "ExistsAllMapsResult";
    int_int: boolean;
    int_int8: boolean;
    int_int42: boolean;
    int_int256: boolean;
    int_uint8: boolean;
    int_uint42: boolean;
    int_uint256: boolean;
    int_coins: boolean;
    int8_int: boolean;
    int8_int8: boolean;
    int8_int42: boolean;
    int8_int256: boolean;
    int8_uint8: boolean;
    int8_uint42: boolean;
    int8_uint256: boolean;
    int8_coins: boolean;
    int42_int: boolean;
    int42_int8: boolean;
    int42_int42: boolean;
    int42_int256: boolean;
    int42_uint8: boolean;
    int42_uint42: boolean;
    int42_uint256: boolean;
    int42_coins: boolean;
    int256_int: boolean;
    int256_int8: boolean;
    int256_int42: boolean;
    int256_int256: boolean;
    int256_uint8: boolean;
    int256_uint42: boolean;
    int256_uint256: boolean;
    int256_coins: boolean;
    uint8_int: boolean;
    uint8_int8: boolean;
    uint8_int42: boolean;
    uint8_int256: boolean;
    uint8_uint8: boolean;
    uint8_uint42: boolean;
    uint8_uint256: boolean;
    uint8_coins: boolean;
    uint42_int: boolean;
    uint42_int8: boolean;
    uint42_int42: boolean;
    uint42_int256: boolean;
    uint42_uint8: boolean;
    uint42_uint42: boolean;
    uint42_uint256: boolean;
    uint42_coins: boolean;
    uint256_int: boolean;
    uint256_int8: boolean;
    uint256_int42: boolean;
    uint256_int256: boolean;
    uint256_uint8: boolean;
    uint256_uint42: boolean;
    uint256_uint256: boolean;
    uint256_coins: boolean;
    address_int: boolean;
    address_int8: boolean;
    address_int42: boolean;
    address_int256: boolean;
    address_uint8: boolean;
    address_uint42: boolean;
    address_uint256: boolean;
    address_coins: boolean;
};
export type IsEmptyAllMapsResult = {
    $$type: 'IsEmptyAllMapsResult';
    int_int: boolean;
    int_int8: boolean;
    int_int42: boolean;
    int_int256: boolean;
    int_uint8: boolean;
    int_uint42: boolean;
    int_uint256: boolean;
    int_coins: boolean;
    int8_int: boolean;
    int8_int8: boolean;
    int8_int42: boolean;
    int8_int256: boolean;
    int8_uint8: boolean;
    int8_uint42: boolean;
    int8_uint256: boolean;
    int8_coins: boolean;
    int42_int: boolean;
    int42_int8: boolean;
    int42_int42: boolean;
    int42_int256: boolean;
    int42_uint8: boolean;
    int42_uint42: boolean;
    int42_uint256: boolean;
    int42_coins: boolean;
    int256_int: boolean;
    int256_int8: boolean;
    int256_int42: boolean;
    int256_int256: boolean;
    int256_uint8: boolean;
    int256_uint42: boolean;
    int256_uint256: boolean;
    int256_coins: boolean;
    uint8_int: boolean;
    uint8_int8: boolean;
    uint8_int42: boolean;
    uint8_int256: boolean;
    uint8_uint8: boolean;
    uint8_uint42: boolean;
    uint8_uint256: boolean;
    uint8_coins: boolean;
    uint42_int: boolean;
    uint42_int8: boolean;
    uint42_int42: boolean;
    uint42_int256: boolean;
    uint42_uint8: boolean;
    uint42_uint42: boolean;
    uint42_uint256: boolean;
    uint42_coins: boolean;
    uint256_int: boolean;
    uint256_int8: boolean;
    uint256_int42: boolean;
    uint256_int256: boolean;
    uint256_uint8: boolean;
    uint256_uint42: boolean;
    uint256_uint256: boolean;
    uint256_coins: boolean;
    address_int: boolean;
    address_int8: boolean;
    address_int42: boolean;
    address_int256: boolean;
    address_uint8: boolean;
    address_uint42: boolean;
    address_uint256: boolean;
    address_coins: boolean;
};
export declare function storeIsEmptyAllMapsResult(src: IsEmptyAllMapsResult): (builder: Builder) => void;
export declare function loadIsEmptyAllMapsResult(slice: Slice): {
    $$type: "IsEmptyAllMapsResult";
    int_int: boolean;
    int_int8: boolean;
    int_int42: boolean;
    int_int256: boolean;
    int_uint8: boolean;
    int_uint42: boolean;
    int_uint256: boolean;
    int_coins: boolean;
    int8_int: boolean;
    int8_int8: boolean;
    int8_int42: boolean;
    int8_int256: boolean;
    int8_uint8: boolean;
    int8_uint42: boolean;
    int8_uint256: boolean;
    int8_coins: boolean;
    int42_int: boolean;
    int42_int8: boolean;
    int42_int42: boolean;
    int42_int256: boolean;
    int42_uint8: boolean;
    int42_uint42: boolean;
    int42_uint256: boolean;
    int42_coins: boolean;
    int256_int: boolean;
    int256_int8: boolean;
    int256_int42: boolean;
    int256_int256: boolean;
    int256_uint8: boolean;
    int256_uint42: boolean;
    int256_uint256: boolean;
    int256_coins: boolean;
    uint8_int: boolean;
    uint8_int8: boolean;
    uint8_int42: boolean;
    uint8_int256: boolean;
    uint8_uint8: boolean;
    uint8_uint42: boolean;
    uint8_uint256: boolean;
    uint8_coins: boolean;
    uint42_int: boolean;
    uint42_int8: boolean;
    uint42_int42: boolean;
    uint42_int256: boolean;
    uint42_uint8: boolean;
    uint42_uint42: boolean;
    uint42_uint256: boolean;
    uint42_coins: boolean;
    uint256_int: boolean;
    uint256_int8: boolean;
    uint256_int42: boolean;
    uint256_int256: boolean;
    uint256_uint8: boolean;
    uint256_uint42: boolean;
    uint256_uint256: boolean;
    uint256_coins: boolean;
    address_int: boolean;
    address_int8: boolean;
    address_int42: boolean;
    address_int256: boolean;
    address_uint8: boolean;
    address_uint42: boolean;
    address_uint256: boolean;
    address_coins: boolean;
};
export type AsCellAllMapsResult = {
    $$type: 'AsCellAllMapsResult';
    int_int: Cell | null;
    int_int8: Cell | null;
    int_int42: Cell | null;
    int_int256: Cell | null;
    int_uint8: Cell | null;
    int_uint42: Cell | null;
    int_uint256: Cell | null;
    int_coins: Cell | null;
    int8_int: Cell | null;
    int8_int8: Cell | null;
    int8_int42: Cell | null;
    int8_int256: Cell | null;
    int8_uint8: Cell | null;
    int8_uint42: Cell | null;
    int8_uint256: Cell | null;
    int8_coins: Cell | null;
    int42_int: Cell | null;
    int42_int8: Cell | null;
    int42_int42: Cell | null;
    int42_int256: Cell | null;
    int42_uint8: Cell | null;
    int42_uint42: Cell | null;
    int42_uint256: Cell | null;
    int42_coins: Cell | null;
    int256_int: Cell | null;
    int256_int8: Cell | null;
    int256_int42: Cell | null;
    int256_int256: Cell | null;
    int256_uint8: Cell | null;
    int256_uint42: Cell | null;
    int256_uint256: Cell | null;
    int256_coins: Cell | null;
    uint8_int: Cell | null;
    uint8_int8: Cell | null;
    uint8_int42: Cell | null;
    uint8_int256: Cell | null;
    uint8_uint8: Cell | null;
    uint8_uint42: Cell | null;
    uint8_uint256: Cell | null;
    uint8_coins: Cell | null;
    uint42_int: Cell | null;
    uint42_int8: Cell | null;
    uint42_int42: Cell | null;
    uint42_int256: Cell | null;
    uint42_uint8: Cell | null;
    uint42_uint42: Cell | null;
    uint42_uint256: Cell | null;
    uint42_coins: Cell | null;
    uint256_int: Cell | null;
    uint256_int8: Cell | null;
    uint256_int42: Cell | null;
    uint256_int256: Cell | null;
    uint256_uint8: Cell | null;
    uint256_uint42: Cell | null;
    uint256_uint256: Cell | null;
    uint256_coins: Cell | null;
    address_int: Cell | null;
    address_int8: Cell | null;
    address_int42: Cell | null;
    address_int256: Cell | null;
    address_uint8: Cell | null;
    address_uint42: Cell | null;
    address_uint256: Cell | null;
    address_coins: Cell | null;
};
export declare function storeAsCellAllMapsResult(src: AsCellAllMapsResult): (builder: Builder) => void;
export declare function loadAsCellAllMapsResult(slice: Slice): {
    $$type: "AsCellAllMapsResult";
    int_int: Cell | null;
    int_int8: Cell | null;
    int_int42: Cell | null;
    int_int256: Cell | null;
    int_uint8: Cell | null;
    int_uint42: Cell | null;
    int_uint256: Cell | null;
    int_coins: Cell | null;
    int8_int: Cell | null;
    int8_int8: Cell | null;
    int8_int42: Cell | null;
    int8_int256: Cell | null;
    int8_uint8: Cell | null;
    int8_uint42: Cell | null;
    int8_uint256: Cell | null;
    int8_coins: Cell | null;
    int42_int: Cell | null;
    int42_int8: Cell | null;
    int42_int42: Cell | null;
    int42_int256: Cell | null;
    int42_uint8: Cell | null;
    int42_uint42: Cell | null;
    int42_uint256: Cell | null;
    int42_coins: Cell | null;
    int256_int: Cell | null;
    int256_int8: Cell | null;
    int256_int42: Cell | null;
    int256_int256: Cell | null;
    int256_uint8: Cell | null;
    int256_uint42: Cell | null;
    int256_uint256: Cell | null;
    int256_coins: Cell | null;
    uint8_int: Cell | null;
    uint8_int8: Cell | null;
    uint8_int42: Cell | null;
    uint8_int256: Cell | null;
    uint8_uint8: Cell | null;
    uint8_uint42: Cell | null;
    uint8_uint256: Cell | null;
    uint8_coins: Cell | null;
    uint42_int: Cell | null;
    uint42_int8: Cell | null;
    uint42_int42: Cell | null;
    uint42_int256: Cell | null;
    uint42_uint8: Cell | null;
    uint42_uint42: Cell | null;
    uint42_uint256: Cell | null;
    uint42_coins: Cell | null;
    uint256_int: Cell | null;
    uint256_int8: Cell | null;
    uint256_int42: Cell | null;
    uint256_int256: Cell | null;
    uint256_uint8: Cell | null;
    uint256_uint42: Cell | null;
    uint256_uint256: Cell | null;
    uint256_coins: Cell | null;
    address_int: Cell | null;
    address_int8: Cell | null;
    address_int42: Cell | null;
    address_int256: Cell | null;
    address_uint8: Cell | null;
    address_uint42: Cell | null;
    address_uint256: Cell | null;
    address_coins: Cell | null;
};
export type SetAllMaps = {
    $$type: 'SetAllMaps';
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueInt: bigint | null;
    valueInt8: bigint | null;
    valueInt42: bigint | null;
    valueInt256: bigint | null;
    valueUint8: bigint | null;
    valueUint42: bigint | null;
    valueUint256: bigint | null;
    valueCoins: bigint | null;
};
export declare function storeSetAllMaps(src: SetAllMaps): (builder: Builder) => void;
export declare function loadSetAllMaps(slice: Slice): {
    $$type: "SetAllMaps";
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueInt: bigint | null;
    valueInt8: bigint | null;
    valueInt42: bigint | null;
    valueInt256: bigint | null;
    valueUint8: bigint | null;
    valueUint42: bigint | null;
    valueUint256: bigint | null;
    valueCoins: bigint | null;
};
export type DelAllMaps = {
    $$type: 'DelAllMaps';
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
};
export declare function storeDelAllMaps(src: DelAllMaps): (builder: Builder) => void;
export declare function loadDelAllMaps(slice: Slice): {
    $$type: "DelAllMaps";
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
};
export type ReplaceAllMaps = {
    $$type: 'ReplaceAllMaps';
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueInt: bigint | null;
    valueInt8: bigint | null;
    valueInt42: bigint | null;
    valueInt256: bigint | null;
    valueUint8: bigint | null;
    valueUint42: bigint | null;
    valueUint256: bigint | null;
    valueCoins: bigint | null;
};
export declare function storeReplaceAllMaps(src: ReplaceAllMaps): (builder: Builder) => void;
export declare function loadReplaceAllMaps(slice: Slice): {
    $$type: "ReplaceAllMaps";
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueInt: bigint | null;
    valueInt8: bigint | null;
    valueInt42: bigint | null;
    valueInt256: bigint | null;
    valueUint8: bigint | null;
    valueUint42: bigint | null;
    valueUint256: bigint | null;
    valueCoins: bigint | null;
};
export type ReplaceGetAllMaps = {
    $$type: 'ReplaceGetAllMaps';
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueInt: bigint | null;
    valueInt8: bigint | null;
    valueInt42: bigint | null;
    valueInt256: bigint | null;
    valueUint8: bigint | null;
    valueUint42: bigint | null;
    valueUint256: bigint | null;
    valueCoins: bigint | null;
};
export declare function storeReplaceGetAllMaps(src: ReplaceGetAllMaps): (builder: Builder) => void;
export declare function loadReplaceGetAllMaps(slice: Slice): {
    $$type: "ReplaceGetAllMaps";
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueInt: bigint | null;
    valueInt8: bigint | null;
    valueInt42: bigint | null;
    valueInt256: bigint | null;
    valueUint8: bigint | null;
    valueUint42: bigint | null;
    valueUint256: bigint | null;
    valueCoins: bigint | null;
};
export type CheckNullReference = {
    $$type: 'CheckNullReference';
};
export declare function storeCheckNullReference(src: CheckNullReference): (builder: Builder) => void;
export declare function loadCheckNullReference(slice: Slice): {
    $$type: "CheckNullReference";
};
export type MapTestContract$Data = {
    $$type: 'MapTestContract$Data';
    int_int: Dictionary<bigint, bigint>;
    int_int8: Dictionary<bigint, number>;
    int_int42: Dictionary<bigint, bigint>;
    int_int256: Dictionary<bigint, bigint>;
    int_uint8: Dictionary<bigint, number>;
    int_uint42: Dictionary<bigint, bigint>;
    int_uint256: Dictionary<bigint, bigint>;
    int_coins: Dictionary<bigint, bigint>;
    int8_int: Dictionary<number, bigint>;
    int8_int8: Dictionary<number, number>;
    int8_int42: Dictionary<number, bigint>;
    int8_int256: Dictionary<number, bigint>;
    int8_uint8: Dictionary<number, number>;
    int8_uint42: Dictionary<number, bigint>;
    int8_uint256: Dictionary<number, bigint>;
    int8_coins: Dictionary<number, bigint>;
    int42_int: Dictionary<bigint, bigint>;
    int42_int8: Dictionary<bigint, number>;
    int42_int42: Dictionary<bigint, bigint>;
    int42_int256: Dictionary<bigint, bigint>;
    int42_uint8: Dictionary<bigint, number>;
    int42_uint42: Dictionary<bigint, bigint>;
    int42_uint256: Dictionary<bigint, bigint>;
    int42_coins: Dictionary<bigint, bigint>;
    int256_int: Dictionary<bigint, bigint>;
    int256_int8: Dictionary<bigint, number>;
    int256_int42: Dictionary<bigint, bigint>;
    int256_int256: Dictionary<bigint, bigint>;
    int256_uint8: Dictionary<bigint, number>;
    int256_uint42: Dictionary<bigint, bigint>;
    int256_uint256: Dictionary<bigint, bigint>;
    int256_coins: Dictionary<bigint, bigint>;
    uint8_int: Dictionary<number, bigint>;
    uint8_int8: Dictionary<number, number>;
    uint8_int42: Dictionary<number, bigint>;
    uint8_int256: Dictionary<number, bigint>;
    uint8_uint8: Dictionary<number, number>;
    uint8_uint42: Dictionary<number, bigint>;
    uint8_uint256: Dictionary<number, bigint>;
    uint8_coins: Dictionary<number, bigint>;
    uint42_int: Dictionary<bigint, bigint>;
    uint42_int8: Dictionary<bigint, number>;
    uint42_int42: Dictionary<bigint, bigint>;
    uint42_int256: Dictionary<bigint, bigint>;
    uint42_uint8: Dictionary<bigint, number>;
    uint42_uint42: Dictionary<bigint, bigint>;
    uint42_uint256: Dictionary<bigint, bigint>;
    uint42_coins: Dictionary<bigint, bigint>;
    uint256_int: Dictionary<bigint, bigint>;
    uint256_int8: Dictionary<bigint, number>;
    uint256_int42: Dictionary<bigint, bigint>;
    uint256_int256: Dictionary<bigint, bigint>;
    uint256_uint8: Dictionary<bigint, number>;
    uint256_uint42: Dictionary<bigint, bigint>;
    uint256_uint256: Dictionary<bigint, bigint>;
    uint256_coins: Dictionary<bigint, bigint>;
    address_int: Dictionary<Address, bigint>;
    address_int8: Dictionary<Address, number>;
    address_int42: Dictionary<Address, bigint>;
    address_int256: Dictionary<Address, bigint>;
    address_uint8: Dictionary<Address, number>;
    address_uint42: Dictionary<Address, bigint>;
    address_uint256: Dictionary<Address, bigint>;
    address_coins: Dictionary<Address, bigint>;
};
export declare function storeMapTestContract$Data(src: MapTestContract$Data): (builder: Builder) => void;
export declare function loadMapTestContract$Data(slice: Slice): {
    $$type: "MapTestContract$Data";
    int_int: Dictionary<bigint, bigint>;
    int_int8: Dictionary<bigint, number>;
    int_int42: Dictionary<bigint, bigint>;
    int_int256: Dictionary<bigint, bigint>;
    int_uint8: Dictionary<bigint, number>;
    int_uint42: Dictionary<bigint, bigint>;
    int_uint256: Dictionary<bigint, bigint>;
    int_coins: Dictionary<bigint, bigint>;
    int8_int: Dictionary<number, bigint>;
    int8_int8: Dictionary<number, number>;
    int8_int42: Dictionary<number, bigint>;
    int8_int256: Dictionary<number, bigint>;
    int8_uint8: Dictionary<number, number>;
    int8_uint42: Dictionary<number, bigint>;
    int8_uint256: Dictionary<number, bigint>;
    int8_coins: Dictionary<number, bigint>;
    int42_int: Dictionary<bigint, bigint>;
    int42_int8: Dictionary<bigint, number>;
    int42_int42: Dictionary<bigint, bigint>;
    int42_int256: Dictionary<bigint, bigint>;
    int42_uint8: Dictionary<bigint, number>;
    int42_uint42: Dictionary<bigint, bigint>;
    int42_uint256: Dictionary<bigint, bigint>;
    int42_coins: Dictionary<bigint, bigint>;
    int256_int: Dictionary<bigint, bigint>;
    int256_int8: Dictionary<bigint, number>;
    int256_int42: Dictionary<bigint, bigint>;
    int256_int256: Dictionary<bigint, bigint>;
    int256_uint8: Dictionary<bigint, number>;
    int256_uint42: Dictionary<bigint, bigint>;
    int256_uint256: Dictionary<bigint, bigint>;
    int256_coins: Dictionary<bigint, bigint>;
    uint8_int: Dictionary<number, bigint>;
    uint8_int8: Dictionary<number, number>;
    uint8_int42: Dictionary<number, bigint>;
    uint8_int256: Dictionary<number, bigint>;
    uint8_uint8: Dictionary<number, number>;
    uint8_uint42: Dictionary<number, bigint>;
    uint8_uint256: Dictionary<number, bigint>;
    uint8_coins: Dictionary<number, bigint>;
    uint42_int: Dictionary<bigint, bigint>;
    uint42_int8: Dictionary<bigint, number>;
    uint42_int42: Dictionary<bigint, bigint>;
    uint42_int256: Dictionary<bigint, bigint>;
    uint42_uint8: Dictionary<bigint, number>;
    uint42_uint42: Dictionary<bigint, bigint>;
    uint42_uint256: Dictionary<bigint, bigint>;
    uint42_coins: Dictionary<bigint, bigint>;
    uint256_int: Dictionary<bigint, bigint>;
    uint256_int8: Dictionary<bigint, number>;
    uint256_int42: Dictionary<bigint, bigint>;
    uint256_int256: Dictionary<bigint, bigint>;
    uint256_uint8: Dictionary<bigint, number>;
    uint256_uint42: Dictionary<bigint, bigint>;
    uint256_uint256: Dictionary<bigint, bigint>;
    uint256_coins: Dictionary<bigint, bigint>;
    address_int: Dictionary<Address, bigint>;
    address_int8: Dictionary<Address, number>;
    address_int42: Dictionary<Address, bigint>;
    address_int256: Dictionary<Address, bigint>;
    address_uint8: Dictionary<Address, number>;
    address_uint42: Dictionary<Address, bigint>;
    address_uint256: Dictionary<Address, bigint>;
    address_coins: Dictionary<Address, bigint>;
};
export declare const MapTestContract_getterMapping: {
    [key: string]: string;
};
export declare class MapTestContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapTestContract>;
    static fromAddress(address: Address): MapTestContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | SetAllMaps | DelAllMaps | ReplaceAllMaps | ReplaceGetAllMaps | CheckNullReference): Promise<void>;
    getAllMaps(provider: ContractProvider): Promise<{
        $$type: "MapTestContract$Data";
        int_int: Dictionary<bigint, bigint>;
        int_int8: Dictionary<bigint, number>;
        int_int42: Dictionary<bigint, bigint>;
        int_int256: Dictionary<bigint, bigint>;
        int_uint8: Dictionary<bigint, number>;
        int_uint42: Dictionary<bigint, bigint>;
        int_uint256: Dictionary<bigint, bigint>;
        int_coins: Dictionary<bigint, bigint>;
        int8_int: Dictionary<number, bigint>;
        int8_int8: Dictionary<number, number>;
        int8_int42: Dictionary<number, bigint>;
        int8_int256: Dictionary<number, bigint>;
        int8_uint8: Dictionary<number, number>;
        int8_uint42: Dictionary<number, bigint>;
        int8_uint256: Dictionary<number, bigint>;
        int8_coins: Dictionary<number, bigint>;
        int42_int: Dictionary<bigint, bigint>;
        int42_int8: Dictionary<bigint, number>;
        int42_int42: Dictionary<bigint, bigint>;
        int42_int256: Dictionary<bigint, bigint>;
        int42_uint8: Dictionary<bigint, number>;
        int42_uint42: Dictionary<bigint, bigint>;
        int42_uint256: Dictionary<bigint, bigint>;
        int42_coins: Dictionary<bigint, bigint>;
        int256_int: Dictionary<bigint, bigint>;
        int256_int8: Dictionary<bigint, number>;
        int256_int42: Dictionary<bigint, bigint>;
        int256_int256: Dictionary<bigint, bigint>;
        int256_uint8: Dictionary<bigint, number>;
        int256_uint42: Dictionary<bigint, bigint>;
        int256_uint256: Dictionary<bigint, bigint>;
        int256_coins: Dictionary<bigint, bigint>;
        uint8_int: Dictionary<number, bigint>;
        uint8_int8: Dictionary<number, number>;
        uint8_int42: Dictionary<number, bigint>;
        uint8_int256: Dictionary<number, bigint>;
        uint8_uint8: Dictionary<number, number>;
        uint8_uint42: Dictionary<number, bigint>;
        uint8_uint256: Dictionary<number, bigint>;
        uint8_coins: Dictionary<number, bigint>;
        uint42_int: Dictionary<bigint, bigint>;
        uint42_int8: Dictionary<bigint, number>;
        uint42_int42: Dictionary<bigint, bigint>;
        uint42_int256: Dictionary<bigint, bigint>;
        uint42_uint8: Dictionary<bigint, number>;
        uint42_uint42: Dictionary<bigint, bigint>;
        uint42_uint256: Dictionary<bigint, bigint>;
        uint42_coins: Dictionary<bigint, bigint>;
        uint256_int: Dictionary<bigint, bigint>;
        uint256_int8: Dictionary<bigint, number>;
        uint256_int42: Dictionary<bigint, bigint>;
        uint256_int256: Dictionary<bigint, bigint>;
        uint256_uint8: Dictionary<bigint, number>;
        uint256_uint42: Dictionary<bigint, bigint>;
        uint256_uint256: Dictionary<bigint, bigint>;
        uint256_coins: Dictionary<bigint, bigint>;
        address_int: Dictionary<Address, bigint>;
        address_int8: Dictionary<Address, number>;
        address_int42: Dictionary<Address, bigint>;
        address_int256: Dictionary<Address, bigint>;
        address_uint8: Dictionary<Address, number>;
        address_uint42: Dictionary<Address, bigint>;
        address_uint256: Dictionary<Address, bigint>;
        address_coins: Dictionary<Address, bigint>;
    }>;
    getGetAllMaps(provider: ContractProvider, keyInt: bigint, keyInt8: bigint, keyInt42: bigint, keyInt256: bigint, keyUint8: bigint, keyUint42: bigint, keyUint256: bigint, keyAddress: Address): Promise<{
        $$type: "GetAllMapsResult";
        int_int: bigint | null;
        int_int8: bigint | null;
        int_int42: bigint | null;
        int_int256: bigint | null;
        int_uint8: bigint | null;
        int_uint42: bigint | null;
        int_uint256: bigint | null;
        int_coins: bigint | null;
        int8_int: bigint | null;
        int8_int8: bigint | null;
        int8_int42: bigint | null;
        int8_int256: bigint | null;
        int8_uint8: bigint | null;
        int8_uint42: bigint | null;
        int8_uint256: bigint | null;
        int8_coins: bigint | null;
        int42_int: bigint | null;
        int42_int8: bigint | null;
        int42_int42: bigint | null;
        int42_int256: bigint | null;
        int42_uint8: bigint | null;
        int42_uint42: bigint | null;
        int42_uint256: bigint | null;
        int42_coins: bigint | null;
        int256_int: bigint | null;
        int256_int8: bigint | null;
        int256_int42: bigint | null;
        int256_int256: bigint | null;
        int256_uint8: bigint | null;
        int256_uint42: bigint | null;
        int256_uint256: bigint | null;
        int256_coins: bigint | null;
        uint8_int: bigint | null;
        uint8_int8: bigint | null;
        uint8_int42: bigint | null;
        uint8_int256: bigint | null;
        uint8_uint8: bigint | null;
        uint8_uint42: bigint | null;
        uint8_uint256: bigint | null;
        uint8_coins: bigint | null;
        uint42_int: bigint | null;
        uint42_int8: bigint | null;
        uint42_int42: bigint | null;
        uint42_int256: bigint | null;
        uint42_uint8: bigint | null;
        uint42_uint42: bigint | null;
        uint42_uint256: bigint | null;
        uint42_coins: bigint | null;
        uint256_int: bigint | null;
        uint256_int8: bigint | null;
        uint256_int42: bigint | null;
        uint256_int256: bigint | null;
        uint256_uint8: bigint | null;
        uint256_uint42: bigint | null;
        uint256_uint256: bigint | null;
        uint256_coins: bigint | null;
        address_int: bigint | null;
        address_int8: bigint | null;
        address_int42: bigint | null;
        address_int256: bigint | null;
        address_uint8: bigint | null;
        address_uint42: bigint | null;
        address_uint256: bigint | null;
        address_coins: bigint | null;
    }>;
    getReplaceAllMaps(provider: ContractProvider, keyInt: bigint, keyInt8: bigint, keyInt42: bigint, keyInt256: bigint, keyUint8: bigint, keyUint42: bigint, keyUint256: bigint, keyAddress: Address, valueInt: bigint, valueInt8: bigint, valueInt42: bigint, valueInt256: bigint, valueUint8: bigint, valueUint42: bigint, valueUint256: bigint, valueCoins: bigint): Promise<{
        $$type: "ReplaceAllMapsResult";
        int_int: boolean;
        int_int8: boolean;
        int_int42: boolean;
        int_int256: boolean;
        int_uint8: boolean;
        int_uint42: boolean;
        int_uint256: boolean;
        int_coins: boolean;
        int8_int: boolean;
        int8_int8: boolean;
        int8_int42: boolean;
        int8_int256: boolean;
        int8_uint8: boolean;
        int8_uint42: boolean;
        int8_uint256: boolean;
        int8_coins: boolean;
        int42_int: boolean;
        int42_int8: boolean;
        int42_int42: boolean;
        int42_int256: boolean;
        int42_uint8: boolean;
        int42_uint42: boolean;
        int42_uint256: boolean;
        int42_coins: boolean;
        int256_int: boolean;
        int256_int8: boolean;
        int256_int42: boolean;
        int256_int256: boolean;
        int256_uint8: boolean;
        int256_uint42: boolean;
        int256_uint256: boolean;
        int256_coins: boolean;
        uint8_int: boolean;
        uint8_int8: boolean;
        uint8_int42: boolean;
        uint8_int256: boolean;
        uint8_uint8: boolean;
        uint8_uint42: boolean;
        uint8_uint256: boolean;
        uint8_coins: boolean;
        uint42_int: boolean;
        uint42_int8: boolean;
        uint42_int42: boolean;
        uint42_int256: boolean;
        uint42_uint8: boolean;
        uint42_uint42: boolean;
        uint42_uint256: boolean;
        uint42_coins: boolean;
        uint256_int: boolean;
        uint256_int8: boolean;
        uint256_int42: boolean;
        uint256_int256: boolean;
        uint256_uint8: boolean;
        uint256_uint42: boolean;
        uint256_uint256: boolean;
        uint256_coins: boolean;
        address_int: boolean;
        address_int8: boolean;
        address_int42: boolean;
        address_int256: boolean;
        address_uint8: boolean;
        address_uint42: boolean;
        address_uint256: boolean;
        address_coins: boolean;
    }>;
    getReplaceGetAllMaps(provider: ContractProvider, keyInt: bigint, keyInt8: bigint, keyInt42: bigint, keyInt256: bigint, keyUint8: bigint, keyUint42: bigint, keyUint256: bigint, keyAddress: Address, valueInt: bigint, valueInt8: bigint, valueInt42: bigint, valueInt256: bigint, valueUint8: bigint, valueUint42: bigint, valueUint256: bigint, valueCoins: bigint): Promise<{
        $$type: "ReplaceGetAllMapsResult";
        int_int: bigint | null;
        int_int8: bigint | null;
        int_int42: bigint | null;
        int_int256: bigint | null;
        int_uint8: bigint | null;
        int_uint42: bigint | null;
        int_uint256: bigint | null;
        int_coins: bigint | null;
        int8_int: bigint | null;
        int8_int8: bigint | null;
        int8_int42: bigint | null;
        int8_int256: bigint | null;
        int8_uint8: bigint | null;
        int8_uint42: bigint | null;
        int8_uint256: bigint | null;
        int8_coins: bigint | null;
        int42_int: bigint | null;
        int42_int8: bigint | null;
        int42_int42: bigint | null;
        int42_int256: bigint | null;
        int42_uint8: bigint | null;
        int42_uint42: bigint | null;
        int42_uint256: bigint | null;
        int42_coins: bigint | null;
        int256_int: bigint | null;
        int256_int8: bigint | null;
        int256_int42: bigint | null;
        int256_int256: bigint | null;
        int256_uint8: bigint | null;
        int256_uint42: bigint | null;
        int256_uint256: bigint | null;
        int256_coins: bigint | null;
        uint8_int: bigint | null;
        uint8_int8: bigint | null;
        uint8_int42: bigint | null;
        uint8_int256: bigint | null;
        uint8_uint8: bigint | null;
        uint8_uint42: bigint | null;
        uint8_uint256: bigint | null;
        uint8_coins: bigint | null;
        uint42_int: bigint | null;
        uint42_int8: bigint | null;
        uint42_int42: bigint | null;
        uint42_int256: bigint | null;
        uint42_uint8: bigint | null;
        uint42_uint42: bigint | null;
        uint42_uint256: bigint | null;
        uint42_coins: bigint | null;
        uint256_int: bigint | null;
        uint256_int8: bigint | null;
        uint256_int42: bigint | null;
        uint256_int256: bigint | null;
        uint256_uint8: bigint | null;
        uint256_uint42: bigint | null;
        uint256_uint256: bigint | null;
        uint256_coins: bigint | null;
        address_int: bigint | null;
        address_int8: bigint | null;
        address_int42: bigint | null;
        address_int256: bigint | null;
        address_uint8: bigint | null;
        address_uint42: bigint | null;
        address_uint256: bigint | null;
        address_coins: bigint | null;
    }>;
    getExistsAllMaps(provider: ContractProvider, keyInt: bigint, keyInt8: bigint, keyInt42: bigint, keyInt256: bigint, keyUint8: bigint, keyUint42: bigint, keyUint256: bigint, keyAddress: Address): Promise<{
        $$type: "ExistsAllMapsResult";
        int_int: boolean;
        int_int8: boolean;
        int_int42: boolean;
        int_int256: boolean;
        int_uint8: boolean;
        int_uint42: boolean;
        int_uint256: boolean;
        int_coins: boolean;
        int8_int: boolean;
        int8_int8: boolean;
        int8_int42: boolean;
        int8_int256: boolean;
        int8_uint8: boolean;
        int8_uint42: boolean;
        int8_uint256: boolean;
        int8_coins: boolean;
        int42_int: boolean;
        int42_int8: boolean;
        int42_int42: boolean;
        int42_int256: boolean;
        int42_uint8: boolean;
        int42_uint42: boolean;
        int42_uint256: boolean;
        int42_coins: boolean;
        int256_int: boolean;
        int256_int8: boolean;
        int256_int42: boolean;
        int256_int256: boolean;
        int256_uint8: boolean;
        int256_uint42: boolean;
        int256_uint256: boolean;
        int256_coins: boolean;
        uint8_int: boolean;
        uint8_int8: boolean;
        uint8_int42: boolean;
        uint8_int256: boolean;
        uint8_uint8: boolean;
        uint8_uint42: boolean;
        uint8_uint256: boolean;
        uint8_coins: boolean;
        uint42_int: boolean;
        uint42_int8: boolean;
        uint42_int42: boolean;
        uint42_int256: boolean;
        uint42_uint8: boolean;
        uint42_uint42: boolean;
        uint42_uint256: boolean;
        uint42_coins: boolean;
        uint256_int: boolean;
        uint256_int8: boolean;
        uint256_int42: boolean;
        uint256_int256: boolean;
        uint256_uint8: boolean;
        uint256_uint42: boolean;
        uint256_uint256: boolean;
        uint256_coins: boolean;
        address_int: boolean;
        address_int8: boolean;
        address_int42: boolean;
        address_int256: boolean;
        address_uint8: boolean;
        address_uint42: boolean;
        address_uint256: boolean;
        address_coins: boolean;
    }>;
    getIsEmptyAllMaps(provider: ContractProvider): Promise<{
        $$type: "IsEmptyAllMapsResult";
        int_int: boolean;
        int_int8: boolean;
        int_int42: boolean;
        int_int256: boolean;
        int_uint8: boolean;
        int_uint42: boolean;
        int_uint256: boolean;
        int_coins: boolean;
        int8_int: boolean;
        int8_int8: boolean;
        int8_int42: boolean;
        int8_int256: boolean;
        int8_uint8: boolean;
        int8_uint42: boolean;
        int8_uint256: boolean;
        int8_coins: boolean;
        int42_int: boolean;
        int42_int8: boolean;
        int42_int42: boolean;
        int42_int256: boolean;
        int42_uint8: boolean;
        int42_uint42: boolean;
        int42_uint256: boolean;
        int42_coins: boolean;
        int256_int: boolean;
        int256_int8: boolean;
        int256_int42: boolean;
        int256_int256: boolean;
        int256_uint8: boolean;
        int256_uint42: boolean;
        int256_uint256: boolean;
        int256_coins: boolean;
        uint8_int: boolean;
        uint8_int8: boolean;
        uint8_int42: boolean;
        uint8_int256: boolean;
        uint8_uint8: boolean;
        uint8_uint42: boolean;
        uint8_uint256: boolean;
        uint8_coins: boolean;
        uint42_int: boolean;
        uint42_int8: boolean;
        uint42_int42: boolean;
        uint42_int256: boolean;
        uint42_uint8: boolean;
        uint42_uint42: boolean;
        uint42_uint256: boolean;
        uint42_coins: boolean;
        uint256_int: boolean;
        uint256_int8: boolean;
        uint256_int42: boolean;
        uint256_int256: boolean;
        uint256_uint8: boolean;
        uint256_uint42: boolean;
        uint256_uint256: boolean;
        uint256_coins: boolean;
        address_int: boolean;
        address_int8: boolean;
        address_int42: boolean;
        address_int256: boolean;
        address_uint8: boolean;
        address_uint42: boolean;
        address_uint256: boolean;
        address_coins: boolean;
    }>;
    getAsCellAllMaps(provider: ContractProvider): Promise<{
        $$type: "AsCellAllMapsResult";
        int_int: Cell | null;
        int_int8: Cell | null;
        int_int42: Cell | null;
        int_int256: Cell | null;
        int_uint8: Cell | null;
        int_uint42: Cell | null;
        int_uint256: Cell | null;
        int_coins: Cell | null;
        int8_int: Cell | null;
        int8_int8: Cell | null;
        int8_int42: Cell | null;
        int8_int256: Cell | null;
        int8_uint8: Cell | null;
        int8_uint42: Cell | null;
        int8_uint256: Cell | null;
        int8_coins: Cell | null;
        int42_int: Cell | null;
        int42_int8: Cell | null;
        int42_int42: Cell | null;
        int42_int256: Cell | null;
        int42_uint8: Cell | null;
        int42_uint42: Cell | null;
        int42_uint256: Cell | null;
        int42_coins: Cell | null;
        int256_int: Cell | null;
        int256_int8: Cell | null;
        int256_int42: Cell | null;
        int256_int256: Cell | null;
        int256_uint8: Cell | null;
        int256_uint42: Cell | null;
        int256_uint256: Cell | null;
        int256_coins: Cell | null;
        uint8_int: Cell | null;
        uint8_int8: Cell | null;
        uint8_int42: Cell | null;
        uint8_int256: Cell | null;
        uint8_uint8: Cell | null;
        uint8_uint42: Cell | null;
        uint8_uint256: Cell | null;
        uint8_coins: Cell | null;
        uint42_int: Cell | null;
        uint42_int8: Cell | null;
        uint42_int42: Cell | null;
        uint42_int256: Cell | null;
        uint42_uint8: Cell | null;
        uint42_uint42: Cell | null;
        uint42_uint256: Cell | null;
        uint42_coins: Cell | null;
        uint256_int: Cell | null;
        uint256_int8: Cell | null;
        uint256_int42: Cell | null;
        uint256_int256: Cell | null;
        uint256_uint8: Cell | null;
        uint256_uint42: Cell | null;
        uint256_uint256: Cell | null;
        uint256_coins: Cell | null;
        address_int: Cell | null;
        address_int8: Cell | null;
        address_int42: Cell | null;
        address_int256: Cell | null;
        address_uint8: Cell | null;
        address_uint42: Cell | null;
        address_uint256: Cell | null;
        address_coins: Cell | null;
    }>;
    getCheckNullReference(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/masterchain_MasterchainTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/masterchain_MasterchainTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MasterchainTester$Data = {
    $$type: 'MasterchainTester$Data';
};
export declare function storeMasterchainTester$Data(src: MasterchainTester$Data): (builder: Builder) => void;
export declare function loadMasterchainTester$Data(slice: Slice): {
    $$type: "MasterchainTester$Data";
};
export declare const MasterchainTester_getterMapping: {
    [key: string]: string;
};
export declare class MasterchainTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MasterchainTester>;
    static fromAddress(address: Address): MasterchainTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "DeployToWorkchain" | "DeployToMasterchain"): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/math_MathTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/math_MathTester.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type MathTester$Data = {
    $$type: 'MathTester$Data';
};
export declare function storeMathTester$Data(src: MathTester$Data): (builder: Builder) => void;
export declare function loadMathTester$Data(slice: Slice): {
    $$type: "MathTester$Data";
};
export declare const MathTester_getterMapping: {
    [key: string]: string;
};
export declare class MathTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MathTester>;
    static fromAddress(address: Address): MathTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Deploy): Promise<void>;
    getAdd(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getSub(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getMul(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getDiv(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getMod(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getShr(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getShl(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getAnd(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getOr(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getXor(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getBitwiseNot(provider: ContractProvider, a: bigint): Promise<bigint>;
    getAddAug(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getSubAug(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getMulAug(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getDivAug(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getModAug(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getBitwiseOrAug(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getBitwiseAndAug(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getBitwiseXorAug(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getCompare1(provider: ContractProvider, a: bigint, b: bigint | null): Promise<boolean>;
    getCompare2(provider: ContractProvider, a: bigint, b: bigint | null): Promise<boolean>;
    getCompare3(provider: ContractProvider, a: bigint | null, b: bigint): Promise<boolean>;
    getCompare4(provider: ContractProvider, a: bigint | null, b: bigint): Promise<boolean>;
    getCompare5(provider: ContractProvider, a: bigint | null, b: bigint | null): Promise<boolean>;
    getCompare6(provider: ContractProvider, a: bigint | null, b: bigint | null): Promise<boolean>;
    getCompare7(provider: ContractProvider, a: bigint, b: bigint): Promise<boolean>;
    getCompare8(provider: ContractProvider, a: bigint, b: bigint): Promise<boolean>;
    getCompare9(provider: ContractProvider, a: bigint, b: bigint): Promise<boolean>;
    getCompare10(provider: ContractProvider, a: bigint, b: bigint): Promise<boolean>;
    getCompare11(provider: ContractProvider, a: Address, b: Address): Promise<boolean>;
    getCompare12(provider: ContractProvider, a: Address, b: Address | null): Promise<boolean>;
    getCompare13(provider: ContractProvider, a: Address | null, b: Address): Promise<boolean>;
    getCompare14(provider: ContractProvider, a: Address | null, b: Address | null): Promise<boolean>;
    getCompare15(provider: ContractProvider, a: Address, b: Address): Promise<boolean>;
    getCompare16(provider: ContractProvider, a: Address, b: Address | null): Promise<boolean>;
    getCompare17(provider: ContractProvider, a: Address | null, b: Address): Promise<boolean>;
    getCompare18(provider: ContractProvider, a: Address | null, b: Address | null): Promise<boolean>;
    getCompare19(provider: ContractProvider, a: Cell, b: Cell): Promise<boolean>;
    getCompare20(provider: ContractProvider, a: Cell, b: Cell | null): Promise<boolean>;
    getCompare21(provider: ContractProvider, a: Cell | null, b: Cell): Promise<boolean>;
    getCompare22(provider: ContractProvider, a: Cell | null, b: Cell | null): Promise<boolean>;
    getCompare23(provider: ContractProvider, a: Cell, b: Cell): Promise<boolean>;
    getCompare24(provider: ContractProvider, a: Cell, b: Cell | null): Promise<boolean>;
    getCompare25(provider: ContractProvider, a: Cell | null, b: Cell): Promise<boolean>;
    getCompare26(provider: ContractProvider, a: Cell | null, b: Cell | null): Promise<boolean>;
    getCompare27(provider: ContractProvider, a: Dictionary<bigint, bigint>, b: Dictionary<bigint, bigint>): Promise<boolean>;
    getCompare28(provider: ContractProvider, a: Dictionary<bigint, bigint>, b: Dictionary<bigint, bigint>): Promise<boolean>;
    getCompare29(provider: ContractProvider, a: Slice, b: Slice): Promise<boolean>;
    getCompare30(provider: ContractProvider, a: Slice, b: Slice | null): Promise<boolean>;
    getCompare31(provider: ContractProvider, a: Slice | null, b: Slice): Promise<boolean>;
    getCompare32(provider: ContractProvider, a: Slice | null, b: Slice | null): Promise<boolean>;
    getCompare33(provider: ContractProvider, a: Slice, b: Slice): Promise<boolean>;
    getCompare34(provider: ContractProvider, a: Slice, b: Slice | null): Promise<boolean>;
    getCompare35(provider: ContractProvider, a: Slice | null, b: Slice): Promise<boolean>;
    getCompare36(provider: ContractProvider, a: Slice | null, b: Slice | null): Promise<boolean>;
    getCompare37(provider: ContractProvider, a: string, b: string): Promise<boolean>;
    getCompare38(provider: ContractProvider, a: string, b: string | null): Promise<boolean>;
    getCompare39(provider: ContractProvider, a: string | null, b: string): Promise<boolean>;
    getCompare40(provider: ContractProvider, a: string | null, b: string | null): Promise<boolean>;
    getCompare41(provider: ContractProvider, a: string, b: string): Promise<boolean>;
    getCompare42(provider: ContractProvider, a: string, b: string | null): Promise<boolean>;
    getCompare43(provider: ContractProvider, a: string | null, b: string): Promise<boolean>;
    getCompare44(provider: ContractProvider, a: string | null, b: string | null): Promise<boolean>;
    getIsNull1(provider: ContractProvider, a: bigint | null): Promise<boolean>;
    getIsNotNull1(provider: ContractProvider, a: bigint | null): Promise<boolean>;
    getIsNull2(provider: ContractProvider, address: Address | null): Promise<boolean>;
    getIsNotNull2(provider: ContractProvider, address: Address | null): Promise<boolean>;
    getIsNull3(provider: ContractProvider, cell: Cell | null): Promise<boolean>;
    getIsNotNull3(provider: ContractProvider, cell: Cell | null): Promise<boolean>;
    getLog2(provider: ContractProvider, num: bigint): Promise<bigint>;
    getLog(provider: ContractProvider, num: bigint, base: bigint): Promise<bigint>;
    getPow(provider: ContractProvider, base: bigint, exp: bigint): Promise<bigint>;
    getPow2(provider: ContractProvider, exp: bigint): Promise<bigint>;
    getPrecedence1(provider: ContractProvider): Promise<bigint>;
    getPrecedence2(provider: ContractProvider): Promise<bigint>;
    getPrecedence3(provider: ContractProvider): Promise<bigint>;
    getPrecedence4(provider: ContractProvider): Promise<bigint>;
    getPrecedence5(provider: ContractProvider): Promise<bigint>;
    getPrecedence6(provider: ContractProvider): Promise<bigint>;
    getPrecedence7(provider: ContractProvider): Promise<bigint>;
    getPrecedence8(provider: ContractProvider): Promise<bigint>;
    getPrecedence9(provider: ContractProvider): Promise<bigint>;
    getPrecedence10(provider: ContractProvider): Promise<bigint>;
    getPrecedence11(provider: ContractProvider): Promise<bigint>;
    getPrecedence12(provider: ContractProvider): Promise<bigint>;
    getBitwiseNot1(provider: ContractProvider, x: bigint): Promise<bigint>;
    getBitwiseNot2(provider: ContractProvider, x: bigint): Promise<bigint>;
    getBitwiseNot3(provider: ContractProvider, x: bigint): Promise<bigint>;
    getBitwiseNot4(provider: ContractProvider, x: bigint): Promise<bigint>;
    getAugmentedAnd(provider: ContractProvider, a: boolean, b: boolean): Promise<boolean>;
    getAugmentedOr(provider: ContractProvider, a: boolean, b: boolean): Promise<boolean>;
    getAugmentedShiftLeft(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getAugmentedShiftRight(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/mutating-methods_Tester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/mutating-methods_Tester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Foo = {
    $$type: 'Foo';
    s: Slice;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    s: Slice;
};
export type Tester$Data = {
    $$type: 'Tester$Data';
    s: Slice;
};
export declare function storeTester$Data(src: Tester$Data): (builder: Builder) => void;
export declare function loadTester$Data(slice: Slice): {
    $$type: "Tester$Data";
    s: Slice;
};
export declare const Tester_getterMapping: {
    [key: string]: string;
};
export declare class Tester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Tester>;
    static fromAddress(address: Address): Tester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTest1(provider: ContractProvider): Promise<bigint>;
    getTest2(provider: ContractProvider): Promise<bigint>;
    getTest3(provider: ContractProvider): Promise<bigint>;
    getTest4(provider: ContractProvider): Promise<bigint>;
    getTest5(provider: ContractProvider): Promise<bigint>;
    getTest6(provider: ContractProvider): Promise<void>;
    getTest7(provider: ContractProvider): Promise<bigint>;
    getTest8(provider: ContractProvider): Promise<bigint>;
    getTest9(provider: ContractProvider): Promise<bigint>;
    getTest10(provider: ContractProvider, dict: Cell | null): Promise<Cell | null>;
    getTest11(provider: ContractProvider, x: bigint | null): Promise<bigint | null>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/non-mutating-methods_Tester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/non-mutating-methods_Tester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
};
export type Tester$Data = {
    $$type: 'Tester$Data';
};
export declare function storeTester$Data(src: Tester$Data): (builder: Builder) => void;
export declare function loadTester$Data(slice: Slice): {
    $$type: "Tester$Data";
};
export declare const Tester_getterMapping: {
    [key: string]: string;
};
export declare class Tester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Tester>;
    static fromAddress(address: Address): Tester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTest1(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/optionals_ContractWithOptionals.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/optionals_ContractWithOptionals.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Struct2 = {
    $$type: 'Struct2';
    v: bigint;
};
export declare function storeStruct2(src: Struct2): (builder: Builder) => void;
export declare function loadStruct2(slice: Slice): {
    $$type: "Struct2";
    v: bigint;
};
export type OptStruct = {
    $$type: 'OptStruct';
    s: Struct2 | null;
};
export declare function storeOptStruct(src: OptStruct): (builder: Builder) => void;
export declare function loadOptStruct(slice: Slice): {
    $$type: "OptStruct";
    s: {
        $$type: "Struct2";
        v: bigint;
    } | null;
};
export type Opt2$Data = {
    $$type: 'Opt2$Data';
    stateInit: StateInit;
};
export declare function storeOpt2$Data(src: Opt2$Data): (builder: Builder) => void;
export declare function loadOpt2$Data(slice: Slice): {
    $$type: "Opt2$Data";
    stateInit: {
        $$type: "StateInit";
        code: Cell;
        data: Cell;
    };
};
export type Opt3$Data = {
    $$type: 'Opt3$Data';
};
export declare function storeOpt3$Data(src: Opt3$Data): (builder: Builder) => void;
export declare function loadOpt3$Data(slice: Slice): {
    $$type: "Opt3$Data";
};
export type OptAddr = {
    $$type: 'OptAddr';
    x: bigint;
    y: Address | null;
    z: bigint;
};
export declare function storeOptAddr(src: OptAddr): (builder: Builder) => void;
export declare function loadOptAddr(slice: Slice): {
    $$type: "OptAddr";
    x: bigint;
    y: Address | null;
    z: bigint;
};
export type Opt4$Data = {
    $$type: 'Opt4$Data';
    z: bigint;
};
export declare function storeOpt4$Data(src: Opt4$Data): (builder: Builder) => void;
export declare function loadOpt4$Data(slice: Slice): {
    $$type: "Opt4$Data";
    z: bigint;
};
export type SomeGenericStruct = {
    $$type: 'SomeGenericStruct';
    value1: bigint;
    value2: bigint;
    value3: bigint;
    value4: bigint;
    value5: bigint;
};
export declare function storeSomeGenericStruct(src: SomeGenericStruct): (builder: Builder) => void;
export declare function loadSomeGenericStruct(slice: Slice): {
    $$type: "SomeGenericStruct";
    value1: bigint;
    value2: bigint;
    value3: bigint;
    value4: bigint;
    value5: bigint;
};
export type StructWithOptionals = {
    $$type: 'StructWithOptionals';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
};
export declare function storeStructWithOptionals(src: StructWithOptionals): (builder: Builder) => void;
export declare function loadStructWithOptionals(slice: Slice): {
    $$type: "StructWithOptionals";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
};
export type Update = {
    $$type: 'Update';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
    f: StructWithOptionals | null;
};
export declare function storeUpdate(src: Update): (builder: Builder) => void;
export declare function loadUpdate(slice: Slice): {
    $$type: "Update";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
    f: {
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    } | null;
};
export type ContractWithOptionals$Data = {
    $$type: 'ContractWithOptionals$Data';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
    f: StructWithOptionals | null;
};
export declare function storeContractWithOptionals$Data(src: ContractWithOptionals$Data): (builder: Builder) => void;
export declare function loadContractWithOptionals$Data(slice: Slice): {
    $$type: "ContractWithOptionals$Data";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
    f: {
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    } | null;
};
export declare const ContractWithOptionals_getterMapping: {
    [key: string]: string;
};
export declare class ContractWithOptionals implements Contract {
    static init(a: bigint | null, b: boolean | null, c: Cell | null, d: Address | null, e: SomeGenericStruct | null, f: StructWithOptionals | null): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(a: bigint | null, b: boolean | null, c: Cell | null, d: Address | null, e: SomeGenericStruct | null, f: StructWithOptionals | null): Promise<ContractWithOptionals>;
    static fromAddress(address: Address): ContractWithOptionals;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | Update): Promise<void>;
    getIsNotNullA(provider: ContractProvider): Promise<boolean>;
    getIsNotNullB(provider: ContractProvider): Promise<boolean>;
    getIsNotNullC(provider: ContractProvider): Promise<boolean>;
    getIsNotNullD(provider: ContractProvider): Promise<boolean>;
    getIsNotNullE(provider: ContractProvider): Promise<boolean>;
    getIsNotNullF(provider: ContractProvider): Promise<boolean>;
    getNullA(provider: ContractProvider): Promise<bigint | null>;
    getNullB(provider: ContractProvider): Promise<boolean | null>;
    getNullC(provider: ContractProvider): Promise<Cell | null>;
    getNullD(provider: ContractProvider): Promise<Address | null>;
    getNullE(provider: ContractProvider): Promise<{
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null>;
    getNullF(provider: ContractProvider): Promise<{
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    } | null>;
    getNotNullA(provider: ContractProvider): Promise<bigint>;
    getNotNullB(provider: ContractProvider): Promise<boolean>;
    getNotNullC(provider: ContractProvider): Promise<Cell>;
    getNotNullD(provider: ContractProvider): Promise<Address>;
    getNotNullE(provider: ContractProvider): Promise<{
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    }>;
    getNotNullF(provider: ContractProvider): Promise<{
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    }>;
    getTestVariables(provider: ContractProvider): Promise<{
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    }>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/optionals_Opt2.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/optionals_Opt2.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Struct2 = {
    $$type: 'Struct2';
    v: bigint;
};
export declare function storeStruct2(src: Struct2): (builder: Builder) => void;
export declare function loadStruct2(slice: Slice): {
    $$type: "Struct2";
    v: bigint;
};
export type OptStruct = {
    $$type: 'OptStruct';
    s: Struct2 | null;
};
export declare function storeOptStruct(src: OptStruct): (builder: Builder) => void;
export declare function loadOptStruct(slice: Slice): {
    $$type: "OptStruct";
    s: {
        $$type: "Struct2";
        v: bigint;
    } | null;
};
export type Opt2$Data = {
    $$type: 'Opt2$Data';
    stateInit: StateInit;
};
export declare function storeOpt2$Data(src: Opt2$Data): (builder: Builder) => void;
export declare function loadOpt2$Data(slice: Slice): {
    $$type: "Opt2$Data";
    stateInit: {
        $$type: "StateInit";
        code: Cell;
        data: Cell;
    };
};
export type Opt3$Data = {
    $$type: 'Opt3$Data';
};
export declare function storeOpt3$Data(src: Opt3$Data): (builder: Builder) => void;
export declare function loadOpt3$Data(slice: Slice): {
    $$type: "Opt3$Data";
};
export type OptAddr = {
    $$type: 'OptAddr';
    x: bigint;
    y: Address | null;
    z: bigint;
};
export declare function storeOptAddr(src: OptAddr): (builder: Builder) => void;
export declare function loadOptAddr(slice: Slice): {
    $$type: "OptAddr";
    x: bigint;
    y: Address | null;
    z: bigint;
};
export type Opt4$Data = {
    $$type: 'Opt4$Data';
    z: bigint;
};
export declare function storeOpt4$Data(src: Opt4$Data): (builder: Builder) => void;
export declare function loadOpt4$Data(slice: Slice): {
    $$type: "Opt4$Data";
    z: bigint;
};
export type SomeGenericStruct = {
    $$type: 'SomeGenericStruct';
    value1: bigint;
    value2: bigint;
    value3: bigint;
    value4: bigint;
    value5: bigint;
};
export declare function storeSomeGenericStruct(src: SomeGenericStruct): (builder: Builder) => void;
export declare function loadSomeGenericStruct(slice: Slice): {
    $$type: "SomeGenericStruct";
    value1: bigint;
    value2: bigint;
    value3: bigint;
    value4: bigint;
    value5: bigint;
};
export type StructWithOptionals = {
    $$type: 'StructWithOptionals';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
};
export declare function storeStructWithOptionals(src: StructWithOptionals): (builder: Builder) => void;
export declare function loadStructWithOptionals(slice: Slice): {
    $$type: "StructWithOptionals";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
};
export type Update = {
    $$type: 'Update';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
    f: StructWithOptionals | null;
};
export declare function storeUpdate(src: Update): (builder: Builder) => void;
export declare function loadUpdate(slice: Slice): {
    $$type: "Update";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
    f: {
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    } | null;
};
export type ContractWithOptionals$Data = {
    $$type: 'ContractWithOptionals$Data';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
    f: StructWithOptionals | null;
};
export declare function storeContractWithOptionals$Data(src: ContractWithOptionals$Data): (builder: Builder) => void;
export declare function loadContractWithOptionals$Data(slice: Slice): {
    $$type: "ContractWithOptionals$Data";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
    f: {
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    } | null;
};
export declare const Opt2_getterMapping: {
    [key: string]: string;
};
export declare class Opt2 implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Opt2>;
    static fromAddress(address: Address): Opt2;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "Test"): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/optionals_Opt3.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/optionals_Opt3.d.ts" {
                import { Cell, Slice, Address, Builder, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Struct2 = {
    $$type: 'Struct2';
    v: bigint;
};
export declare function storeStruct2(src: Struct2): (builder: Builder) => void;
export declare function loadStruct2(slice: Slice): {
    $$type: "Struct2";
    v: bigint;
};
export type OptStruct = {
    $$type: 'OptStruct';
    s: Struct2 | null;
};
export declare function storeOptStruct(src: OptStruct): (builder: Builder) => void;
export declare function loadOptStruct(slice: Slice): {
    $$type: "OptStruct";
    s: {
        $$type: "Struct2";
        v: bigint;
    } | null;
};
export type Opt2$Data = {
    $$type: 'Opt2$Data';
    stateInit: StateInit;
};
export declare function storeOpt2$Data(src: Opt2$Data): (builder: Builder) => void;
export declare function loadOpt2$Data(slice: Slice): {
    $$type: "Opt2$Data";
    stateInit: {
        $$type: "StateInit";
        code: Cell;
        data: Cell;
    };
};
export type Opt3$Data = {
    $$type: 'Opt3$Data';
};
export declare function storeOpt3$Data(src: Opt3$Data): (builder: Builder) => void;
export declare function loadOpt3$Data(slice: Slice): {
    $$type: "Opt3$Data";
};
export type OptAddr = {
    $$type: 'OptAddr';
    x: bigint;
    y: Address | null;
    z: bigint;
};
export declare function storeOptAddr(src: OptAddr): (builder: Builder) => void;
export declare function loadOptAddr(slice: Slice): {
    $$type: "OptAddr";
    x: bigint;
    y: Address | null;
    z: bigint;
};
export type Opt4$Data = {
    $$type: 'Opt4$Data';
    z: bigint;
};
export declare function storeOpt4$Data(src: Opt4$Data): (builder: Builder) => void;
export declare function loadOpt4$Data(slice: Slice): {
    $$type: "Opt4$Data";
    z: bigint;
};
export type SomeGenericStruct = {
    $$type: 'SomeGenericStruct';
    value1: bigint;
    value2: bigint;
    value3: bigint;
    value4: bigint;
    value5: bigint;
};
export declare function storeSomeGenericStruct(src: SomeGenericStruct): (builder: Builder) => void;
export declare function loadSomeGenericStruct(slice: Slice): {
    $$type: "SomeGenericStruct";
    value1: bigint;
    value2: bigint;
    value3: bigint;
    value4: bigint;
    value5: bigint;
};
export type StructWithOptionals = {
    $$type: 'StructWithOptionals';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
};
export declare function storeStructWithOptionals(src: StructWithOptionals): (builder: Builder) => void;
export declare function loadStructWithOptionals(slice: Slice): {
    $$type: "StructWithOptionals";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
};
export type Update = {
    $$type: 'Update';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
    f: StructWithOptionals | null;
};
export declare function storeUpdate(src: Update): (builder: Builder) => void;
export declare function loadUpdate(slice: Slice): {
    $$type: "Update";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
    f: {
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    } | null;
};
export type ContractWithOptionals$Data = {
    $$type: 'ContractWithOptionals$Data';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
    f: StructWithOptionals | null;
};
export declare function storeContractWithOptionals$Data(src: ContractWithOptionals$Data): (builder: Builder) => void;
export declare function loadContractWithOptionals$Data(slice: Slice): {
    $$type: "ContractWithOptionals$Data";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
    f: {
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    } | null;
};
export declare const Opt3_getterMapping: {
    [key: string]: string;
};
export declare class Opt3 implements Contract {
    static init(arg: Struct2 | null): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(arg: Struct2 | null): Promise<Opt3>;
    static fromAddress(address: Address): Opt3;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/optionals_Opt4.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/optionals_Opt4.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Struct2 = {
    $$type: 'Struct2';
    v: bigint;
};
export declare function storeStruct2(src: Struct2): (builder: Builder) => void;
export declare function loadStruct2(slice: Slice): {
    $$type: "Struct2";
    v: bigint;
};
export type OptStruct = {
    $$type: 'OptStruct';
    s: Struct2 | null;
};
export declare function storeOptStruct(src: OptStruct): (builder: Builder) => void;
export declare function loadOptStruct(slice: Slice): {
    $$type: "OptStruct";
    s: {
        $$type: "Struct2";
        v: bigint;
    } | null;
};
export type Opt2$Data = {
    $$type: 'Opt2$Data';
    stateInit: StateInit;
};
export declare function storeOpt2$Data(src: Opt2$Data): (builder: Builder) => void;
export declare function loadOpt2$Data(slice: Slice): {
    $$type: "Opt2$Data";
    stateInit: {
        $$type: "StateInit";
        code: Cell;
        data: Cell;
    };
};
export type Opt3$Data = {
    $$type: 'Opt3$Data';
};
export declare function storeOpt3$Data(src: Opt3$Data): (builder: Builder) => void;
export declare function loadOpt3$Data(slice: Slice): {
    $$type: "Opt3$Data";
};
export type OptAddr = {
    $$type: 'OptAddr';
    x: bigint;
    y: Address | null;
    z: bigint;
};
export declare function storeOptAddr(src: OptAddr): (builder: Builder) => void;
export declare function loadOptAddr(slice: Slice): {
    $$type: "OptAddr";
    x: bigint;
    y: Address | null;
    z: bigint;
};
export type Opt4$Data = {
    $$type: 'Opt4$Data';
    z: bigint;
};
export declare function storeOpt4$Data(src: Opt4$Data): (builder: Builder) => void;
export declare function loadOpt4$Data(slice: Slice): {
    $$type: "Opt4$Data";
    z: bigint;
};
export type SomeGenericStruct = {
    $$type: 'SomeGenericStruct';
    value1: bigint;
    value2: bigint;
    value3: bigint;
    value4: bigint;
    value5: bigint;
};
export declare function storeSomeGenericStruct(src: SomeGenericStruct): (builder: Builder) => void;
export declare function loadSomeGenericStruct(slice: Slice): {
    $$type: "SomeGenericStruct";
    value1: bigint;
    value2: bigint;
    value3: bigint;
    value4: bigint;
    value5: bigint;
};
export type StructWithOptionals = {
    $$type: 'StructWithOptionals';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
};
export declare function storeStructWithOptionals(src: StructWithOptionals): (builder: Builder) => void;
export declare function loadStructWithOptionals(slice: Slice): {
    $$type: "StructWithOptionals";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
};
export type Update = {
    $$type: 'Update';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
    f: StructWithOptionals | null;
};
export declare function storeUpdate(src: Update): (builder: Builder) => void;
export declare function loadUpdate(slice: Slice): {
    $$type: "Update";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
    f: {
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    } | null;
};
export type ContractWithOptionals$Data = {
    $$type: 'ContractWithOptionals$Data';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
    f: StructWithOptionals | null;
};
export declare function storeContractWithOptionals$Data(src: ContractWithOptionals$Data): (builder: Builder) => void;
export declare function loadContractWithOptionals$Data(slice: Slice): {
    $$type: "ContractWithOptionals$Data";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
    f: {
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    } | null;
};
export declare const Opt4_getterMapping: {
    [key: string]: string;
};
export declare class Opt4 implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Opt4>;
    static fromAddress(address: Address): Opt4;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | OptAddr): Promise<void>;
    getZ(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/ordering_A.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/ordering_A.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type S = {
    $$type: 'S';
    v1: bigint;
    v2: bigint;
    v3: bigint;
};
export declare function storeS(src: S): (builder: Builder) => void;
export declare function loadS(slice: Slice): {
    $$type: "S";
    v1: bigint;
    v2: bigint;
    v3: bigint;
};
export type A$Data = {
    $$type: 'A$Data';
    owner: Address;
};
export declare function storeA$Data(src: A$Data): (builder: Builder) => void;
export declare function loadA$Data(slice: Slice): {
    $$type: "A$Data";
    owner: Address;
};
export type B$Data = {
    $$type: 'B$Data';
};
export declare function storeB$Data(src: B$Data): (builder: Builder) => void;
export declare function loadB$Data(slice: Slice): {
    $$type: "B$Data";
};
export declare const A_getterMapping: {
    [key: string]: string;
};
export declare class A implements Contract {
    static init(owner: Address): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(owner: Address): Promise<A>;
    static fromAddress(address: Address): A;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Deploy): Promise<void>;
    getCreate(provider: ContractProvider, v: bigint): Promise<{
        $$type: "S";
        v1: bigint;
        v2: bigint;
        v3: bigint;
    }>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/ordering_B.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/ordering_B.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type S = {
    $$type: 'S';
    v1: bigint;
    v2: bigint;
    v3: bigint;
};
export declare function storeS(src: S): (builder: Builder) => void;
export declare function loadS(slice: Slice): {
    $$type: "S";
    v1: bigint;
    v2: bigint;
    v3: bigint;
};
export type A$Data = {
    $$type: 'A$Data';
    owner: Address;
};
export declare function storeA$Data(src: A$Data): (builder: Builder) => void;
export declare function loadA$Data(slice: Slice): {
    $$type: "A$Data";
    owner: Address;
};
export type B$Data = {
    $$type: 'B$Data';
};
export declare function storeB$Data(src: B$Data): (builder: Builder) => void;
export declare function loadB$Data(slice: Slice): {
    $$type: "B$Data";
};
export declare const B_getterMapping: {
    [key: string]: string;
};
export declare class B implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<B>;
    static fromAddress(address: Address): B;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Deploy): Promise<void>;
    getCreate(provider: ContractProvider, v: bigint): Promise<{
        $$type: "S";
        v1: bigint;
        v2: bigint;
        v3: bigint;
    }>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/random_RandomContract.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/random_RandomContract.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type RandomContract$Data = {
    $$type: 'RandomContract$Data';
};
export declare function storeRandomContract$Data(src: RandomContract$Data): (builder: Builder) => void;
export declare function loadRandomContract$Data(slice: Slice): {
    $$type: "RandomContract$Data";
};
export declare const RandomContract_getterMapping: {
    [key: string]: string;
};
export declare class RandomContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<RandomContract>;
    static fromAddress(address: Address): RandomContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Deploy): Promise<void>;
    getRandomInt(provider: ContractProvider): Promise<bigint>;
    getRandom(provider: ContractProvider, min: bigint, max: bigint): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/receiver-empty_Test.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/receiver-empty_Test.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export declare const Test_getterMapping: {
    [key: string]: string;
};
export declare class Test implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Test>;
    static fromAddress(address: Address): Test;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getBalance(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/recursion_RecursionTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/recursion_RecursionTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type RecursionTester$Data = {
    $$type: 'RecursionTester$Data';
};
export declare function storeRecursionTester$Data(src: RecursionTester$Data): (builder: Builder) => void;
export declare function loadRecursionTester$Data(slice: Slice): {
    $$type: "RecursionTester$Data";
};
export declare const RecursionTester_getterMapping: {
    [key: string]: string;
};
export declare class RecursionTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<RecursionTester>;
    static fromAddress(address: Address): RecursionTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Deploy): Promise<void>;
    getFib(provider: ContractProvider, n: bigint): Promise<bigint>;
    getFact(provider: ContractProvider, n: bigint): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/sample-jetton_JettonDefaultWallet.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/sample-jetton_JettonDefaultWallet.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type ChangeOwner = {
    $$type: 'ChangeOwner';
    queryId: bigint;
    newOwner: Address;
};
export declare function storeChangeOwner(src: ChangeOwner): (builder: Builder) => void;
export declare function loadChangeOwner(slice: Slice): {
    $$type: "ChangeOwner";
    queryId: bigint;
    newOwner: Address;
};
export type ChangeOwnerOk = {
    $$type: 'ChangeOwnerOk';
    queryId: bigint;
    newOwner: Address;
};
export declare function storeChangeOwnerOk(src: ChangeOwnerOk): (builder: Builder) => void;
export declare function loadChangeOwnerOk(slice: Slice): {
    $$type: "ChangeOwnerOk";
    queryId: bigint;
    newOwner: Address;
};
export type Mint = {
    $$type: 'Mint';
    amount: bigint;
    receiver: Address;
};
export declare function storeMint(src: Mint): (builder: Builder) => void;
export declare function loadMint(slice: Slice): {
    $$type: "Mint";
    amount: bigint;
    receiver: Address;
};
export type JettonData = {
    $$type: 'JettonData';
    totalSupply: bigint;
    mintable: boolean;
    owner: Address;
    content: Cell;
    walletCode: Cell;
};
export declare function storeJettonData(src: JettonData): (builder: Builder) => void;
export declare function loadJettonData(slice: Slice): {
    $$type: "JettonData";
    totalSupply: bigint;
    mintable: boolean;
    owner: Address;
    content: Cell;
    walletCode: Cell;
};
export type SampleJetton$Data = {
    $$type: 'SampleJetton$Data';
    totalSupply: bigint;
    max_supply: bigint;
    owner: Address;
    content: Cell;
    mintable: boolean;
};
export declare function storeSampleJetton$Data(src: SampleJetton$Data): (builder: Builder) => void;
export declare function loadSampleJetton$Data(slice: Slice): {
    $$type: "SampleJetton$Data";
    totalSupply: bigint;
    max_supply: bigint;
    owner: Address;
    content: Cell;
    mintable: boolean;
};
export type TokenTransfer = {
    $$type: 'TokenTransfer';
    queryId: bigint;
    amount: bigint;
    destination: Address;
    response_destination: Address | null;
    custom_payload: Cell | null;
    forward_ton_amount: bigint;
    forward_payload: Slice;
};
export declare function storeTokenTransfer(src: TokenTransfer): (builder: Builder) => void;
export declare function loadTokenTransfer(slice: Slice): {
    $$type: "TokenTransfer";
    queryId: bigint;
    amount: bigint;
    destination: Address;
    response_destination: Address | null;
    custom_payload: Cell | null;
    forward_ton_amount: bigint;
    forward_payload: Slice;
};
export type TokenTransferInternal = {
    $$type: 'TokenTransferInternal';
    queryId: bigint;
    amount: bigint;
    from: Address;
    response_destination: Address | null;
    forward_ton_amount: bigint;
    forward_payload: Slice;
};
export declare function storeTokenTransferInternal(src: TokenTransferInternal): (builder: Builder) => void;
export declare function loadTokenTransferInternal(slice: Slice): {
    $$type: "TokenTransferInternal";
    queryId: bigint;
    amount: bigint;
    from: Address;
    response_destination: Address | null;
    forward_ton_amount: bigint;
    forward_payload: Slice;
};
export type TokenNotification = {
    $$type: 'TokenNotification';
    queryId: bigint;
    amount: bigint;
    from: Address;
    forward_payload: Slice;
};
export declare function storeTokenNotification(src: TokenNotification): (builder: Builder) => void;
export declare function loadTokenNotification(slice: Slice): {
    $$type: "TokenNotification";
    queryId: bigint;
    amount: bigint;
    from: Address;
    forward_payload: Slice;
};
export type TokenBurn = {
    $$type: 'TokenBurn';
    queryId: bigint;
    amount: bigint;
    owner: Address;
    response_destination: Address;
};
export declare function storeTokenBurn(src: TokenBurn): (builder: Builder) => void;
export declare function loadTokenBurn(slice: Slice): {
    $$type: "TokenBurn";
    queryId: bigint;
    amount: bigint;
    owner: Address;
    response_destination: Address;
};
export type TokenBurnNotification = {
    $$type: 'TokenBurnNotification';
    queryId: bigint;
    amount: bigint;
    owner: Address;
    response_destination: Address | null;
};
export declare function storeTokenBurnNotification(src: TokenBurnNotification): (builder: Builder) => void;
export declare function loadTokenBurnNotification(slice: Slice): {
    $$type: "TokenBurnNotification";
    queryId: bigint;
    amount: bigint;
    owner: Address;
    response_destination: Address | null;
};
export type TokenExcesses = {
    $$type: 'TokenExcesses';
    queryId: bigint;
};
export declare function storeTokenExcesses(src: TokenExcesses): (builder: Builder) => void;
export declare function loadTokenExcesses(slice: Slice): {
    $$type: "TokenExcesses";
    queryId: bigint;
};
export type TokenUpdateContent = {
    $$type: 'TokenUpdateContent';
    content: Cell;
};
export declare function storeTokenUpdateContent(src: TokenUpdateContent): (builder: Builder) => void;
export declare function loadTokenUpdateContent(slice: Slice): {
    $$type: "TokenUpdateContent";
    content: Cell;
};
export type JettonDefaultWallet$Data = {
    $$type: 'JettonDefaultWallet$Data';
    balance: bigint;
    owner: Address;
    master: Address;
};
export declare function storeJettonDefaultWallet$Data(src: JettonDefaultWallet$Data): (builder: Builder) => void;
export declare function loadJettonDefaultWallet$Data(slice: Slice): {
    $$type: "JettonDefaultWallet$Data";
    balance: bigint;
    owner: Address;
    master: Address;
};
export type JettonWalletData = {
    $$type: 'JettonWalletData';
    balance: bigint;
    owner: Address;
    master: Address;
    walletCode: Cell;
};
export declare function storeJettonWalletData(src: JettonWalletData): (builder: Builder) => void;
export declare function loadJettonWalletData(slice: Slice): {
    $$type: "JettonWalletData";
    balance: bigint;
    owner: Address;
    master: Address;
    walletCode: Cell;
};
export declare const JettonDefaultWallet_getterMapping: {
    [key: string]: string;
};
export declare class JettonDefaultWallet implements Contract {
    static init(master: Address, owner: Address): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(master: Address, owner: Address): Promise<JettonDefaultWallet>;
    static fromAddress(address: Address): JettonDefaultWallet;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: TokenTransfer | TokenTransferInternal | TokenBurn): Promise<void>;
    getMsgValue(provider: ContractProvider, value: bigint): Promise<bigint>;
    getGetWalletData(provider: ContractProvider): Promise<{
        $$type: "JettonWalletData";
        balance: bigint;
        owner: Address;
        master: Address;
        walletCode: Cell;
    }>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/sample-jetton_SampleJetton.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/sample-jetton_SampleJetton.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type ChangeOwner = {
    $$type: 'ChangeOwner';
    queryId: bigint;
    newOwner: Address;
};
export declare function storeChangeOwner(src: ChangeOwner): (builder: Builder) => void;
export declare function loadChangeOwner(slice: Slice): {
    $$type: "ChangeOwner";
    queryId: bigint;
    newOwner: Address;
};
export type ChangeOwnerOk = {
    $$type: 'ChangeOwnerOk';
    queryId: bigint;
    newOwner: Address;
};
export declare function storeChangeOwnerOk(src: ChangeOwnerOk): (builder: Builder) => void;
export declare function loadChangeOwnerOk(slice: Slice): {
    $$type: "ChangeOwnerOk";
    queryId: bigint;
    newOwner: Address;
};
export type Mint = {
    $$type: 'Mint';
    amount: bigint;
    receiver: Address;
};
export declare function storeMint(src: Mint): (builder: Builder) => void;
export declare function loadMint(slice: Slice): {
    $$type: "Mint";
    amount: bigint;
    receiver: Address;
};
export type JettonData = {
    $$type: 'JettonData';
    totalSupply: bigint;
    mintable: boolean;
    owner: Address;
    content: Cell;
    walletCode: Cell;
};
export declare function storeJettonData(src: JettonData): (builder: Builder) => void;
export declare function loadJettonData(slice: Slice): {
    $$type: "JettonData";
    totalSupply: bigint;
    mintable: boolean;
    owner: Address;
    content: Cell;
    walletCode: Cell;
};
export type SampleJetton$Data = {
    $$type: 'SampleJetton$Data';
    totalSupply: bigint;
    max_supply: bigint;
    owner: Address;
    content: Cell;
    mintable: boolean;
};
export declare function storeSampleJetton$Data(src: SampleJetton$Data): (builder: Builder) => void;
export declare function loadSampleJetton$Data(slice: Slice): {
    $$type: "SampleJetton$Data";
    totalSupply: bigint;
    max_supply: bigint;
    owner: Address;
    content: Cell;
    mintable: boolean;
};
export type TokenTransfer = {
    $$type: 'TokenTransfer';
    queryId: bigint;
    amount: bigint;
    destination: Address;
    response_destination: Address | null;
    custom_payload: Cell | null;
    forward_ton_amount: bigint;
    forward_payload: Slice;
};
export declare function storeTokenTransfer(src: TokenTransfer): (builder: Builder) => void;
export declare function loadTokenTransfer(slice: Slice): {
    $$type: "TokenTransfer";
    queryId: bigint;
    amount: bigint;
    destination: Address;
    response_destination: Address | null;
    custom_payload: Cell | null;
    forward_ton_amount: bigint;
    forward_payload: Slice;
};
export type TokenTransferInternal = {
    $$type: 'TokenTransferInternal';
    queryId: bigint;
    amount: bigint;
    from: Address;
    response_destination: Address | null;
    forward_ton_amount: bigint;
    forward_payload: Slice;
};
export declare function storeTokenTransferInternal(src: TokenTransferInternal): (builder: Builder) => void;
export declare function loadTokenTransferInternal(slice: Slice): {
    $$type: "TokenTransferInternal";
    queryId: bigint;
    amount: bigint;
    from: Address;
    response_destination: Address | null;
    forward_ton_amount: bigint;
    forward_payload: Slice;
};
export type TokenNotification = {
    $$type: 'TokenNotification';
    queryId: bigint;
    amount: bigint;
    from: Address;
    forward_payload: Slice;
};
export declare function storeTokenNotification(src: TokenNotification): (builder: Builder) => void;
export declare function loadTokenNotification(slice: Slice): {
    $$type: "TokenNotification";
    queryId: bigint;
    amount: bigint;
    from: Address;
    forward_payload: Slice;
};
export type TokenBurn = {
    $$type: 'TokenBurn';
    queryId: bigint;
    amount: bigint;
    owner: Address;
    response_destination: Address;
};
export declare function storeTokenBurn(src: TokenBurn): (builder: Builder) => void;
export declare function loadTokenBurn(slice: Slice): {
    $$type: "TokenBurn";
    queryId: bigint;
    amount: bigint;
    owner: Address;
    response_destination: Address;
};
export type TokenBurnNotification = {
    $$type: 'TokenBurnNotification';
    queryId: bigint;
    amount: bigint;
    owner: Address;
    response_destination: Address | null;
};
export declare function storeTokenBurnNotification(src: TokenBurnNotification): (builder: Builder) => void;
export declare function loadTokenBurnNotification(slice: Slice): {
    $$type: "TokenBurnNotification";
    queryId: bigint;
    amount: bigint;
    owner: Address;
    response_destination: Address | null;
};
export type TokenExcesses = {
    $$type: 'TokenExcesses';
    queryId: bigint;
};
export declare function storeTokenExcesses(src: TokenExcesses): (builder: Builder) => void;
export declare function loadTokenExcesses(slice: Slice): {
    $$type: "TokenExcesses";
    queryId: bigint;
};
export type TokenUpdateContent = {
    $$type: 'TokenUpdateContent';
    content: Cell;
};
export declare function storeTokenUpdateContent(src: TokenUpdateContent): (builder: Builder) => void;
export declare function loadTokenUpdateContent(slice: Slice): {
    $$type: "TokenUpdateContent";
    content: Cell;
};
export type JettonDefaultWallet$Data = {
    $$type: 'JettonDefaultWallet$Data';
    balance: bigint;
    owner: Address;
    master: Address;
};
export declare function storeJettonDefaultWallet$Data(src: JettonDefaultWallet$Data): (builder: Builder) => void;
export declare function loadJettonDefaultWallet$Data(slice: Slice): {
    $$type: "JettonDefaultWallet$Data";
    balance: bigint;
    owner: Address;
    master: Address;
};
export type JettonWalletData = {
    $$type: 'JettonWalletData';
    balance: bigint;
    owner: Address;
    master: Address;
    walletCode: Cell;
};
export declare function storeJettonWalletData(src: JettonWalletData): (builder: Builder) => void;
export declare function loadJettonWalletData(slice: Slice): {
    $$type: "JettonWalletData";
    balance: bigint;
    owner: Address;
    master: Address;
    walletCode: Cell;
};
export declare const SampleJetton_getterMapping: {
    [key: string]: string;
};
export declare class SampleJetton implements Contract {
    static init(owner: Address, content: Cell, max_supply: bigint): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(owner: Address, content: Cell, max_supply: bigint): Promise<SampleJetton>;
    static fromAddress(address: Address): SampleJetton;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Mint | "Mint: 100" | "Owner: MintClose" | TokenUpdateContent | TokenBurnNotification): Promise<void>;
    getGetJettonData(provider: ContractProvider): Promise<{
        $$type: "JettonData";
        totalSupply: bigint;
        mintable: boolean;
        owner: Address;
        content: Cell;
        walletCode: Cell;
    }>;
    getGetWalletAddress(provider: ContractProvider, owner: Address): Promise<Address>;
    getOwner(provider: ContractProvider): Promise<Address>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/semantics_SemanticsTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/semantics_SemanticsTester.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type SA = {
    $$type: 'SA';
    a1: bigint;
    a2: SB;
};
export declare function storeSA(src: SA): (builder: Builder) => void;
export declare function loadSA(slice: Slice): {
    $$type: "SA";
    a1: bigint;
    a2: {
        $$type: "SB";
        b1: boolean;
        b2: {
            $$type: "SC";
            c1: bigint;
        };
        b3: bigint;
    };
};
export type SB = {
    $$type: 'SB';
    b1: boolean;
    b2: SC;
    b3: bigint;
};
export declare function storeSB(src: SB): (builder: Builder) => void;
export declare function loadSB(slice: Slice): {
    $$type: "SB";
    b1: boolean;
    b2: {
        $$type: "SC";
        c1: bigint;
    };
    b3: bigint;
};
export type SC = {
    $$type: 'SC';
    c1: bigint;
};
export declare function storeSC(src: SC): (builder: Builder) => void;
export declare function loadSC(slice: Slice): {
    $$type: "SC";
    c1: bigint;
};
export type MapWrapper = {
    $$type: 'MapWrapper';
    m: Dictionary<bigint, SA>;
};
export declare function storeMapWrapper(src: MapWrapper): (builder: Builder) => void;
export declare function loadMapWrapper(slice: Slice): {
    $$type: "MapWrapper";
    m: Dictionary<bigint, SA>;
};
export type SemanticsTester$Data = {
    $$type: 'SemanticsTester$Data';
    sC: SC;
    sB: SB;
    sA: SA;
    uB: SB;
    mA: Dictionary<bigint, SA>;
    mB: Dictionary<bigint, boolean>;
    mC: Dictionary<bigint, MapWrapper>;
    mutateContractStateResult: boolean;
};
export declare function storeSemanticsTester$Data(src: SemanticsTester$Data): (builder: Builder) => void;
export declare function loadSemanticsTester$Data(slice: Slice): {
    $$type: "SemanticsTester$Data";
    sC: {
        $$type: "SC";
        c1: bigint;
    };
    sB: {
        $$type: "SB";
        b1: boolean;
        b2: {
            $$type: "SC";
            c1: bigint;
        };
        b3: bigint;
    };
    sA: {
        $$type: "SA";
        a1: bigint;
        a2: {
            $$type: "SB";
            b1: boolean;
            b2: {
                $$type: "SC";
                c1: bigint;
            };
            b3: bigint;
        };
    };
    uB: {
        $$type: "SB";
        b1: boolean;
        b2: {
            $$type: "SC";
            c1: bigint;
        };
        b3: bigint;
    };
    mA: Dictionary<bigint, SA>;
    mB: Dictionary<bigint, boolean>;
    mC: Dictionary<bigint, MapWrapper>;
    mutateContractStateResult: boolean;
};
export declare const SemanticsTester_getterMapping: {
    [key: string]: string;
};
export declare class SemanticsTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<SemanticsTester>;
    static fromAddress(address: Address): SemanticsTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | "mutate"): Promise<void>;
    getCheckAllContractFieldsAreUnchanged(provider: ContractProvider): Promise<boolean>;
    getStructAssign1(provider: ContractProvider): Promise<boolean>;
    getStructAssign2(provider: ContractProvider): Promise<boolean>;
    getParamStruct1(provider: ContractProvider): Promise<boolean>;
    getParamStruct2(provider: ContractProvider): Promise<boolean>;
    getMutateParamStruct1(provider: ContractProvider): Promise<boolean>;
    getMutateParamStruct2(provider: ContractProvider): Promise<boolean>;
    getTestReturnedStructs(provider: ContractProvider): Promise<boolean>;
    getMutatesChainStruct1(provider: ContractProvider): Promise<boolean>;
    getMutatesChainStruct2(provider: ContractProvider): Promise<boolean>;
    getMutatesChainStruct3(provider: ContractProvider): Promise<boolean>;
    getMutatesChainStruct4(provider: ContractProvider): Promise<boolean>;
    getMutatesChainStruct5(provider: ContractProvider): Promise<boolean>;
    getMutatesChainStruct6(provider: ContractProvider): Promise<boolean>;
    getMapAssign1(provider: ContractProvider): Promise<boolean>;
    getMapAssign2(provider: ContractProvider): Promise<boolean>;
    getParamMap1(provider: ContractProvider): Promise<boolean>;
    getParamMap2(provider: ContractProvider): Promise<boolean>;
    getMutateParamMap1(provider: ContractProvider): Promise<boolean>;
    getMutateParamMap2(provider: ContractProvider): Promise<boolean>;
    getTestReturnedMaps1(provider: ContractProvider): Promise<boolean>;
    getMutateNestedMap1(provider: ContractProvider): Promise<boolean>;
    getContractAssign1(provider: ContractProvider): Promise<boolean>;
    getContractAssign2(provider: ContractProvider): Promise<boolean>;
    getParamContract(provider: ContractProvider): Promise<boolean>;
    getMutateParamContract(provider: ContractProvider): Promise<boolean>;
    getAddress(provider: ContractProvider): Promise<Address>;
    getTestReturnedContracts(provider: ContractProvider): Promise<boolean>;
    getMutateContractStateFlag(provider: ContractProvider): Promise<boolean>;
    getChangesPersisted(provider: ContractProvider): Promise<boolean>;
    getMutatesChainInt1(provider: ContractProvider): Promise<boolean>;
    getMutatesChainInt2(provider: ContractProvider): Promise<boolean>;
    getMutatesChainInt3(provider: ContractProvider): Promise<boolean>;
    getMutatesChainInt4(provider: ContractProvider): Promise<boolean>;
    getMutatesChainInt5(provider: ContractProvider): Promise<boolean>;
    getMutatesChainInt6(provider: ContractProvider): Promise<boolean>;
    getAndMutateShortCircuit(provider: ContractProvider): Promise<boolean>;
    getAndInfiniteLoopShortCircuit(provider: ContractProvider): Promise<boolean>;
    getAndExceptionShortCircuit(provider: ContractProvider): Promise<boolean>;
    getOrMutateShortCircuit(provider: ContractProvider): Promise<boolean>;
    getOrInfiniteLoopShortCircuit(provider: ContractProvider): Promise<boolean>;
    getOrExceptionShortCircuit(provider: ContractProvider): Promise<boolean>;
    getTestAddressEquality(provider: ContractProvider): Promise<boolean>;
    getTestSliceEquality1(provider: ContractProvider): Promise<boolean>;
    getTestSliceEquality2(provider: ContractProvider): Promise<boolean>;
    getTestCellEquality1(provider: ContractProvider): Promise<boolean>;
    getTestCellEquality2(provider: ContractProvider): Promise<boolean>;
    getTestCellEquality3(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/send_SendTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/send_SendTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type SendTester$Data = {
    $$type: 'SendTester$Data';
};
export declare function storeSendTester$Data(src: SendTester$Data): (builder: Builder) => void;
export declare function loadSendTester$Data(slice: Slice): {
    $$type: "SendTester$Data";
};
export declare const SendTester_getterMapping: {
    [key: string]: string;
};
export declare class SendTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<SendTester>;
    static fromAddress(address: Address): SendTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "Hello" | Deploy): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/serialization-2_SerializationTester2.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/serialization-2_SerializationTester2.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Vars = {
    $$type: 'Vars';
    a: bigint;
    b: bigint;
    c: bigint;
    d: bigint;
    e: bigint;
};
export declare function storeVars(src: Vars): (builder: Builder) => void;
export declare function loadVars(slice: Slice): {
    $$type: "Vars";
    a: bigint;
    b: bigint;
    c: bigint;
    d: bigint;
    e: bigint;
};
export type Both = {
    $$type: 'Both';
    a: Vars;
    b: Vars;
};
export declare function storeBoth(src: Both): (builder: Builder) => void;
export declare function loadBoth(slice: Slice): {
    $$type: "Both";
    a: {
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    };
    b: {
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    };
};
export type Update = {
    $$type: 'Update';
    a: Vars;
    b: Vars;
};
export declare function storeUpdate(src: Update): (builder: Builder) => void;
export declare function loadUpdate(slice: Slice): {
    $$type: "Update";
    a: {
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    };
    b: {
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    };
};
export type SerializationTester2$Data = {
    $$type: 'SerializationTester2$Data';
    a: Vars;
    b: Vars;
};
export declare function storeSerializationTester2$Data(src: SerializationTester2$Data): (builder: Builder) => void;
export declare function loadSerializationTester2$Data(slice: Slice): {
    $$type: "SerializationTester2$Data";
    a: {
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    };
    b: {
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    };
};
export declare const SerializationTester2_getterMapping: {
    [key: string]: string;
};
export declare class SerializationTester2 implements Contract {
    static init(a: Vars, b: Vars): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(a: Vars, b: Vars): Promise<SerializationTester2>;
    static fromAddress(address: Address): SerializationTester2;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | Update): Promise<void>;
    getGetA(provider: ContractProvider): Promise<{
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    }>;
    getGetAOpt(provider: ContractProvider): Promise<{
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    } | null>;
    getGetB(provider: ContractProvider): Promise<{
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    }>;
    getGetBOpt(provider: ContractProvider): Promise<{
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    } | null>;
    getGetBoth(provider: ContractProvider): Promise<{
        $$type: "Both";
        a: {
            $$type: "Vars";
            a: bigint;
            b: bigint;
            c: bigint;
            d: bigint;
            e: bigint;
        };
        b: {
            $$type: "Vars";
            a: bigint;
            b: bigint;
            c: bigint;
            d: bigint;
            e: bigint;
        };
    }>;
    getGetBothOpt(provider: ContractProvider): Promise<{
        $$type: "Both";
        a: {
            $$type: "Vars";
            a: bigint;
            b: bigint;
            c: bigint;
            d: bigint;
            e: bigint;
        };
        b: {
            $$type: "Vars";
            a: bigint;
            b: bigint;
            c: bigint;
            d: bigint;
            e: bigint;
        };
    } | null>;
    getProcess(provider: ContractProvider, src: Vars, both: Both, both2: Both | null): Promise<{
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    }>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/serialization-3_SerializationTester3.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/serialization-3_SerializationTester3.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Update = {
    $$type: 'Update';
    a: bigint;
    b: boolean;
    c: Cell;
    d: Slice;
    e: Builder;
    f: string;
};
export declare function storeUpdate(src: Update): (builder: Builder) => void;
export declare function loadUpdate(slice: Slice): {
    $$type: "Update";
    a: bigint;
    b: boolean;
    c: Cell;
    d: Slice;
    e: Builder;
    f: string;
};
export type SerializationTester3$Data = {
    $$type: 'SerializationTester3$Data';
    a: bigint;
    b: boolean;
    c: Cell;
    d: Slice;
    e: Builder;
    f: string;
};
export declare function storeSerializationTester3$Data(src: SerializationTester3$Data): (builder: Builder) => void;
export declare function loadSerializationTester3$Data(slice: Slice): {
    $$type: "SerializationTester3$Data";
    a: bigint;
    b: boolean;
    c: Cell;
    d: Slice;
    e: Builder;
    f: string;
};
export declare const SerializationTester3_getterMapping: {
    [key: string]: string;
};
export declare class SerializationTester3 implements Contract {
    static init(a: bigint, b: boolean, c: Cell, d: Slice, e: Builder, f: string): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(a: bigint, b: boolean, c: Cell, d: Slice, e: Builder, f: string): Promise<SerializationTester3>;
    static fromAddress(address: Address): SerializationTester3;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | Update): Promise<void>;
    getGetA(provider: ContractProvider): Promise<bigint>;
    getGetB(provider: ContractProvider): Promise<boolean>;
    getGetC(provider: ContractProvider): Promise<Cell>;
    getGetD(provider: ContractProvider): Promise<Slice>;
    getGetE(provider: ContractProvider): Promise<Builder>;
    getGetF(provider: ContractProvider): Promise<string>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/serialization_SerializationTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/serialization_SerializationTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Update = {
    $$type: 'Update';
    a: bigint;
    b: bigint;
    c: bigint;
    d: bigint;
    e: bigint;
    f: bigint;
    g: bigint;
    h: bigint;
    i: bigint;
};
export declare function storeUpdate(src: Update): (builder: Builder) => void;
export declare function loadUpdate(slice: Slice): {
    $$type: "Update";
    a: bigint;
    b: bigint;
    c: bigint;
    d: bigint;
    e: bigint;
    f: bigint;
    g: bigint;
    h: bigint;
    i: bigint;
};
export type SerializationTester$Data = {
    $$type: 'SerializationTester$Data';
    a: bigint;
    b: bigint;
    c: bigint;
    d: bigint;
    e: bigint;
    f: bigint;
    g: bigint;
    h: bigint;
    i: bigint;
};
export declare function storeSerializationTester$Data(src: SerializationTester$Data): (builder: Builder) => void;
export declare function loadSerializationTester$Data(slice: Slice): {
    $$type: "SerializationTester$Data";
    a: bigint;
    b: bigint;
    c: bigint;
    d: bigint;
    e: bigint;
    f: bigint;
    g: bigint;
    h: bigint;
    i: bigint;
};
export declare const SerializationTester_getterMapping: {
    [key: string]: string;
};
export declare class SerializationTester implements Contract {
    static init(a: bigint, b: bigint, c: bigint, d: bigint, e: bigint, f: bigint, g: bigint, h: bigint, i: bigint): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(a: bigint, b: bigint, c: bigint, d: bigint, e: bigint, f: bigint, g: bigint, h: bigint, i: bigint): Promise<SerializationTester>;
    static fromAddress(address: Address): SerializationTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | Update): Promise<void>;
    getGetA(provider: ContractProvider): Promise<bigint>;
    getGetB(provider: ContractProvider): Promise<bigint>;
    getGetC(provider: ContractProvider): Promise<bigint>;
    getGetD(provider: ContractProvider): Promise<bigint>;
    getGetE(provider: ContractProvider): Promise<bigint>;
    getGetF(provider: ContractProvider): Promise<bigint>;
    getGetG(provider: ContractProvider): Promise<bigint>;
    getGetH(provider: ContractProvider): Promise<bigint>;
    getGetI(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/stdlib_StdlibTest.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/stdlib_StdlibTest.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type StdlibTest$Data = {
    $$type: 'StdlibTest$Data';
    v: bigint;
};
export declare function storeStdlibTest$Data(src: StdlibTest$Data): (builder: Builder) => void;
export declare function loadStdlibTest$Data(slice: Slice): {
    $$type: "StdlibTest$Data";
    v: bigint;
};
export declare const StdlibTest_getterMapping: {
    [key: string]: string;
};
export declare class StdlibTest implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<StdlibTest>;
    static fromAddress(address: Address): StdlibTest;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getSliceEmpty(provider: ContractProvider, sc: Slice): Promise<boolean>;
    getSliceBits(provider: ContractProvider, sc: Slice): Promise<bigint>;
    getSliceRefs(provider: ContractProvider, sc: Slice): Promise<bigint>;
    getStoreBool(provider: ContractProvider, bl: Builder, b: boolean): Promise<Builder>;
    getLoadBool(provider: ContractProvider, sc: Slice): Promise<boolean>;
    getStoreBit(provider: ContractProvider, bl: Builder, b: boolean): Promise<Builder>;
    getLoadBit(provider: ContractProvider, sc: Slice): Promise<boolean>;
    getTvm_2023_07Upgrade(provider: ContractProvider): Promise<bigint>;
    getTvm_2024_04Upgrade(provider: ContractProvider): Promise<bigint>;
    getStoreMaybeRef(provider: ContractProvider, bl: Builder, c: Cell | null): Promise<Builder>;
    getParseStdAddress(provider: ContractProvider, slice: Slice): Promise<{
        $$type: "StdAddress";
        workchain: bigint;
        address: bigint;
    }>;
    getParseVarAddress(provider: ContractProvider, slice: Slice): Promise<{
        $$type: "VarAddress";
        workchain: bigint;
        address: Slice;
    }>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/strings_StringsTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/strings_StringsTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type StringsTester$Data = {
    $$type: 'StringsTester$Data';
};
export declare function storeStringsTester$Data(src: StringsTester$Data): (builder: Builder) => void;
export declare function loadStringsTester$Data(slice: Slice): {
    $$type: "StringsTester$Data";
};
export declare const StringsTester_getterMapping: {
    [key: string]: string;
};
export declare class StringsTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<StringsTester>;
    static fromAddress(address: Address): StringsTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | "backtick-test"): Promise<void>;
    getConstantString(provider: ContractProvider): Promise<string>;
    getConstantStringUnicode(provider: ContractProvider): Promise<string>;
    getConstantStringUnicodeLong(provider: ContractProvider): Promise<string>;
    getDynamicStringCell(provider: ContractProvider): Promise<Cell>;
    getDynamicStringCell2(provider: ContractProvider): Promise<Cell>;
    getDynamicCommentCell(provider: ContractProvider): Promise<Cell>;
    getDynamicCommentCellLarge(provider: ContractProvider): Promise<Cell>;
    getDynamicCommentStringLarge(provider: ContractProvider): Promise<string>;
    getStringWithNumber(provider: ContractProvider): Promise<string>;
    getStringWithNegativeNumber(provider: ContractProvider): Promise<string>;
    getStringWithLargeNumber(provider: ContractProvider): Promise<string>;
    getStringWithFloat(provider: ContractProvider): Promise<string>;
    getBase64(provider: ContractProvider): Promise<Slice>;
    getProcessBase64(provider: ContractProvider, src: string): Promise<Slice>;
    getStringWithEscapedChars1(provider: ContractProvider): Promise<string>;
    getStringWithEscapedChars2(provider: ContractProvider): Promise<string>;
    getStringWithEscapedChars3(provider: ContractProvider): Promise<string>;
    getStringWithEscapedChars4(provider: ContractProvider): Promise<string>;
    getStringWithEscapedChars5(provider: ContractProvider): Promise<string>;
    getStringWithEscapedChars6(provider: ContractProvider): Promise<string>;
    getStringWithAddress(provider: ContractProvider): Promise<string>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/structs_StructsTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/structs_StructsTester.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type S = {
    $$type: 'S';
    a: boolean;
    b: bigint;
};
export declare function storeS(src: S): (builder: Builder) => void;
export declare function loadS(slice: Slice): {
    $$type: "S";
    a: boolean;
    b: bigint;
};
export type T = {
    $$type: 'T';
    a: bigint;
    s: S;
};
export declare function storeT(src: T): (builder: Builder) => void;
export declare function loadT(slice: Slice): {
    $$type: "T";
    a: bigint;
    s: {
        $$type: "S";
        a: boolean;
        b: bigint;
    };
};
export type MyStruct1 = {
    $$type: 'MyStruct1';
    a: bigint;
    b: bigint;
    c: bigint | null;
};
export declare function storeMyStruct1(src: MyStruct1): (builder: Builder) => void;
export declare function loadMyStruct1(slice: Slice): {
    $$type: "MyStruct1";
    a: bigint;
    b: bigint;
    c: bigint | null;
};
export type MyStruct2 = {
    $$type: 'MyStruct2';
    m: Dictionary<bigint, bigint>;
    s: MyStruct1 | null;
};
export declare function storeMyStruct2(src: MyStruct2): (builder: Builder) => void;
export declare function loadMyStruct2(slice: Slice): {
    $$type: "MyStruct2";
    m: Dictionary<bigint, bigint>;
    s: {
        $$type: "MyStruct1";
        a: bigint;
        b: bigint;
        c: bigint | null;
    } | null;
};
export type MyStruct3 = {
    $$type: 'MyStruct3';
    s: string;
};
export declare function storeMyStruct3(src: MyStruct3): (builder: Builder) => void;
export declare function loadMyStruct3(slice: Slice): {
    $$type: "MyStruct3";
    s: string;
};
export type MyMessage1 = {
    $$type: 'MyMessage1';
    a: bigint;
    s: MyStruct2;
};
export declare function storeMyMessage1(src: MyMessage1): (builder: Builder) => void;
export declare function loadMyMessage1(slice: Slice): {
    $$type: "MyMessage1";
    a: bigint;
    s: {
        $$type: "MyStruct2";
        m: Dictionary<bigint, bigint>;
        s: {
            $$type: "MyStruct1";
            a: bigint;
            b: bigint;
            c: bigint | null;
        } | null;
    };
};
export type Coin = {
    $$type: 'Coin';
    first: bigint;
    second: bigint;
};
export declare function storeCoin(src: Coin): (builder: Builder) => void;
export declare function loadCoin(slice: Slice): {
    $$type: "Coin";
    first: bigint;
    second: bigint;
};
export type VarIntegers = {
    $$type: 'VarIntegers';
    a: bigint;
    b: bigint;
    c: bigint;
    d: bigint;
};
export declare function storeVarIntegers(src: VarIntegers): (builder: Builder) => void;
export declare function loadVarIntegers(slice: Slice): {
    $$type: "VarIntegers";
    a: bigint;
    b: bigint;
    c: bigint;
    d: bigint;
};
export type IntFields = {
    $$type: 'IntFields';
    i1: bigint;
    i2: bigint;
    i3: bigint;
    i255: bigint;
    i256: bigint;
    i257: bigint;
};
export declare function storeIntFields(src: IntFields): (builder: Builder) => void;
export declare function loadIntFields(slice: Slice): {
    $$type: "IntFields";
    i1: bigint;
    i2: bigint;
    i3: bigint;
    i255: bigint;
    i256: bigint;
    i257: bigint;
};
export type UintFields = {
    $$type: 'UintFields';
    u1: bigint;
    u2: bigint;
    u3: bigint;
    u254: bigint;
    u255: bigint;
    u256: bigint;
};
export declare function storeUintFields(src: UintFields): (builder: Builder) => void;
export declare function loadUintFields(slice: Slice): {
    $$type: "UintFields";
    u1: bigint;
    u2: bigint;
    u3: bigint;
    u254: bigint;
    u255: bigint;
    u256: bigint;
};
export type LongStruct15 = {
    $$type: 'LongStruct15';
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
};
export declare function storeLongStruct15(src: LongStruct15): (builder: Builder) => void;
export declare function loadLongStruct15(slice: Slice): {
    $$type: "LongStruct15";
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
};
export type LongStruct16 = {
    $$type: 'LongStruct16';
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
};
export declare function storeLongStruct16(src: LongStruct16): (builder: Builder) => void;
export declare function loadLongStruct16(slice: Slice): {
    $$type: "LongStruct16";
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
};
export type LongStruct32 = {
    $$type: 'LongStruct32';
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    x17: bigint;
    x18: bigint;
    x19: bigint;
    x20: bigint;
    x21: bigint;
    x22: bigint;
    x23: bigint;
    x24: bigint;
    x25: bigint;
    x26: bigint;
    x27: bigint;
    x28: bigint;
    x29: bigint;
    x30: bigint;
    x31: bigint;
    x32: bigint;
};
export declare function storeLongStruct32(src: LongStruct32): (builder: Builder) => void;
export declare function loadLongStruct32(slice: Slice): {
    $$type: "LongStruct32";
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    x17: bigint;
    x18: bigint;
    x19: bigint;
    x20: bigint;
    x21: bigint;
    x22: bigint;
    x23: bigint;
    x24: bigint;
    x25: bigint;
    x26: bigint;
    x27: bigint;
    x28: bigint;
    x29: bigint;
    x30: bigint;
    x31: bigint;
    x32: bigint;
};
export type LongNestedStruct = {
    $$type: 'LongNestedStruct';
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    x17: bigint;
    x18: bigint;
    x19: bigint;
    x20: bigint;
    s1: LongStruct15;
    s2: LongStruct16;
    s3: LongStruct32;
};
export declare function storeLongNestedStruct(src: LongNestedStruct): (builder: Builder) => void;
export declare function loadLongNestedStruct(slice: Slice): {
    $$type: "LongNestedStruct";
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    x17: bigint;
    x18: bigint;
    x19: bigint;
    x20: bigint;
    s1: {
        $$type: "LongStruct15";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
    };
    s2: {
        $$type: "LongStruct16";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
    };
    s3: {
        $$type: "LongStruct32";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
        x17: bigint;
        x18: bigint;
        x19: bigint;
        x20: bigint;
        x21: bigint;
        x22: bigint;
        x23: bigint;
        x24: bigint;
        x25: bigint;
        x26: bigint;
        x27: bigint;
        x28: bigint;
        x29: bigint;
        x30: bigint;
        x31: bigint;
        x32: bigint;
    };
};
export type LongNestedStructWithOpts = {
    $$type: 'LongNestedStructWithOpts';
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    x17: bigint;
    x18: bigint | null;
    x19: bigint;
    x20: bigint;
    s1: LongStruct15 | null;
    s2: LongStruct16;
    s3: LongStruct32 | null;
};
export declare function storeLongNestedStructWithOpts(src: LongNestedStructWithOpts): (builder: Builder) => void;
export declare function loadLongNestedStructWithOpts(slice: Slice): {
    $$type: "LongNestedStructWithOpts";
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    x17: bigint;
    x18: bigint | null;
    x19: bigint;
    x20: bigint;
    s1: {
        $$type: "LongStruct15";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
    } | null;
    s2: {
        $$type: "LongStruct16";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
    };
    s3: {
        $$type: "LongStruct32";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
        x17: bigint;
        x18: bigint;
        x19: bigint;
        x20: bigint;
        x21: bigint;
        x22: bigint;
        x23: bigint;
        x24: bigint;
        x25: bigint;
        x26: bigint;
        x27: bigint;
        x28: bigint;
        x29: bigint;
        x30: bigint;
        x31: bigint;
        x32: bigint;
    } | null;
};
export type Point = {
    $$type: 'Point';
    x: bigint;
    y: bigint;
};
export declare function storePoint(src: Point): (builder: Builder) => void;
export declare function loadPoint(slice: Slice): {
    $$type: "Point";
    x: bigint;
    y: bigint;
};
export type Line = {
    $$type: 'Line';
    start: Point;
    end: Point;
};
export declare function storeLine(src: Line): (builder: Builder) => void;
export declare function loadLine(slice: Slice): {
    $$type: "Line";
    start: {
        $$type: "Point";
        x: bigint;
        y: bigint;
    };
    end: {
        $$type: "Point";
        x: bigint;
        y: bigint;
    };
};
export type Location = {
    $$type: 'Location';
    idx: bigint;
    line1: Line;
    line2: Line | null;
};
export declare function storeLocation(src: Location): (builder: Builder) => void;
export declare function loadLocation(slice: Slice): {
    $$type: "Location";
    idx: bigint;
    line1: {
        $$type: "Line";
        start: {
            $$type: "Point";
            x: bigint;
            y: bigint;
        };
        end: {
            $$type: "Point";
            x: bigint;
            y: bigint;
        };
    };
    line2: {
        $$type: "Line";
        start: {
            $$type: "Point";
            x: bigint;
            y: bigint;
        };
        end: {
            $$type: "Point";
            x: bigint;
            y: bigint;
        };
    } | null;
};
export type DoubleNestedStructOpt = {
    $$type: 'DoubleNestedStructOpt';
    a: bigint;
    s: MyStruct1 | null;
};
export declare function storeDoubleNestedStructOpt(src: DoubleNestedStructOpt): (builder: Builder) => void;
export declare function loadDoubleNestedStructOpt(slice: Slice): {
    $$type: "DoubleNestedStructOpt";
    a: bigint;
    s: {
        $$type: "MyStruct1";
        a: bigint;
        b: bigint;
        c: bigint | null;
    } | null;
};
export type TripleNestedStructOpt = {
    $$type: 'TripleNestedStructOpt';
    a: bigint;
    s: DoubleNestedStructOpt | null;
};
export declare function storeTripleNestedStructOpt(src: TripleNestedStructOpt): (builder: Builder) => void;
export declare function loadTripleNestedStructOpt(slice: Slice): {
    $$type: "TripleNestedStructOpt";
    a: bigint;
    s: {
        $$type: "DoubleNestedStructOpt";
        a: bigint;
        s: {
            $$type: "MyStruct1";
            a: bigint;
            b: bigint;
            c: bigint | null;
        } | null;
    } | null;
};
export type LongAndDeepNestedStruct = {
    $$type: 'LongAndDeepNestedStruct';
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    s1: TripleNestedStructOpt;
    s2: TripleNestedStructOpt;
    s3: TripleNestedStructOpt | null;
    s4: TripleNestedStructOpt | null;
};
export declare function storeLongAndDeepNestedStruct(src: LongAndDeepNestedStruct): (builder: Builder) => void;
export declare function loadLongAndDeepNestedStruct(slice: Slice): {
    $$type: "LongAndDeepNestedStruct";
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    s1: {
        $$type: "TripleNestedStructOpt";
        a: bigint;
        s: {
            $$type: "DoubleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "MyStruct1";
                a: bigint;
                b: bigint;
                c: bigint | null;
            } | null;
        } | null;
    };
    s2: {
        $$type: "TripleNestedStructOpt";
        a: bigint;
        s: {
            $$type: "DoubleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "MyStruct1";
                a: bigint;
                b: bigint;
                c: bigint | null;
            } | null;
        } | null;
    };
    s3: {
        $$type: "TripleNestedStructOpt";
        a: bigint;
        s: {
            $$type: "DoubleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "MyStruct1";
                a: bigint;
                b: bigint;
                c: bigint | null;
            } | null;
        } | null;
    } | null;
    s4: {
        $$type: "TripleNestedStructOpt";
        a: bigint;
        s: {
            $$type: "DoubleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "MyStruct1";
                a: bigint;
                b: bigint;
                c: bigint | null;
            } | null;
        } | null;
    } | null;
};
export type Foo = {
    $$type: 'Foo';
    s: Slice;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    s: Slice;
};
export type Dict = {
    $$type: 'Dict';
    m: Dictionary<number, bigint>;
};
export declare function storeDict(src: Dict): (builder: Builder) => void;
export declare function loadDict(slice: Slice): {
    $$type: "Dict";
    m: Dictionary<number, bigint>;
};
export type OptionalFields = {
    $$type: 'OptionalFields';
    nickname: string | null;
    avatar: string | null;
};
export declare function storeOptionalFields(src: OptionalFields): (builder: Builder) => void;
export declare function loadOptionalFields(slice: Slice): {
    $$type: "OptionalFields";
    nickname: string | null;
    avatar: string | null;
};
export type S1 = {
    $$type: 'S1';
    a: bigint;
    b: bigint;
    c: bigint;
};
export declare function storeS1(src: S1): (builder: Builder) => void;
export declare function loadS1(slice: Slice): {
    $$type: "S1";
    a: bigint;
    b: bigint;
    c: bigint;
};
export type StructsTester$Data = {
    $$type: 'StructsTester$Data';
    s1: S;
    s2: S;
    t1: T;
    t2: T;
    mapWithLongStructs15: Dictionary<bigint, LongStruct15>;
    mapWithLongStructs16: Dictionary<bigint, LongStruct16>;
    mapWithLongStructs32: Dictionary<bigint, LongStruct32>;
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    x17: bigint;
    x18: bigint;
    x19: bigint;
    x20: bigint;
};
export declare function storeStructsTester$Data(src: StructsTester$Data): (builder: Builder) => void;
export declare function loadStructsTester$Data(slice: Slice): {
    $$type: "StructsTester$Data";
    s1: {
        $$type: "S";
        a: boolean;
        b: bigint;
    };
    s2: {
        $$type: "S";
        a: boolean;
        b: bigint;
    };
    t1: {
        $$type: "T";
        a: bigint;
        s: {
            $$type: "S";
            a: boolean;
            b: bigint;
        };
    };
    t2: {
        $$type: "T";
        a: bigint;
        s: {
            $$type: "S";
            a: boolean;
            b: bigint;
        };
    };
    mapWithLongStructs15: Dictionary<bigint, LongStruct15>;
    mapWithLongStructs16: Dictionary<bigint, LongStruct16>;
    mapWithLongStructs32: Dictionary<bigint, LongStruct32>;
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    x17: bigint;
    x18: bigint;
    x19: bigint;
    x20: bigint;
};
export declare const StructsTester_getterMapping: {
    [key: string]: string;
};
export declare class StructsTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<StructsTester>;
    static fromAddress(address: Address): StructsTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | Foo | "example" | "exampleVarIntegers"): Promise<void>;
    getStructInitializerTest(provider: ContractProvider): Promise<boolean>;
    getToCell1(provider: ContractProvider, s: MyStruct1): Promise<Cell>;
    getToSlice1(provider: ContractProvider, s: MyStruct1): Promise<Slice>;
    getFromCell1(provider: ContractProvider, src: Cell): Promise<{
        $$type: "MyStruct1";
        a: bigint;
        b: bigint;
        c: bigint | null;
    }>;
    getFromSlice1(provider: ContractProvider, src: Slice): Promise<{
        $$type: "MyStruct1";
        a: bigint;
        b: bigint;
        c: bigint | null;
    }>;
    getToCell2(provider: ContractProvider, s: MyStruct2): Promise<Cell>;
    getFromCell2(provider: ContractProvider, src: Cell): Promise<{
        $$type: "MyStruct2";
        m: Dictionary<bigint, bigint>;
        s: {
            $$type: "MyStruct1";
            a: bigint;
            b: bigint;
            c: bigint | null;
        } | null;
    }>;
    getFromSlice2(provider: ContractProvider, src: Slice): Promise<{
        $$type: "MyStruct2";
        m: Dictionary<bigint, bigint>;
        s: {
            $$type: "MyStruct1";
            a: bigint;
            b: bigint;
            c: bigint | null;
        } | null;
    }>;
    getTest1(provider: ContractProvider, s1: MyStruct1, s2: MyStruct2): Promise<Cell>;
    getToCellMessage1(provider: ContractProvider, m: MyMessage1): Promise<Cell>;
    getFromCellMessage1(provider: ContractProvider, src: Cell): Promise<{
        $$type: "MyMessage1";
        a: bigint;
        s: {
            $$type: "MyStruct2";
            m: Dictionary<bigint, bigint>;
            s: {
                $$type: "MyStruct1";
                a: bigint;
                b: bigint;
                c: bigint | null;
            } | null;
        };
    }>;
    getFromSliceMessage1(provider: ContractProvider, src: Slice): Promise<{
        $$type: "MyMessage1";
        a: bigint;
        s: {
            $$type: "MyStruct2";
            m: Dictionary<bigint, bigint>;
            s: {
                $$type: "MyStruct1";
                a: bigint;
                b: bigint;
                c: bigint | null;
            } | null;
        };
    }>;
    getContractStructConstantImmediate(provider: ContractProvider): Promise<{
        $$type: "MyStruct3";
        s: string;
    }>;
    getGlobalConstStructConstantImmediate(provider: ContractProvider): Promise<{
        $$type: "MyStruct3";
        s: string;
    }>;
    getContractStructConstantFieldImmediate(provider: ContractProvider): Promise<string>;
    getGlobalConstStructConstantFieldImmediate(provider: ContractProvider): Promise<string>;
    getContractStructConstantViaVar(provider: ContractProvider): Promise<{
        $$type: "MyStruct3";
        s: string;
    }>;
    getGlobalConstStructConstantViaVar(provider: ContractProvider): Promise<{
        $$type: "MyStruct3";
        s: string;
    }>;
    getContractStructConstantFieldViaVar(provider: ContractProvider): Promise<string>;
    getGlobalConstStructConstantFieldViaVar(provider: ContractProvider): Promise<string>;
    getLongStruct15Test(provider: ContractProvider): Promise<{
        $$type: "LongStruct15";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
    }>;
    getLongStruct16Test(provider: ContractProvider): Promise<{
        $$type: "LongStruct16";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
    }>;
    getLongStruct32Test(provider: ContractProvider): Promise<{
        $$type: "LongStruct32";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
        x17: bigint;
        x18: bigint;
        x19: bigint;
        x20: bigint;
        x21: bigint;
        x22: bigint;
        x23: bigint;
        x24: bigint;
        x25: bigint;
        x26: bigint;
        x27: bigint;
        x28: bigint;
        x29: bigint;
        x30: bigint;
        x31: bigint;
        x32: bigint;
    }>;
    getLongNestedStructTest(provider: ContractProvider): Promise<{
        $$type: "LongNestedStruct";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
        x17: bigint;
        x18: bigint;
        x19: bigint;
        x20: bigint;
        s1: {
            $$type: "LongStruct15";
            x1: bigint;
            x2: bigint;
            x3: bigint;
            x4: bigint;
            x5: bigint;
            x6: bigint;
            x7: bigint;
            x8: bigint;
            x9: bigint;
            x10: bigint;
            x11: bigint;
            x12: bigint;
            x13: bigint;
            x14: bigint;
            x15: bigint;
        };
        s2: {
            $$type: "LongStruct16";
            x1: bigint;
            x2: bigint;
            x3: bigint;
            x4: bigint;
            x5: bigint;
            x6: bigint;
            x7: bigint;
            x8: bigint;
            x9: bigint;
            x10: bigint;
            x11: bigint;
            x12: bigint;
            x13: bigint;
            x14: bigint;
            x15: bigint;
            x16: bigint;
        };
        s3: {
            $$type: "LongStruct32";
            x1: bigint;
            x2: bigint;
            x3: bigint;
            x4: bigint;
            x5: bigint;
            x6: bigint;
            x7: bigint;
            x8: bigint;
            x9: bigint;
            x10: bigint;
            x11: bigint;
            x12: bigint;
            x13: bigint;
            x14: bigint;
            x15: bigint;
            x16: bigint;
            x17: bigint;
            x18: bigint;
            x19: bigint;
            x20: bigint;
            x21: bigint;
            x22: bigint;
            x23: bigint;
            x24: bigint;
            x25: bigint;
            x26: bigint;
            x27: bigint;
            x28: bigint;
            x29: bigint;
            x30: bigint;
            x31: bigint;
            x32: bigint;
        };
    }>;
    getLongNestedStructWithOptsTest(provider: ContractProvider): Promise<{
        $$type: "LongNestedStructWithOpts";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
        x17: bigint;
        x18: bigint | null;
        x19: bigint;
        x20: bigint;
        s1: {
            $$type: "LongStruct15";
            x1: bigint;
            x2: bigint;
            x3: bigint;
            x4: bigint;
            x5: bigint;
            x6: bigint;
            x7: bigint;
            x8: bigint;
            x9: bigint;
            x10: bigint;
            x11: bigint;
            x12: bigint;
            x13: bigint;
            x14: bigint;
            x15: bigint;
        } | null;
        s2: {
            $$type: "LongStruct16";
            x1: bigint;
            x2: bigint;
            x3: bigint;
            x4: bigint;
            x5: bigint;
            x6: bigint;
            x7: bigint;
            x8: bigint;
            x9: bigint;
            x10: bigint;
            x11: bigint;
            x12: bigint;
            x13: bigint;
            x14: bigint;
            x15: bigint;
            x16: bigint;
        };
        s3: {
            $$type: "LongStruct32";
            x1: bigint;
            x2: bigint;
            x3: bigint;
            x4: bigint;
            x5: bigint;
            x6: bigint;
            x7: bigint;
            x8: bigint;
            x9: bigint;
            x10: bigint;
            x11: bigint;
            x12: bigint;
            x13: bigint;
            x14: bigint;
            x15: bigint;
            x16: bigint;
            x17: bigint;
            x18: bigint;
            x19: bigint;
            x20: bigint;
            x21: bigint;
            x22: bigint;
            x23: bigint;
            x24: bigint;
            x25: bigint;
            x26: bigint;
            x27: bigint;
            x28: bigint;
            x29: bigint;
            x30: bigint;
            x31: bigint;
            x32: bigint;
        } | null;
    }>;
    getLongContractTest(provider: ContractProvider): Promise<bigint>;
    getLocation1(provider: ContractProvider): Promise<{
        $$type: "Location";
        idx: bigint;
        line1: {
            $$type: "Line";
            start: {
                $$type: "Point";
                x: bigint;
                y: bigint;
            };
            end: {
                $$type: "Point";
                x: bigint;
                y: bigint;
            };
        };
        line2: {
            $$type: "Line";
            start: {
                $$type: "Point";
                x: bigint;
                y: bigint;
            };
            end: {
                $$type: "Point";
                x: bigint;
                y: bigint;
            };
        } | null;
    }>;
    getLocation2(provider: ContractProvider): Promise<{
        $$type: "Location";
        idx: bigint;
        line1: {
            $$type: "Line";
            start: {
                $$type: "Point";
                x: bigint;
                y: bigint;
            };
            end: {
                $$type: "Point";
                x: bigint;
                y: bigint;
            };
        };
        line2: {
            $$type: "Line";
            start: {
                $$type: "Point";
                x: bigint;
                y: bigint;
            };
            end: {
                $$type: "Point";
                x: bigint;
                y: bigint;
            };
        } | null;
    }>;
    getTripleNestedStructOpt1(provider: ContractProvider): Promise<{
        $$type: "TripleNestedStructOpt";
        a: bigint;
        s: {
            $$type: "DoubleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "MyStruct1";
                a: bigint;
                b: bigint;
                c: bigint | null;
            } | null;
        } | null;
    }>;
    getTripleNestedStructOpt2(provider: ContractProvider): Promise<{
        $$type: "TripleNestedStructOpt";
        a: bigint;
        s: {
            $$type: "DoubleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "MyStruct1";
                a: bigint;
                b: bigint;
                c: bigint | null;
            } | null;
        } | null;
    }>;
    getTripleNestedStructOpt3(provider: ContractProvider): Promise<{
        $$type: "TripleNestedStructOpt";
        a: bigint;
        s: {
            $$type: "DoubleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "MyStruct1";
                a: bigint;
                b: bigint;
                c: bigint | null;
            } | null;
        } | null;
    }>;
    getLongAndDeepNestedStruct1(provider: ContractProvider): Promise<{
        $$type: "LongAndDeepNestedStruct";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
        s1: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        };
        s2: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        };
        s3: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        } | null;
        s4: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        } | null;
    }>;
    getLongAndDeepNestedStruct2(provider: ContractProvider): Promise<{
        $$type: "LongAndDeepNestedStruct";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
        s1: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        };
        s2: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        };
        s3: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        } | null;
        s4: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        } | null;
    }>;
    getLongAndDeepNestedStruct3(provider: ContractProvider): Promise<{
        $$type: "LongAndDeepNestedStruct";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
        s1: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        };
        s2: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        };
        s3: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        } | null;
        s4: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        } | null;
    }>;
    getIntFieldsStruct(provider: ContractProvider): Promise<{
        $$type: "IntFields";
        i1: bigint;
        i2: bigint;
        i3: bigint;
        i255: bigint;
        i256: bigint;
        i257: bigint;
    }>;
    getIntFieldsFromCell(provider: ContractProvider, src: Cell): Promise<{
        $$type: "IntFields";
        i1: bigint;
        i2: bigint;
        i3: bigint;
        i255: bigint;
        i256: bigint;
        i257: bigint;
    }>;
    getUintFieldsMessage(provider: ContractProvider): Promise<{
        $$type: "UintFields";
        u1: bigint;
        u2: bigint;
        u3: bigint;
        u254: bigint;
        u255: bigint;
        u256: bigint;
    }>;
    getUintFieldsFromCell(provider: ContractProvider, src: Cell): Promise<{
        $$type: "UintFields";
        u1: bigint;
        u2: bigint;
        u3: bigint;
        u254: bigint;
        u255: bigint;
        u256: bigint;
    }>;
    getOptionalFields(provider: ContractProvider): Promise<{
        $$type: "OptionalFields";
        nickname: string | null;
        avatar: string | null;
    }>;
    getDestructuringTest1(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest1Const(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest2(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest2Const(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest3(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest3Const(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest4(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest4Const(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest5(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest5Const(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest6(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest6Const(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest7(provider: ContractProvider): Promise<{
        $$type: "S1";
        a: bigint;
        b: bigint;
        c: bigint;
    }>;
    getDestructuringTest7Const(provider: ContractProvider): Promise<{
        $$type: "S1";
        a: bigint;
        b: bigint;
        c: bigint;
    }>;
    getDestructuringTest8(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest8Const(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/ternary_TernaryTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/ternary_TernaryTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type TernaryTester$Data = {
    $$type: 'TernaryTester$Data';
};
export declare function storeTernaryTester$Data(src: TernaryTester$Data): (builder: Builder) => void;
export declare function loadTernaryTester$Data(slice: Slice): {
    $$type: "TernaryTester$Data";
};
export declare const TernaryTester_getterMapping: {
    [key: string]: string;
};
export declare class TernaryTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<TernaryTester>;
    static fromAddress(address: Address): TernaryTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTest1(provider: ContractProvider, a: bigint): Promise<bigint>;
    getTest2(provider: ContractProvider, a: bigint): Promise<bigint>;
    getTest3(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getTest4(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getTest5(provider: ContractProvider): Promise<bigint>;
    getTest6(provider: ContractProvider): Promise<bigint>;
    getTest7(provider: ContractProvider): Promise<bigint>;
    getTest8(provider: ContractProvider): Promise<bigint>;
    getTest9(provider: ContractProvider): Promise<bigint>;
    getTest10(provider: ContractProvider, a: bigint): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/text-message-receivers_TextMessageReceivers.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/text-message-receivers_TextMessageReceivers.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type TextMessageReceivers$Data = {
    $$type: 'TextMessageReceivers$Data';
    counter: bigint;
};
export declare function storeTextMessageReceivers$Data(src: TextMessageReceivers$Data): (builder: Builder) => void;
export declare function loadTextMessageReceivers$Data(slice: Slice): {
    $$type: "TextMessageReceivers$Data";
    counter: bigint;
};
export declare const TextMessageReceivers_getterMapping: {
    [key: string]: string;
};
export declare class TextMessageReceivers implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<TextMessageReceivers>;
    static fromAddress(address: Address): TextMessageReceivers;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "increment'" | "increment-2\\\"" | "increment-3`" | "\\\\increment-4\\\\" | Deploy): Promise<void>;
    getGetCounter(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/traits_LaikaContract.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/traits_LaikaContract.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type LaikaContract$Data = {
    $$type: 'LaikaContract$Data';
};
export declare function storeLaikaContract$Data(src: LaikaContract$Data): (builder: Builder) => void;
export declare function loadLaikaContract$Data(slice: Slice): {
    $$type: "LaikaContract$Data";
};
export declare const LaikaContract_getterMapping: {
    [key: string]: string;
};
export declare class LaikaContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<LaikaContract>;
    static fromAddress(address: Address): LaikaContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | "make sound"): Promise<void>;
    getSay(provider: ContractProvider): Promise<string>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/try-catch_TryCatchTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/try-catch_TryCatchTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type TryCatchTester$Data = {
    $$type: 'TryCatchTester$Data';
    counter: bigint;
};
export declare function storeTryCatchTester$Data(src: TryCatchTester$Data): (builder: Builder) => void;
export declare function loadTryCatchTester$Data(slice: Slice): {
    $$type: "TryCatchTester$Data";
    counter: bigint;
};
export declare const TryCatchTester_getterMapping: {
    [key: string]: string;
};
export declare class TryCatchTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<TryCatchTester>;
    static fromAddress(address: Address): TryCatchTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | "increment" | "incrementTryCatch" | "tryCatchRegisters"): Promise<void>;
    getGetCounter(provider: ContractProvider): Promise<bigint>;
    getTestTryCatch1(provider: ContractProvider): Promise<bigint>;
    getTestTryCatch2(provider: ContractProvider): Promise<bigint>;
    getTestTryCatch3(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/underscore-variable_UnderscoreVariableTestContract.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/underscore-variable_UnderscoreVariableTestContract.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type UnderscoreVariableTestContract$Data = {
    $$type: 'UnderscoreVariableTestContract$Data';
    something: bigint;
};
export declare function storeUnderscoreVariableTestContract$Data(src: UnderscoreVariableTestContract$Data): (builder: Builder) => void;
export declare function loadUnderscoreVariableTestContract$Data(slice: Slice): {
    $$type: "UnderscoreVariableTestContract$Data";
    something: bigint;
};
export declare const UnderscoreVariableTestContract_getterMapping: {
    [key: string]: string;
};
export declare class UnderscoreVariableTestContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<UnderscoreVariableTestContract>;
    static fromAddress(address: Address): UnderscoreVariableTestContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTest1(provider: ContractProvider): Promise<bigint>;
    getTest2(provider: ContractProvider): Promise<bigint>;
    getTest3(provider: ContractProvider): Promise<bigint>;
    getTest4(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Address/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Address/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: Address;
    _2: Address;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Address;
    _2: Address;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Bool/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Bool/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: boolean;
    _2: boolean;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: boolean;
    _2: boolean;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Cell/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Cell/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: Cell;
    _2: Cell;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Cell;
    _2: Cell;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-coins/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-coins/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-int257/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-int257/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-int42/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-int42/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-int8/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-int8/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-uint256/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-uint256/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-uint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-uint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-uint9/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-uint9/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-varint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-varint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-varint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-varint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-varuint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-varuint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-varuint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-varuint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_SomeMessage/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_SomeMessage/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeMessage;
    _2: SomeMessage;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
    _2: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_SomeStruct/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_SomeStruct/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeStruct;
    _2: SomeStruct;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
    _2: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Address/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Address/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Address;
    _2: Address;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Address;
    _2: Address;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Bool/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Bool/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: boolean;
    _2: boolean;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: boolean;
    _2: boolean;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Cell/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Cell/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Cell;
    _2: Cell;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Cell;
    _2: Cell;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-coins/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-coins/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-int257/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-int257/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-int42/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-int42/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-int8/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-int8/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-uint256/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-uint256/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-uint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-uint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-uint9/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-uint9/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-varint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-varint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-varint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-varint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-varuint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-varuint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-varuint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-varuint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_SomeMessage/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_SomeMessage/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeMessage;
    _2: SomeMessage;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
    _2: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_SomeStruct/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_SomeStruct/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeStruct;
    _2: SomeStruct;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
    _2: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Address/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Address/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Address;
    _2: Address;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Address;
    _2: Address;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Bool/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Bool/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: boolean;
    _2: boolean;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: boolean;
    _2: boolean;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Cell/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Cell/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Cell;
    _2: Cell;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Cell;
    _2: Cell;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-coins/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-coins/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-int257/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-int257/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-int42/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-int42/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-int8/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-int8/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-uint256/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-uint256/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-uint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-uint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-uint9/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-uint9/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-varint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-varint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-varint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-varint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-varuint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-varuint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-varuint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-varuint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_SomeMessage/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_SomeMessage/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeMessage;
    _2: SomeMessage;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
    _2: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_SomeStruct/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_SomeStruct/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeStruct;
    _2: SomeStruct;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
    _2: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Address/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Address/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Address;
    _2: Address;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Address;
    _2: Address;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Bool/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Bool/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: boolean;
    _2: boolean;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: boolean;
    _2: boolean;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Cell/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Cell/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Cell;
    _2: Cell;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Cell;
    _2: Cell;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-coins/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-coins/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-int257/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-int257/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-int42/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-int42/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-int8/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-int8/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-uint256/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-uint256/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-uint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-uint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-uint9/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-uint9/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-varint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-varint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-varint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-varint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-varuint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-varuint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-varuint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-varuint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_SomeMessage/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_SomeMessage/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeMessage;
    _2: SomeMessage;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
    _2: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_SomeStruct/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_SomeStruct/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeStruct;
    _2: SomeStruct;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
    _2: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Address/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Address/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Address;
    _2: Address;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Address;
    _2: Address;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Bool/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Bool/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: boolean;
    _2: boolean;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: boolean;
    _2: boolean;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Cell/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Cell/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Cell;
    _2: Cell;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Cell;
    _2: Cell;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-coins/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-coins/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-int257/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-int257/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-int42/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-int42/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-int8/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-int8/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-uint256/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-uint256/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-uint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-uint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-uint9/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-uint9/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-varint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-varint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-varint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-varint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-varuint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-varuint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-varuint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-varuint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_SomeMessage/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_SomeMessage/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeMessage;
    _2: SomeMessage;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
    _2: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_SomeStruct/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_SomeStruct/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeStruct;
    _2: SomeStruct;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
    _2: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Address/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Address/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Address;
    _2: Address;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Address;
    _2: Address;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Bool/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Bool/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: boolean;
    _2: boolean;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: boolean;
    _2: boolean;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Cell/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Cell/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Cell;
    _2: Cell;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Cell;
    _2: Cell;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-coins/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-coins/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-int257/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-int257/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-int42/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-int42/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-int8/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-int8/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-uint256/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-uint256/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-uint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-uint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-uint9/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-uint9/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-varint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-varint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-varint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-varint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-varuint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-varuint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-varuint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-varuint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_SomeMessage/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_SomeMessage/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeMessage;
    _2: SomeMessage;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
    _2: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_SomeStruct/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_SomeStruct/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeStruct;
    _2: SomeStruct;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
    _2: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Address/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Address/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Address;
    _2: Address;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Address;
    _2: Address;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Bool/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Bool/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: boolean;
    _2: boolean;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: boolean;
    _2: boolean;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Cell/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Cell/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Cell;
    _2: Cell;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Cell;
    _2: Cell;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-coins/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-coins/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-int257/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-int257/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-int42/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-int42/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-int8/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-int8/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-uint256/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-uint256/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-uint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-uint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-uint9/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-uint9/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-varint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-varint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-varint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-varint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-varuint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-varuint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-varuint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-varuint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_SomeMessage/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_SomeMessage/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeMessage;
    _2: SomeMessage;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
    _2: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_SomeStruct/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_SomeStruct/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeStruct;
    _2: SomeStruct;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
    _2: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/generate.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/generate.d.ts" {
                export {};

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/map-int-limits-key-value-types.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/map-int-limits-key-value-types.d.ts" {
                type FixedWidthFormat = "int" | "uint";
type VarWidthFormat = "varint" | "varuint";
type MapIntKeyDescription = {
    format: FixedWidthFormat;
    size: number;
} | {
    format: null;
};
type MapIntValDescription = MapIntKeyDescription | {
    format: VarWidthFormat;
    size: 16 | 32;
} | {
    format: "coins";
};
export declare const minInt: (descr: MapIntValDescription) => bigint;
export declare const maxInt: (descr: MapIntValDescription) => bigint;
export declare const descriptionToString: (descr: MapIntValDescription) => string;
export declare const intKeyFormats: MapIntKeyDescription[];
export declare const intValFormats: MapIntValDescription[];
export {};

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/map-properties-key-value-types.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/map-properties-key-value-types.d.ts" {
                type MapType = {
    type: string;
    _1: string;
    _2: string;
};
export declare const keyTypes: MapType[];
export declare const valTypes: MapType[];
export {};

            };
/// <amd-module name="tact-compiler/test/exit-codes/contracts/output/compute-phase-errors_ComputePhaseErrorsTester.d.ts" /> 
 declare module "tact-compiler/test/exit-codes/contracts/output/compute-phase-errors_ComputePhaseErrorsTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type ComputePhaseErrorsTester$Data = {
    $$type: 'ComputePhaseErrorsTester$Data';
    tmpI: bigint;
    tmpC: Cell;
};
export declare function storeComputePhaseErrorsTester$Data(src: ComputePhaseErrorsTester$Data): (builder: Builder) => void;
export declare function loadComputePhaseErrorsTester$Data(slice: Slice): {
    $$type: "ComputePhaseErrorsTester$Data";
    tmpI: bigint;
    tmpC: Cell;
};
export type ExitCode4 = {
    $$type: 'ExitCode4';
    val0: bigint;
    val1: bigint;
};
export declare function storeExitCode4(src: ExitCode4): (builder: Builder) => void;
export declare function loadExitCode4(slice: Slice): {
    $$type: "ExitCode4";
    val0: bigint;
    val1: bigint;
};
export declare const ComputePhaseErrorsTester_getterMapping: {
    [key: string]: string;
};
export declare class ComputePhaseErrorsTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<ComputePhaseErrorsTester>;
    static fromAddress(address: Address): ComputePhaseErrorsTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | "0" | "1" | "2" | "3" | ExitCode4 | "5" | "6" | "7" | "8" | "9" | "10" | "11" | "13"): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/exit-codes/contracts/output/repeat-range_RepeatRangeTester.d.ts" /> 
 declare module "tact-compiler/test/exit-codes/contracts/output/repeat-range_RepeatRangeTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type RepeatRangeTester$Data = {
    $$type: 'RepeatRangeTester$Data';
};
export declare function storeRepeatRangeTester$Data(src: RepeatRangeTester$Data): (builder: Builder) => void;
export declare function loadRepeatRangeTester$Data(slice: Slice): {
    $$type: "RepeatRangeTester$Data";
};
export declare const RepeatRangeTester_getterMapping: {
    [key: string]: string;
};
export declare class RepeatRangeTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<RepeatRangeTester>;
    static fromAddress(address: Address): RepeatRangeTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | "testMaxEffectiveRange"): Promise<void>;
    getTestIgnoredRange(provider: ContractProvider): Promise<boolean>;
    getTestInvalidRange(provider: ContractProvider): Promise<boolean>;
    getTestMinEffectiveRange(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/exit-codes/contracts/output/tact-reserved-contract-errors_ReservedContractErrorsTester.d.ts" /> 
 declare module "tact-compiler/test/exit-codes/contracts/output/tact-reserved-contract-errors_ReservedContractErrorsTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type ChangeOwner = {
    $$type: 'ChangeOwner';
    queryId: bigint;
    newOwner: Address;
};
export declare function storeChangeOwner(src: ChangeOwner): (builder: Builder) => void;
export declare function loadChangeOwner(slice: Slice): {
    $$type: "ChangeOwner";
    queryId: bigint;
    newOwner: Address;
};
export type ChangeOwnerOk = {
    $$type: 'ChangeOwnerOk';
    queryId: bigint;
    newOwner: Address;
};
export declare function storeChangeOwnerOk(src: ChangeOwnerOk): (builder: Builder) => void;
export declare function loadChangeOwnerOk(slice: Slice): {
    $$type: "ChangeOwnerOk";
    queryId: bigint;
    newOwner: Address;
};
export type DNSResolveResult = {
    $$type: 'DNSResolveResult';
    prefix: bigint;
    record: Cell | null;
};
export declare function storeDNSResolveResult(src: DNSResolveResult): (builder: Builder) => void;
export declare function loadDNSResolveResult(slice: Slice): {
    $$type: "DNSResolveResult";
    prefix: bigint;
    record: Cell | null;
};
export type SpanishInquisition = {
    $$type: 'SpanishInquisition';
};
export declare function storeSpanishInquisition(src: SpanishInquisition): (builder: Builder) => void;
export declare function loadSpanishInquisition(slice: Slice): {
    $$type: "SpanishInquisition";
};
export type ReservedContractErrorsTester$Data = {
    $$type: 'ReservedContractErrorsTester$Data';
    owner: Address;
};
export declare function storeReservedContractErrorsTester$Data(src: ReservedContractErrorsTester$Data): (builder: Builder) => void;
export declare function loadReservedContractErrorsTester$Data(slice: Slice): {
    $$type: "ReservedContractErrorsTester$Data";
    owner: Address;
};
export declare const ReservedContractErrorsTester_getterMapping: {
    [key: string]: string;
};
export declare class ReservedContractErrorsTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<ReservedContractErrorsTester>;
    static fromAddress(address: Address): ReservedContractErrorsTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | "128" | "130" | "132" | "134"): Promise<void>;
    getOwner(provider: ContractProvider): Promise<Address>;
}

            };
/// <amd-module name="tact-compiler/test/util.d.ts" /> 
 declare module "tact-compiler/test/util.d.ts" {
                export declare const CONTRACTS_DIR: string;
export declare function trimTrailingCR(input: string): string;

            };
/// <amd-module name="tact-compiler/test/utils/randomAddress.d.ts" /> 
 declare module "tact-compiler/test/utils/randomAddress.d.ts" {
                import { Address } from "@ijstech/ton-core";
export declare function randomAddress(workchain: number, seed: string): Address;

            };
/// <amd-module name="tact-compiler/types/getSupportedInterfaces.d.ts" /> 
 declare module "tact-compiler/types/getSupportedInterfaces.d.ts" {
                import { CompilerContext } from "../context/context";
import { TypeDescription } from "./types";
export declare function getSupportedInterfaces(type: TypeDescription, ctx: CompilerContext): string[];

            };
/// <amd-module name="tact-compiler/types/isRuntimeType.d.ts" /> 
 declare module "tact-compiler/types/isRuntimeType.d.ts" {
                import { TypeRef } from "./types";
export declare function isRuntimeType(src: TypeRef): boolean;

            };
/// <amd-module name="tact-compiler/types/resolveABITypeRef.d.ts" /> 
 declare module "tact-compiler/types/resolveABITypeRef.d.ts" {
                import { ABITypeRef } from "@ijstech/ton-core";
import { AstFieldDecl } from "../ast/ast";
import { TypeRef } from "./types";
import { CompilerContext } from "../context/context";
import { SrcInfo } from "../grammar";
type FormatDef = Record<string, {
    type: string;
    format: string | number;
} | undefined>;
export declare const intMapKeyFormats: FormatDef;
export declare const intMapValFormats: FormatDef;
export declare function resolveABIType(src: AstFieldDecl): ABITypeRef;
export declare function createABITypeRefFromTypeRef(ctx: CompilerContext, src: TypeRef, loc: SrcInfo): ABITypeRef;
export {};

            };
/// <amd-module name="tact-compiler/types/resolveDescriptors.d.ts" /> 
 declare module "tact-compiler/types/resolveDescriptors.d.ts" {
                import { AstId, AstType, AstTypeId, FactoryAst } from "../ast/ast";
import { CompilerContext } from "../context/context";
import { ConstantDescription, FunctionDescription, TypeDescription, TypeRef } from "./types";
export declare const toBounced: (type: string) => string;
export declare function resolveTypeRef(ctx: CompilerContext, type: AstType): TypeRef;
export declare function resolveDescriptors(ctx: CompilerContext, Ast: FactoryAst): CompilerContext;
export declare function getType(ctx: CompilerContext, ident: AstId | AstTypeId | string): TypeDescription;
export declare function getAllTypes(ctx: CompilerContext): TypeDescription[];
export declare function getContracts(ctx: CompilerContext): string[];
export declare function getStaticFunction(ctx: CompilerContext, name: string): FunctionDescription;
export declare function hasStaticFunction(ctx: CompilerContext, name: string): boolean;
export declare function getStaticConstant(ctx: CompilerContext, name: string): ConstantDescription;
export declare function hasStaticConstant(ctx: CompilerContext, name: string): boolean;
export declare function getAllStaticFunctions(ctx: CompilerContext): FunctionDescription[];
export declare function getAllStaticConstants(ctx: CompilerContext): ConstantDescription[];

            };
/// <amd-module name="tact-compiler/types/resolveErrors.d.ts" /> 
 declare module "tact-compiler/types/resolveErrors.d.ts" {
                import { CompilerContext } from "../context/context";
import { FactoryAst } from "../ast/ast";
type Exception = {
    value: string;
    id: number;
};
export declare function resolveErrors(ctx: CompilerContext, Ast: FactoryAst): CompilerContext;
export declare function getAllErrors(ctx: CompilerContext): Exception[];
export declare function getErrorId(value: string, ctx: CompilerContext): number;
export {};

            };
/// <amd-module name="tact-compiler/types/resolveExpression.d.ts" /> 
 declare module "tact-compiler/types/resolveExpression.d.ts" {
                import { AstExpression } from "../ast/ast";
import { CompilerContext } from "../context/context";
import { TypeRef } from "./types";
import { StatementContext } from "./resolveStatements";
export declare function getExpType(ctx: CompilerContext, exp: AstExpression): TypeRef;
export declare function resolveExpression(exp: AstExpression, sctx: StatementContext, ctx: CompilerContext): CompilerContext;
export declare function getAllExpressionTypes(ctx: CompilerContext): [string, string][];

            };
/// <amd-module name="tact-compiler/types/resolveSignatures.d.ts" /> 
 declare module "tact-compiler/types/resolveSignatures.d.ts" {
                import { CompilerContext } from "../context/context";
import { FactoryAst } from "../ast/ast";
export declare function resolveSignatures(ctx: CompilerContext, Ast: FactoryAst): CompilerContext;

            };
/// <amd-module name="tact-compiler/types/resolveStatements.d.ts" /> 
 declare module "tact-compiler/types/resolveStatements.d.ts" {
                import { CompilerContext } from "../context/context";
import { AstId, FactoryAst } from "../ast/ast";
import { TypeRef } from "./types";
import { SrcInfo } from "../grammar";
export type StatementContext = {
    root: SrcInfo;
    funName: string | null;
    returns: TypeRef;
    vars: Map<string, TypeRef>;
    requiredFields: string[];
};
export declare function emptyContext(root: SrcInfo, funName: string | null, returns: TypeRef): StatementContext;
export declare function isLvalue(path: AstId[], ctx: CompilerContext): boolean;
export declare function resolveStatements(ctx: CompilerContext, Ast: FactoryAst): CompilerContext;

            };
/// <amd-module name="tact-compiler/types/subtyping.d.ts" /> 
 declare module "tact-compiler/types/subtyping.d.ts" {
                import { TypeRef } from "./types";
export declare function isAssignable(src: TypeRef, to: TypeRef): boolean;
export declare function moreGeneralType(type1: TypeRef, type2: TypeRef): TypeRef | null;

            };
/// <amd-module name="tact-compiler/types/types.d.ts" /> 
 declare module "tact-compiler/types/types.d.ts" {
                import { ABIField } from "@ijstech/ton-core";
import { AstConstantDef, AstFunctionDef, AstContractInit, AstNativeFunctionDecl, AstReceiver, AstTypeDecl, AstId, AstFunctionDecl, AstConstantDecl, AstFieldDecl, AstAsmFunctionDef, AstNumber, AstLiteral } from "../ast/ast";
import { ItemOrigin, SrcInfo } from "../grammar";
export type TypeDescription = {
    kind: "struct" | "primitive_type_decl" | "contract" | "trait";
    origin: ItemOrigin;
    name: string;
    uid: number;
    header: AstNumber | null;
    tlb: string | null;
    signature: string | null;
    fields: FieldDescription[];
    partialFieldCount: number;
    traits: TypeDescription[];
    functions: Map<string, FunctionDescription>;
    receivers: ReceiverDescription[];
    init: InitDescription | null;
    ast: AstTypeDecl;
    dependsOn: TypeDescription[];
    interfaces: string[];
    constants: ConstantDescription[];
};
export type TypeRef = {
    kind: "ref";
    name: string;
    optional: boolean;
} | {
    kind: "map";
    key: string;
    keyAs: string | null;
    value: string;
    valueAs: string | null;
} | {
    kind: "ref_bounced";
    name: string;
} | {
    kind: "void";
} | {
    kind: "null";
};
export declare function showValue(val: AstLiteral): string;
export type FieldDescription = {
    name: string;
    index: number;
    type: TypeRef;
    as: string | null;
    default: AstLiteral | undefined;
    loc: SrcInfo;
    ast: AstFieldDecl;
    abi: ABIField;
};
export type ConstantDescription = {
    name: string;
    type: TypeRef;
    value: AstLiteral | undefined;
    loc: SrcInfo;
    ast: AstConstantDef | AstConstantDecl;
};
export type FunctionParameter = {
    name: AstId;
    type: TypeRef;
    loc: SrcInfo;
};
export type InitParameter = {
    name: AstId;
    type: TypeRef;
    as: string | null;
    loc: SrcInfo;
};
export type FunctionDescription = {
    name: string;
    origin: ItemOrigin;
    isGetter: boolean;
    methodId: number | null;
    isMutating: boolean;
    isOverride: boolean;
    isVirtual: boolean;
    isAbstract: boolean;
    isInline: boolean;
    self: TypeRef | null;
    returns: TypeRef;
    params: FunctionParameter[];
    ast: AstFunctionDef | AstNativeFunctionDecl | AstFunctionDecl | AstAsmFunctionDef;
};
export type BinaryReceiverSelector = {
    kind: "internal-binary";
    type: string;
    name: AstId;
} | {
    kind: "bounce-binary";
    name: AstId;
    type: string;
    bounced: boolean;
} | {
    kind: "external-binary";
    type: string;
    name: AstId;
};
export type CommentReceiverSelector = {
    kind: "internal-comment";
    comment: string;
} | {
    kind: "external-comment";
    comment: string;
};
type EmptyReceiverSelector = {
    kind: "internal-empty";
} | {
    kind: "external-empty";
};
type FallbackReceiverSelector = {
    kind: "internal-comment-fallback";
    name: AstId;
} | {
    kind: "internal-fallback";
    name: AstId;
} | {
    kind: "bounce-fallback";
    name: AstId;
} | {
    kind: "external-comment-fallback";
    name: AstId;
} | {
    kind: "external-fallback";
    name: AstId;
};
export type ReceiverSelector = BinaryReceiverSelector | CommentReceiverSelector | EmptyReceiverSelector | FallbackReceiverSelector;
export declare function receiverSelectorName(selector: ReceiverSelector): string;
export type ReceiverDescription = {
    selector: ReceiverSelector;
    ast: AstReceiver;
};
export type InitDescription = {
    params: InitParameter[];
    ast: AstContractInit;
};
export declare function printTypeRef(src: TypeRef): string;
export declare function typeRefEquals(a: TypeRef, b: TypeRef): boolean;
export {};

            };
/// <amd-module name="tact-compiler/utils/array.d.ts" /> 
 declare module "tact-compiler/utils/array.d.ts" {
                export declare const isUndefined: <T>(t: T | undefined) => t is undefined;
export declare const groupBy: <T, U>(items: readonly T[], f: (t: T) => U) => readonly (readonly T[])[];
export declare const intercalate: <T>(items: readonly (readonly T[])[], value: T) => readonly T[];

            };
/// <amd-module name="tact-compiler/utils/calculateIPFSlink.d.ts" /> 
 declare module "tact-compiler/utils/calculateIPFSlink.d.ts" {
                export declare function calculateIPFSlink(data: Buffer): Promise<string>;

            };
/// <amd-module name="tact-compiler/utils/crc16.d.ts" /> 
 declare module "tact-compiler/utils/crc16.d.ts" {
                export declare function crc16(data: string | Buffer): number;

            };
/// <amd-module name="tact-compiler/utils/filePath.d.ts" /> 
 declare module "tact-compiler/utils/filePath.d.ts" {
                export declare function posixNormalize(path: string): string;

            };
/// <amd-module name="tact-compiler/utils/idToHex.d.ts" /> 
 declare module "tact-compiler/utils/idToHex.d.ts" {
                export declare function idToHex(id: number): string;

            };
/// <amd-module name="tact-compiler/utils/isSubsetOf.d.ts" /> 
 declare module "tact-compiler/utils/isSubsetOf.d.ts" {
                /** Taken from TypeScript collection lib to perfectly match the .isSubsetOf signature */
export interface ReadonlySetLike<T> {
    /**
     * Despite its name, returns an iterator of the values in the set-like.
     */
    keys(): Iterator<T>;
    /**
     * @returns a boolean indicating whether an element with the specified value exists in the set-like or not.
     */
    has(value: T): boolean;
    /**
     * @returns the number of (unique) elements in the set-like.
     */
    readonly size: number;
}
/**
 * @returns a boolean indicating whether all the elements in Set `one` are also in the `other`.
 */
export declare function isSubsetOf<T>(one: Set<T>, other: ReadonlySetLike<unknown>): boolean;

            };
/// <amd-module name="tact-compiler/utils/loadCases.d.ts" /> 
 declare module "tact-compiler/utils/loadCases.d.ts" {
                export declare function loadCases(src: string): {
    name: string;
    code: string;
}[];

            };
/// <amd-module name="tact-compiler/utils/testKey.d.ts" /> 
 declare module "tact-compiler/utils/testKey.d.ts" {
                export declare function testKey(seed: string): import("@ton/crypto").KeyPair;

            };
/// <amd-module name="tact-compiler/utils/text.d.ts" /> 
 declare module "tact-compiler/utils/text.d.ts" {
                export declare function isBlank(src: string): boolean;
export declare function trimIndent(src: string): string;
/**
 * Escapes unicode control codes in the [src] string
 * See: https://en.m.wikipedia.org/wiki/List_of_Unicode_characters#Control_codes
 */
export declare function escapeUnicodeControlCodes(src: string): string;

            };
/// <amd-module name="tact-compiler/utils/tricks.d.ts" /> 
 declare module "tact-compiler/utils/tricks.d.ts" {
                type Extend<T extends any[], H> = H extends infer A ? [...T, A] : never;
type Flat<TS extends any[], R extends any[] = []> = TS extends [
    infer H,
    ...infer T
] ? Flat<T, Extend<R, H>> : R;
declare const NoSuchCase: unique symbol;
interface NoSuchCaseBug<L> extends Array<never> {
    [NoSuchCase]: L;
}
type On<I extends any[], O> = {
    on: <const DI extends any[]>(...key: I extends Flat<DI> ? DI : NoSuchCaseBug<DI>) => <const DO>(handler: (...args: Extract<I, Flat<DI>>) => DO) => MV<Exclude<I, Flat<DI>>, O | DO>;
};
declare const CasesAreNotExhaustive: unique symbol;
interface NonExhaustiveBug<L> {
    [CasesAreNotExhaustive]: L;
}
type End<I extends any[], O> = [I] extends [never] ? EndInternal<I, O> : {
    otherwise: <const DO>(handle: (...input: I) => DO) => O | DO;
    end: NonExhaustiveBug<I>;
};
type MV<I extends any[], O> = End<I, O> & On<I, O>;
type EndInternal<I extends any[], O> = {
    otherwise: <const DO>(handle: (...input: I) => DO) => O | DO;
    end: () => O;
};
export declare const match: <const I extends any[]>(...args: I) => MV<Flat<I>, never>;
/**
 * Convert union to intersection. See https://stackoverflow.com/q/50374908
 */
type Intersect<T> = (T extends unknown ? (x: T) => 0 : never) extends (x: infer R) => 0 ? R : never;
/**
 * Makes types more readable
 * Example: Unwrap<{ a: 1 } & { b: 2 }> = { a: 1, b: 2 }
 */
type Unwrap<T> = T extends infer R ? {
    [K in keyof R]: R[K];
} : never;
type Inputs<I, T extends string> = I extends {
    [Z in T]: infer K;
} ? K extends string ? Record<K, (input: I) => unknown> : never : never;
type Outputs<O> = {
    [K in keyof O]: (input: never) => O[K];
};
type Handlers<I, O, T extends string> = Unwrap<Intersect<Inputs<I, T>>> & Outputs<O>;
export declare const makeMakeVisitor: <T extends string>(tag: T) => <I>() => <O>(handlers: Handlers<I, O, T>) => (input: Extract<I, { [K in T]: string; }>) => O[keyof O];
/**
 * Make visitor for disjoint union (tagged union, discriminated union)
 */
export declare const makeVisitor: <I>() => <O>(handlers: Handlers<I, O, "kind">) => (input: Extract<I, {
    kind: string;
}>) => O[keyof O];
export {};

            };
/// <amd-module name="tact-compiler/utils/utils.d.ts" /> 
 declare module "tact-compiler/utils/utils.d.ts" {
                export declare function topologicalSort<T>(src: T[], references: (src: T) => T[]): T[];

            };
/// <amd-module name="tact-compiler/utils/Writer.d.ts" /> 
 declare module "tact-compiler/utils/Writer.d.ts" {
                export declare class Writer {
    private indent;
    private lines;
    inIndent: (handler: () => void) => void;
    append(src?: string): void;
    write(src: string): void;
    end(): string;
}

            };
/// <amd-module name="tact-compiler/vfs/createNodeFileSystem.d.ts" /> 
 declare module "tact-compiler/vfs/createNodeFileSystem.d.ts" {
                import { VirtualFileSystem } from "./VirtualFileSystem";
export declare function createNodeFileSystem(root: string, readonly?: boolean): VirtualFileSystem;

            };
/// <amd-module name="tact-compiler/vfs/createVirtualFileSystem.d.ts" /> 
 declare module "tact-compiler/vfs/createVirtualFileSystem.d.ts" {
                import { VirtualFileSystem } from "./VirtualFileSystem";
export declare function createVirtualFileSystem(root: string, fs: Record<string, string>, readonly?: boolean): VirtualFileSystem;

            };
/// <amd-module name="tact-compiler/vfs/VirtualFileSystem.d.ts" /> 
 declare module "tact-compiler/vfs/VirtualFileSystem.d.ts" {
                export type VirtualFileSystem = {
    root: string;
    resolve(...path: string[]): string;
    exists(path: string): boolean;
    readFile(path: string): Buffer;
    writeFile(path: string, content: Buffer | string): void;
};

            };

                export { enableFeatures, build } from "./pipeline/build";
export { precompile } from "./pipeline/precompile";
export { TactError, TactCompilationError, TactInternalCompilerError, TactConstEvalError, TactErrorCollection, } from "./error/errors";
export { optionsSchema, projectSchema, configSchema, } from "./config/parseConfig";
export { AstSorter } from "./ast/sort";
export { AstRenamer } from "./ast/rename";
export { AstHasher } from "./ast/hash";
export { AstComparator } from "./ast/compare";
export { Config, ConfigProject, parseConfig, verifyConfig, } from "./config/parseConfig";
export { PackageFileFormat } from "./packaging/fileFormat";
export { VirtualFileSystem } from "./vfs/VirtualFileSystem";
export { createVirtualFileSystem } from "./vfs/createVirtualFileSystem";
export * from "./browser";
export * from "./context/logger";
export * from "./error/errors";

            };
 export = TactCompiler;

/// <reference types="node" />
/// <amd-module name="@ijstech/compiler/lib" />
declare module "@ijstech/compiler/lib" {
    const Lib: string;
    export default Lib;
}
/// <amd-module name="@ijstech/compiler/parser" />
declare module "@ijstech/compiler/parser" {
    import TS from "./lib/typescript";
    export interface IComponent {
        name: string;
        props?: {
            [name: string]: any;
        };
        items?: IComponent[];
    }
    export interface IMethodNode {
        node?: TS.MethodDeclaration;
        newPos?: number;
    }
    export function findMethodNode(source: TS.ClassDeclaration | TS.SourceFile, funcName: string): IMethodNode | undefined;
    export function findPropertyNode(node: TS.ClassDeclaration, name: string): TS.MethodDeclaration | undefined;
    export function findModuleClassNode(source: TS.SourceFile): TS.ClassDeclaration | undefined;
    export function findComponentImportNodeIfNotExists(source: TS.SourceFile, className: string): number | undefined;
    export function findComponentImports(source: TS.SourceFile, classNames: string[]): {
        classNames: string[];
        newPos: number;
    };
    export function findComponentPropertyNodeIfNotExists(classNode: TS.ClassDeclaration, id: string): number | undefined;
    export function renameMethod(source: TS.SourceFile, oldFunc: string, newFunc: string): string;
    export function renameProperty(source: TS.SourceFile, className: string, oldName: string, newName: string): string | undefined;
    export function addComponentImports(source: TS.SourceFile, classNames: string[]): string | undefined;
    export function addComponentProp(source: TS.SourceFile, className: string, id: string): string | undefined;
    export function addEventHandler(source: TS.SourceFile, classNames: string[], funcName: string, params?: string): {
        lineNumber?: number;
        columnNumber?: number;
        code?: string;
    };
    export function locateMethod(source: TS.SourceFile, funcName: string): {
        lineNumber?: number;
        columnNumber?: number;
    };
    export function locateError(source: TS.SourceFile, pos: number): {
        lineNumber?: number;
        columnNumber?: number;
    };
    export function locateControl(source: TS.SourceFile, control: IComponent): {
        lineNumber?: number;
        columnNumber?: number;
    };
    export function parseUI(source: TS.SourceFile, funcName: string): IComponent | undefined;
    export function renderUI(source: TS.SourceFile, funcName: string, component?: IComponent): string;
}
/// <amd-module name="@ijstech/compiler/path" />
declare module "@ijstech/compiler/path" {
    function basename(path: string, ext?: string): string;
    function dirname(path: string): string;
    function join(...paths: string[]): any;
    function relative(from: string, to: string): string;
    function resolve(...paths: string[]): string;
    const _default: {
        basename: typeof basename;
        dirname: typeof dirname;
        join: typeof join;
        relative: typeof relative;
        resolve: typeof resolve;
    };
    export default _default;
}
/// <amd-module name="@ijstech/compiler/types" />
declare module "@ijstech/compiler/types" {
    import TS from "./lib/typescript";
    export interface ICidInfo {
        cid: string;
        links?: ICidInfo[];
        name?: string;
        size: number;
        type?: 'dir' | 'file';
    }
    export interface IStorage {
        rootPath: string;
        cidToSri(value: string): Promise<string>;
        copyAssets(sourceDir: string, targetDir: string): Promise<void>;
        copyPackage(packName: string, targetDir: string, packages?: string[]): Promise<any>;
        getSCConfig(): Promise<any>;
        getPackage(packName: string): Promise<any>;
        getPackageConfig(): Promise<any>;
        getPackageTypes(packName: string): Promise<IPackage>;
        getFiles(dir: string): Promise<{
            [filePath: string]: string;
        }>;
        hashContent(dir: string): Promise<string>;
        hashDir(dir: string): Promise<ICidInfo>;
        isDirectory(dir: string): Promise<boolean>;
        isFile(filePath: string): Promise<boolean>;
        isFileExists(filePath: string): Promise<boolean>;
        readDir(dir: string): Promise<string[]>;
        readFile(fileName: string): Promise<string>;
        rename(oldPath: string, newPath: string): Promise<void>;
        writeFile(fileName: string, content: string): Promise<void>;
        onCompile?(fileName: string): Promise<void>;
    }
    export interface ICompilerError {
        file: string;
        start: number;
        length: number;
        message: string | TS.DiagnosticMessageChain;
        category: number;
        code: number;
    }
    export interface ICompilerResult {
        errors: ICompilerError[];
        script: {
            [file: string]: string;
        };
        dts: {
            [file: string]: string;
        };
    }
    export type IPackageFiles = {
        [filePath: string]: string;
    };
    export interface IPackage {
        indexFile?: string;
        files?: IPackageFiles;
        path?: string;
        errors?: ICompilerError[];
        script?: {
            [file: string]: string;
        };
        dts?: {
            [file: string]: string;
        };
        dependencies?: string[];
    }
    export interface ISolc {
        compile(source: string, version?: string): any;
    }
    export interface ISource {
        [contract: string]: {
            content: string;
        };
    }
    export type NetworkEnvironment = 'TESTNET' | 'MAINNET' | 'SANDBOX';
}
/// <amd-module name="@ijstech/compiler/solCodeGen" />
declare module "@ijstech/compiler/solCodeGen" {
    interface Type {
        name: string;
        type: string;
        components?: Type[];
        internalType?: string;
    }
    interface Item {
        name: string;
        type: string;
        stateMutability: string;
        inputs?: Type[];
        outputs?: Type[];
    }
    interface LinkReferences {
        [file: string]: {
            [contract: string]: {
                length: number;
                start: number;
            }[];
        };
    }
    export interface IUserDefinedOptions {
        outputAbi: boolean;
        outputBytecode: boolean;
        hasBatchCall?: boolean;
        hasTxData?: boolean;
    }
    export default function (name: string, abiPath: string, abi: Item[], linkReferences: LinkReferences, options: IUserDefinedOptions): string;
}
/// <amd-module name="@ijstech/compiler/solFlatten" />
declare module "@ijstech/compiler/solFlatten" {
    import * as Types from "@ijstech/compiler/types";
    export function flatten(sources: Types.ISource, file: string): Promise<string>;
}
/// <amd-module name="@ijstech/compiler/solCompile" />
declare module "@ijstech/compiler/solCompile" {
    import * as Types from "@ijstech/compiler/types";
    interface OutputOptions {
        abi?: boolean;
        bytecode?: boolean;
        batchCall?: boolean;
        txData?: boolean;
    }
    interface CompileOptions {
        version?: string;
        optimizerRuns?: number;
        viaIR?: boolean;
        outputOptions?: OutputOptions;
    }
    interface Override extends CompileOptions {
        root?: string;
        sources: string[];
    }
    interface Config extends CompileOptions {
        sourceDir?: string;
        sources?: string[];
        artifactsDir?: string;
        outputDir?: string;
        output?: string;
        overrides?: Override[];
        libMap?: {
            [soource: string]: string;
        };
        flattenFiles?: string[];
    }
    export function bundle(solc: Types.ISolc, storage: Types.IStorage, config: Config, RootPath: string): Promise<void>;
}
/// <amd-module name="@ijstech/compiler/tactCompile" />
declare module "@ijstech/compiler/tactCompile" {
    import * as Types from "@ijstech/compiler/types";
    function compileTactContract(storage: Types.IStorage, config: any): Promise<Map<string, Buffer> | undefined>;
    export { compileTactContract };
}
/// <amd-module name="@ijstech/compiler" />
declare module "@ijstech/compiler" {
    import * as Parser from "@ijstech/compiler/parser";
    import TS from "./lib/typescript";
    import Path from "@ijstech/compiler/path";
    export { Parser, Path };
    import * as Types from "@ijstech/compiler/types";
    import { ICompilerError } from "@ijstech/compiler/types";
    export { Types };
    export enum EPackageType {
        contract = "contract",
        dapp = "dapp",
        widget = "widget",
        worker = "worker"
    }
    export function bundleContract(storage: Types.IStorage, solc: Types.ISolc, RootPath?: string): Promise<void>;
    export function bundleTactContract(storage: Types.IStorage, RootPath?: string): Promise<void>;
    export function bundleSdk(storage: Types.IStorage, RootPath?: string): Promise<void>;
    export function bundleLib(storage: Types.IStorage, RootPath?: string): Promise<void>;
    export function bundleDist(bundleType: string, storage: Types.IStorage, RootPath?: string): Promise<void>;
    export function bundleWorker(storage: Types.IStorage, RootPath?: string): Promise<void>;
    export function bundleWidget(storage: Types.IStorage, RootPath?: string): Promise<void>;
    export function bundleDapp(storage: Types.IStorage, RootPath?: string): Promise<void>;
    export function resolveAbsolutePath(baseFilePath: string, relativeFilePath: string): string;
    export type FileImporter = (fileName: string, isPackage?: boolean) => Promise<{
        fileName: string;
        content: string;
    } | null>;
    export type PackageImporter = (packName: string) => Promise<Types.IPackage>;
    export class PackageManager {
        private packageImporter;
        private tsconfig;
        private _packages;
        private _importedPackages;
        constructor(options?: {
            packageImporter?: PackageImporter;
            tsconfig?: any;
        });
        getImportedPackage(name: string): Types.IPackage;
        setImportedPackage(name: string, pack: Types.IPackage): void;
        addPackage(name: string, pack: Types.IPackage): void;
        buildAll(storage?: Types.IStorage): Promise<boolean>;
        buildPackage(name: string, storage?: Types.IStorage): Promise<Types.IPackage>;
        packages(name: string): Types.IPackage;
    }
    export class Compiler {
        private scriptOptions;
        private dtsOptions;
        private files;
        private packageFiles;
        private packages;
        private libs;
        private fileNotExists;
        private resolvedFileName;
        dependencies: string[];
        private host;
        private packageManager;
        private packageImporter;
        constructor(options?: {
            packageManager?: PackageManager;
            packageImporter?: PackageImporter;
            tsconfig?: any;
        });
        private importDependencies;
        addFile(fileName: string, content: string, dependenciesImporter?: FileImporter): Promise<string[]>;
        updateFile(fileName: string, content: string): void;
        private getProgram;
        addPackage(packName: string, pack?: Types.IPackage): Promise<{
            fileName: string;
            content: string;
        } | undefined>;
        compile(emitDeclaration?: boolean): Promise<Types.ICompilerResult>;
        getSource(fileName: string): TS.SourceFile | undefined;
        addComponentProp(fileName: string, className: string, id: string): string | undefined;
        addEventHandler(fileName: string, classNames: string[], func: string, params?: string): {
            code?: string;
            lineNumber?: number;
            columnNumber?: number;
        };
        locateMethod(fileName: string, funcName: string): {
            lineNumber?: number;
            columnNumber?: number;
        };
        locateError(error: ICompilerError): {
            lineNumber?: number;
            columnNumber?: number;
        };
        locateControl(fileName: string, control: Parser.IComponent): {
            lineNumber?: number;
            columnNumber?: number;
        };
        renameMethod(fileName: string, fromFuncName: string, toFuncName: string): string | undefined;
        renameComponent(fileName: string, className: string, fromId: string, toId: string): string | undefined;
        parseUI(fileName: string, funcName?: string): Parser.IComponent | undefined;
        renderUI(fileName: string, funcName?: string, component?: Parser.IComponent): string | undefined;
        fileExists(fileName: string): boolean;
        getDependencies(fileName: string, content: string, fileImporter?: FileImporter, result?: string[]): Promise<string[]>;
        getSourceFile(fileName: string, languageVersion: TS.ScriptTarget, onError?: (message: string) => void): TS.SourceFile | undefined;
        readFile(fileName: string): string | undefined;
        resolveModuleNames(moduleNames: string[], containingFile: string): TS.ResolvedModule[];
    }
}
