declare namespace TactCompiler {
                /// <amd-module name="tact-compiler/abi/AbiFunction.d.ts" /> 
 declare module "tact-compiler/abi/AbiFunction.d.ts" {
                import { AstExpression } from "../ast/ast";
import { CompilerContext } from "../context/context";
import { WriterContext } from "../generator/Writer";
import { TypeRef } from "../types/types";
import { SrcInfo } from "../grammar";
export type AbiFunction = {
    name: string;
    resolve: (ctx: CompilerContext, args: TypeRef[], loc: SrcInfo) => TypeRef;
    generate: (ctx: WriterContext, args: TypeRef[], resolved: AstExpression[], loc: SrcInfo) => string;
};

            };
/// <amd-module name="tact-compiler/abi/errors.d.ts" /> 
 declare module "tact-compiler/abi/errors.d.ts" {
                export declare const contractErrors: {
    null: {
        id: number;
        message: string;
    };
    invalidPrefix: {
        id: number;
        message: string;
    };
    invalidMessage: {
        id: number;
        message: string;
    };
    constraintsError: {
        id: number;
        message: string;
    };
    accessDenied: {
        id: number;
        message: string;
    };
    contractStopped: {
        id: number;
        message: string;
    };
    invalidArgument: {
        id: number;
        message: string;
    };
    codeNotFound: {
        id: number;
        message: string;
    };
};

            };
/// <amd-module name="tact-compiler/abi/global.d.ts" /> 
 declare module "tact-compiler/abi/global.d.ts" {
                import { AbiFunction } from "./AbiFunction";
export declare const GlobalFunctions: Map<string, AbiFunction>;

            };
/// <amd-module name="tact-compiler/abi/map.d.ts" /> 
 declare module "tact-compiler/abi/map.d.ts" {
                import { AbiFunction } from "./AbiFunction";
export declare const MapFunctions: Map<string, AbiFunction>;

            };
/// <amd-module name="tact-compiler/abi/struct.d.ts" /> 
 declare module "tact-compiler/abi/struct.d.ts" {
                import { AbiFunction } from "./AbiFunction";
export declare const StructFunctions: Map<string, AbiFunction>;

            };
/// <amd-module name="tact-compiler/ast/ast.d.ts" /> 
 declare module "tact-compiler/ast/ast.d.ts" {
                import { Address, Cell, Slice } from "@ijstech/ton-core";
import { SrcInfo } from "../grammar/src-info";
export type AstModule = {
    kind: "module";
    imports: AstImport[];
    items: AstModuleItem[];
    id: number;
};
export type AstImport = {
    kind: "import";
    path: AstString;
    id: number;
    loc: SrcInfo;
};
export type AstModuleItem = AstPrimitiveTypeDecl | AstFunctionDef | AstAsmFunctionDef | AstNativeFunctionDecl | AstConstantDef | AstStructDecl | AstMessageDecl | AstContract | AstTrait;
export type AstTypeDecl = AstPrimitiveTypeDecl | AstStructDecl | AstMessageDecl | AstContract | AstTrait;
export type AstPrimitiveTypeDecl = {
    kind: "primitive_type_decl";
    name: AstId;
    id: number;
    loc: SrcInfo;
};
export type AstFunctionDef = {
    kind: "function_def";
    attributes: AstFunctionAttribute[];
    name: AstId;
    return: AstType | null;
    params: AstTypedParameter[];
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstAsmFunctionDef = {
    kind: "asm_function_def";
    shuffle: AstAsmShuffle;
    attributes: AstFunctionAttribute[];
    name: AstId;
    return: AstType | null;
    params: AstTypedParameter[];
    instructions: AstAsmInstruction[];
    id: number;
    loc: SrcInfo;
};
export type AstAsmInstruction = string;
export type AstAsmShuffle = {
    args: AstId[];
    ret: AstNumber[];
};
export type AstFunctionDecl = {
    kind: "function_decl";
    attributes: AstFunctionAttribute[];
    name: AstId;
    return: AstType | null;
    params: AstTypedParameter[];
    id: number;
    loc: SrcInfo;
};
export type AstNativeFunctionDecl = {
    kind: "native_function_decl";
    attributes: AstFunctionAttribute[];
    name: AstId;
    nativeName: AstFuncId;
    params: AstTypedParameter[];
    return: AstType | null;
    id: number;
    loc: SrcInfo;
};
export type AstConstantDef = {
    kind: "constant_def";
    attributes: AstConstantAttribute[];
    name: AstId;
    type: AstType;
    initializer: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstConstantDecl = {
    kind: "constant_decl";
    attributes: AstConstantAttribute[];
    name: AstId;
    type: AstType;
    id: number;
    loc: SrcInfo;
};
export type AstStructDecl = {
    kind: "struct_decl";
    name: AstId;
    fields: AstFieldDecl[];
    id: number;
    loc: SrcInfo;
};
export type AstMessageDecl = {
    kind: "message_decl";
    name: AstId;
    opcode: AstExpression | null;
    fields: AstFieldDecl[];
    id: number;
    loc: SrcInfo;
};
export type AstContract = {
    kind: "contract";
    name: AstId;
    traits: AstId[];
    attributes: AstContractAttribute[];
    declarations: AstContractDeclaration[];
    id: number;
    loc: SrcInfo;
};
export type AstTrait = {
    kind: "trait";
    name: AstId;
    traits: AstId[];
    attributes: AstContractAttribute[];
    declarations: AstTraitDeclaration[];
    id: number;
    loc: SrcInfo;
};
export type AstContractDeclaration = AstFieldDecl | AstFunctionDef | AstAsmFunctionDef | AstContractInit | AstReceiver | AstConstantDef;
export type AstTraitDeclaration = AstFieldDecl | AstFunctionDef | AstAsmFunctionDef | AstFunctionDecl | AstReceiver | AstConstantDef | AstConstantDecl;
export type AstFieldDecl = {
    kind: "field_decl";
    name: AstId;
    type: AstType;
    initializer: AstExpression | null;
    as: AstId | null;
    id: number;
    loc: SrcInfo;
};
export type AstReceiver = {
    kind: "receiver";
    selector: AstReceiverKind;
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstContractInit = {
    kind: "contract_init";
    params: AstTypedParameter[];
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstStatement = AstStatementLet | AstStatementReturn | AstStatementExpression | AstStatementAssign | AstStatementAugmentedAssign | AstCondition | AstStatementWhile | AstStatementUntil | AstStatementRepeat | AstStatementTry | AstStatementTryCatch | AstStatementForEach | AstStatementDestruct | AstStatementBlock;
export type AstStatementLet = {
    kind: "statement_let";
    name: AstId;
    type: AstType | null;
    expression: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstStatementReturn = {
    kind: "statement_return";
    expression: AstExpression | null;
    id: number;
    loc: SrcInfo;
};
export type AstStatementExpression = {
    kind: "statement_expression";
    expression: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstStatementAssign = {
    kind: "statement_assign";
    path: AstExpression;
    expression: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstAugmentedAssignOperation = "+" | "-" | "*" | "/" | "&&" | "||" | "%" | "|" | "<<" | ">>" | "&" | "^";
export type AstStatementAugmentedAssign = {
    kind: "statement_augmentedassign";
    op: AstAugmentedAssignOperation;
    path: AstExpression;
    expression: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstCondition = {
    kind: "statement_condition";
    condition: AstExpression;
    trueStatements: AstStatement[];
    falseStatements: AstStatement[] | null;
    elseif: AstCondition | null;
    id: number;
    loc: SrcInfo;
};
export type AstStatementWhile = {
    kind: "statement_while";
    condition: AstExpression;
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstStatementUntil = {
    kind: "statement_until";
    condition: AstExpression;
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstStatementRepeat = {
    kind: "statement_repeat";
    iterations: AstExpression;
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstStatementTry = {
    kind: "statement_try";
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstStatementTryCatch = {
    kind: "statement_try_catch";
    statements: AstStatement[];
    catchName: AstId;
    catchStatements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstStatementForEach = {
    kind: "statement_foreach";
    keyName: AstId;
    valueName: AstId;
    map: AstExpression;
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstStatementDestruct = {
    kind: "statement_destruct";
    type: AstTypeId;
    /** field name -> [field id, local id] */
    identifiers: Map<string, [AstId, AstId]>;
    ignoreUnspecifiedFields: boolean;
    expression: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstStatementBlock = {
    kind: "statement_block";
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};
export type AstType = AstTypeId | AstOptionalType | AstMapType | AstBouncedMessageType;
export type AstTypeId = {
    kind: "type_id";
    text: string;
    id: number;
    loc: SrcInfo;
};
export type AstOptionalType = {
    kind: "optional_type";
    typeArg: AstType;
    id: number;
    loc: SrcInfo;
};
export type AstMapType = {
    kind: "map_type";
    keyType: AstTypeId;
    keyStorageType: AstId | null;
    valueType: AstTypeId;
    valueStorageType: AstId | null;
    id: number;
    loc: SrcInfo;
};
export type AstBouncedMessageType = {
    kind: "bounced_message_type";
    messageType: AstTypeId;
    id: number;
    loc: SrcInfo;
};
export type AstExpression = AstOpBinary | AstOpUnary | AstConditional | AstMethodCall | AstFieldAccess | AstStaticCall | AstStructInstance | AstId | AstInitOf | AstString | AstLiteral;
export type AstLiteral = AstNumber | AstBoolean | AstNull | AstSimplifiedString | AstAddress | AstCell | AstSlice | AstCommentValue | AstStructValue;
export type AstBinaryOperation = "+" | "-" | "*" | "/" | "!=" | ">" | "<" | ">=" | "<=" | "==" | "&&" | "||" | "%" | "<<" | ">>" | "&" | "|" | "^";
export type AstOpBinary = {
    kind: "op_binary";
    op: AstBinaryOperation;
    left: AstExpression;
    right: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstUnaryOperation = "+" | "-" | "!" | "!!" | "~";
export type AstOpUnary = {
    kind: "op_unary";
    op: AstUnaryOperation;
    operand: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstFieldAccess = {
    kind: "field_access";
    aggregate: AstExpression;
    field: AstId;
    id: number;
    loc: SrcInfo;
};
export type AstMethodCall = {
    kind: "method_call";
    self: AstExpression;
    method: AstId;
    args: AstExpression[];
    id: number;
    loc: SrcInfo;
};
export type AstStaticCall = {
    kind: "static_call";
    function: AstId;
    args: AstExpression[];
    id: number;
    loc: SrcInfo;
};
export type AstStructInstance = {
    kind: "struct_instance";
    type: AstId;
    args: AstStructFieldInitializer[];
    id: number;
    loc: SrcInfo;
};
export type AstStructFieldInitializer = {
    kind: "struct_field_initializer";
    field: AstId;
    initializer: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstInitOf = {
    kind: "init_of";
    contract: AstId;
    args: AstExpression[];
    id: number;
    loc: SrcInfo;
};
export type AstConditional = {
    kind: "conditional";
    condition: AstExpression;
    thenBranch: AstExpression;
    elseBranch: AstExpression;
    id: number;
    loc: SrcInfo;
};
export type AstId = {
    kind: "id";
    text: string;
    id: number;
    loc: SrcInfo;
};
export type AstFuncId = {
    kind: "func_id";
    text: string;
    id: number;
    loc: SrcInfo;
};
export declare function idText(ident: AstId | AstFuncId | AstTypeId): string;
export declare function isInt(ident: AstTypeId): boolean;
export declare function isBool(ident: AstTypeId): boolean;
export declare function isCell(ident: AstTypeId): boolean;
export declare function isSlice(ident: AstTypeId): boolean;
export declare function isBuilder(ident: AstTypeId): boolean;
export declare function isAddress(ident: AstTypeId): boolean;
export declare function isString(ident: AstTypeId): boolean;
export declare function isStringBuilder(ident: AstTypeId): boolean;
export declare function isSelfId(ident: AstId): boolean;
export declare function isWildcard(ident: AstId): boolean;
export declare function isRequire(ident: AstId): boolean;
export declare function eqNames(left: AstId | AstTypeId | string, right: AstId | AstTypeId | string): boolean;
export declare function idOfText(text: string): AstId;
export declare const selfId: AstId;
export type AstDestructMapping = {
    kind: "destruct_mapping";
    field: AstId;
    name: AstId;
    id: number;
    loc: SrcInfo;
};
export type AstDestructEnd = {
    kind: "destruct_end";
    ignoreUnspecifiedFields: boolean;
    id: number;
    loc: SrcInfo;
};
export type AstNumber = {
    kind: "number";
    base: AstNumberBase;
    value: bigint;
    id: number;
    loc: SrcInfo;
};
export type AstNumberBase = 2 | 8 | 10 | 16;
export declare function astNumToString(n: AstNumber): string;
export type AstBoolean = {
    kind: "boolean";
    value: boolean;
    id: number;
    loc: SrcInfo;
};
export type AstSimplifiedString = {
    kind: "simplified_string";
    value: string;
    id: number;
    loc: SrcInfo;
};
/**
 * @deprecated AstSimplifiedString
 */
export type AstString = {
    kind: "string";
    value: string;
    id: number;
    loc: SrcInfo;
};
export type AstNull = {
    kind: "null";
    id: number;
    loc: SrcInfo;
};
export type AstAddress = {
    kind: "address";
    value: Address;
    id: number;
    loc: SrcInfo;
};
export type AstCell = {
    kind: "cell";
    value: Cell;
    id: number;
    loc: SrcInfo;
};
export type AstSlice = {
    kind: "slice";
    value: Slice;
    id: number;
    loc: SrcInfo;
};
export type AstCommentValue = {
    kind: "comment_value";
    value: string;
    id: number;
    loc: SrcInfo;
};
export type AstStructValue = {
    kind: "struct_value";
    type: AstId;
    args: AstStructFieldValue[];
    id: number;
    loc: SrcInfo;
};
export type AstStructFieldValue = {
    kind: "struct_field_value";
    field: AstId;
    initializer: AstLiteral;
    id: number;
    loc: SrcInfo;
};
export type AstConstantAttributeName = "virtual" | "override" | "abstract";
export type AstConstantAttribute = {
    type: AstConstantAttributeName;
    loc: SrcInfo;
};
export type AstContractAttribute = {
    type: "interface";
    name: AstString;
    loc: SrcInfo;
};
export type AstFunctionAttributeGet = {
    kind: "function_attribute";
    type: "get";
    methodId: AstExpression | null;
    loc: SrcInfo;
};
export type AstFunctionAttributeName = "mutates" | "extends" | "virtual" | "abstract" | "override" | "inline";
export type AstFunctionAttributeRest = {
    kind: "function_attribute";
    type: AstFunctionAttributeName;
    loc: SrcInfo;
};
export type AstFunctionAttribute = AstFunctionAttributeGet | AstFunctionAttributeRest;
export type AstTypedParameter = {
    kind: "typed_parameter";
    name: AstId;
    type: AstType;
    id: number;
    loc: SrcInfo;
};
export type AstReceiverKind = {
    kind: "internal-simple";
    param: AstTypedParameter;
} | {
    kind: "internal-fallback";
} | {
    kind: "internal-comment";
    comment: AstString;
} | {
    kind: "bounce";
    param: AstTypedParameter;
} | {
    kind: "external-simple";
    param: AstTypedParameter;
} | {
    kind: "external-fallback";
} | {
    kind: "external-comment";
    comment: AstString;
};
export type AstNode = AstFuncId | AstDestructMapping | AstDestructEnd | AstExpression | AstStatement | AstTypeDecl | AstFieldDecl | AstTypedParameter | AstFunctionDef | AstFunctionAttribute | AstAsmFunctionDef | AstFunctionDecl | AstModule | AstNativeFunctionDecl | AstStructFieldInitializer | AstStructFieldValue | AstType | AstContractInit | AstReceiver | AstImport | AstConstantDef | AstConstantDecl;
/**
 * Check if input expression is a 'path expression',
 * i.e. an identifier or a sequence of field accesses starting from an identifier.
 * @param path A path expression to check.
 * @returns An array of identifiers or null if the input expression is not a path expression.
 */
export declare function tryExtractPath(path: AstExpression): AstId[] | null;
type DistributiveOmit<T, K extends keyof any> = T extends any ? Omit<T, K> : never;
export declare const getAstFactory: () => {
    createNode: (src: DistributiveOmit<AstNode, "id">) => AstNode;
    cloneNode: <T extends AstNode>(src: T) => T;
};
export type FactoryAst = ReturnType<typeof getAstFactory>;
export declare function eqExpressions(ast1: AstExpression, ast2: AstExpression): boolean;
export declare function isLiteral(ast: AstExpression): ast is AstLiteral;
export declare function checkLiteral<T>(ast: AstExpression, t: (node: AstLiteral) => T, f: (node: Exclude<AstExpression, AstLiteral>) => T): T;
export {};

            };
/// <amd-module name="tact-compiler/ast/clone.d.ts" /> 
 declare module "tact-compiler/ast/clone.d.ts" {
                import { AstNode, FactoryAst } from "./ast";
export declare function cloneNode<T extends AstNode>(src: T, { cloneNode }: FactoryAst): T;

            };
/// <amd-module name="tact-compiler/ast/compare.d.ts" /> 
 declare module "tact-compiler/ast/compare.d.ts" {
                import { AstNode } from "./ast";
/**
 * Provides an API to compare two AST nodes with extra options.
 */
export declare class AstComparator {
    private readonly sort;
    private readonly canonicalize;
    /**
     * @param sort Topologically sort AST entries before comparing. Should be enabled
     *        in order to handle duplicate entries shuffled in the source code.
     * @param canonicalize Introduce de Brujin indices for local bindings to handle
     *        duplicate code with different names. Should be enabled in order to
     *        treat duplicate entries with different names as the same elements.
     */
    private constructor();
    static make(options?: Partial<{
        sort: boolean;
        canonicalize: boolean;
    }>): AstComparator;
    compare(node1: AstNode, node2: AstNode): boolean;
    private compareNullableNodes;
    private compareArray;
    private compareNullableArray;
    private compareAsmInstructions;
    private compareAttributes;
    private compareReceiverKinds;
}

            };
/// <amd-module name="tact-compiler/ast/getAstSchema.d.ts" /> 
 declare module "tact-compiler/ast/getAstSchema.d.ts" {
                /**
 * AST node constructors are not just constructors: they also generate ids
 * We have this file so that the "current id" state would not be stored globally
 */
import { Loc } from "@tonstudio/parser-runtime";
import * as A from "./ast";
import { SrcInfo } from "../grammar/src-info";
export declare const getAstSchema: (factory: A.FactoryAst, toSrcInfo: (location: Loc) => SrcInfo) => {
    Module: (imports: A.AstImport[], items: A.AstModuleItem[]) => A.AstModule;
    Import: (path: A.AstString, loc: Loc) => A.AstImport;
    PrimitiveTypeDecl: (name: A.AstId, loc: Loc) => A.AstPrimitiveTypeDecl;
    FunctionDef: (attributes: A.AstFunctionAttribute[], name: A.AstId, retType: A.AstType | null, params: A.AstTypedParameter[], statements: A.AstStatement[], loc: Loc) => A.AstFunctionDef;
    AsmFunctionDef: (shuffle: A.AstAsmShuffle, attributes: A.AstFunctionAttribute[], name: A.AstId, retType: A.AstType | null, params: A.AstTypedParameter[], instructions: A.AstAsmInstruction[], loc: Loc) => A.AstAsmFunctionDef;
    FunctionDecl: (attributes: A.AstFunctionAttribute[], name: A.AstId, retType: A.AstType | null, params: A.AstTypedParameter[], loc: Loc) => A.AstFunctionDecl;
    NativeFunctionDecl: (attributes: A.AstFunctionAttribute[], name: A.AstId, nativeName: A.AstFuncId, params: A.AstTypedParameter[], retType: A.AstType | null, loc: Loc) => A.AstNativeFunctionDecl;
    ConstantDef: (attributes: A.AstConstantAttribute[], name: A.AstId, type: A.AstType, initializer: A.AstExpression, loc: Loc) => A.AstConstantDef;
    ConstantDecl: (attributes: A.AstConstantAttribute[], name: A.AstId, type: A.AstType, loc: Loc) => A.AstConstantDecl;
    StructDecl: (name: A.AstId, fields: A.AstFieldDecl[], loc: Loc) => A.AstStructDecl;
    MessageDecl: (name: A.AstId, opcode: A.AstExpression | null, fields: A.AstFieldDecl[], loc: Loc) => A.AstMessageDecl;
    Contract: (name: A.AstId, traits: A.AstId[], attributes: A.AstContractAttribute[], declarations: A.AstContractDeclaration[], loc: Loc) => A.AstContract;
    Trait: (name: A.AstId, traits: A.AstId[], attributes: A.AstContractAttribute[], declarations: A.AstTraitDeclaration[], loc: Loc) => A.AstTrait;
    FieldDecl: (name: A.AstId, type: A.AstType, initializer: A.AstExpression | null, as: A.AstId | null, loc: Loc) => A.AstFieldDecl;
    Receiver: (selector: A.AstReceiverKind, statements: A.AstStatement[], loc: Loc) => A.AstReceiver;
    ContractInit: (params: A.AstTypedParameter[], statements: A.AstStatement[], loc: Loc) => A.AstContractInit;
    StatementLet: (name: A.AstId, type: A.AstType | null, expression: A.AstExpression, loc: Loc) => A.AstStatementLet;
    StatementDestruct: (type: A.AstTypeId, identifiers: Map<string, [A.AstId, A.AstId]>, ignoreUnspecifiedFields: boolean, expression: A.AstExpression, loc: Loc) => A.AstStatementDestruct;
    StatementReturn: (expression: A.AstExpression | null, loc: Loc) => A.AstStatementReturn;
    StatementExpression: (expression: A.AstExpression, loc: Loc) => A.AstStatementExpression;
    StatementAssign: (path: A.AstExpression, expression: A.AstExpression, loc: Loc) => A.AstStatementAssign;
    StatementAugmentedAssign: (op: A.AstAugmentedAssignOperation, path: A.AstExpression, expression: A.AstExpression, loc: Loc) => A.AstStatementAugmentedAssign;
    Condition: (condition: A.AstExpression, trueStatements: A.AstStatement[], falseStatements: A.AstStatement[] | null, elseif: A.AstCondition | null, loc: Loc) => A.AstCondition;
    StatementWhile: (condition: A.AstExpression, statements: A.AstStatement[], loc: Loc) => A.AstStatementWhile;
    StatementUntil: (condition: A.AstExpression, statements: A.AstStatement[], loc: Loc) => A.AstStatementUntil;
    StatementRepeat: (iterations: A.AstExpression, statements: A.AstStatement[], loc: Loc) => A.AstStatementRepeat;
    StatementTry: (statements: A.AstStatement[], loc: Loc) => A.AstStatementTry;
    StatementTryCatch: (statements: A.AstStatement[], catchName: A.AstId, catchStatements: A.AstStatement[], loc: Loc) => A.AstStatementTryCatch;
    StatementForEach: (keyName: A.AstId, valueName: A.AstId, map: A.AstExpression, statements: A.AstStatement[], loc: Loc) => A.AstStatementForEach;
    StatementBlock: (statements: A.AstStatement[], loc: Loc) => A.AstStatementBlock;
    TypeId: (text: string, loc: Loc) => A.AstTypeId;
    OptionalType: (typeArg: A.AstType, loc: Loc) => A.AstOptionalType;
    MapType: (keyType: A.AstTypeId, keyStorageType: A.AstId | null, valueType: A.AstTypeId, valueStorageType: A.AstId | null, loc: Loc) => A.AstMapType;
    BouncedMessageType: (messageType: A.AstTypeId, loc: Loc) => A.AstBouncedMessageType;
    OpBinary: (op: A.AstBinaryOperation, left: A.AstExpression, right: A.AstExpression, loc: Loc) => A.AstOpBinary;
    OpUnary: (op: A.AstUnaryOperation, operand: A.AstExpression, loc: Loc) => A.AstOpUnary;
    FieldAccess: (aggregate: A.AstExpression, field: A.AstId, loc: Loc) => A.AstFieldAccess;
    MethodCall: (self: A.AstExpression, method: A.AstId, args: A.AstExpression[], loc: Loc) => A.AstMethodCall;
    StaticCall: (funcId: A.AstId, args: A.AstExpression[], loc: Loc) => A.AstStaticCall;
    StructInstance: (type: A.AstId, args: A.AstStructFieldInitializer[], loc: Loc) => A.AstStructInstance;
    StructFieldInitializer: (field: A.AstId, initializer: A.AstExpression, loc: Loc) => A.AstStructFieldInitializer;
    InitOf: (contract: A.AstId, args: A.AstExpression[], loc: Loc) => A.AstInitOf;
    Conditional: (condition: A.AstExpression, thenBranch: A.AstExpression, elseBranch: A.AstExpression, loc: Loc) => A.AstConditional;
    Id: (text: string, loc: Loc) => A.AstId;
    FuncId: (text: string, loc: Loc) => A.AstFuncId;
    Null: (loc: Loc) => A.AstNull;
    String: (value: string, loc: Loc) => A.AstString;
    Boolean: (value: boolean, loc: Loc) => A.AstBoolean;
    Number: (base: A.AstNumberBase, value: bigint, loc: Loc) => A.AstNumber;
    ContractAttribute: (name: A.AstString, loc: Loc) => A.AstContractAttribute;
    FunctionAttributeGet: (methodId: A.AstExpression | null, loc: Loc) => A.AstFunctionAttributeGet;
    FunctionAttribute: (type: A.AstFunctionAttributeName, loc: Loc) => A.AstFunctionAttributeRest;
    ConstantAttribute: (type: A.AstConstantAttributeName, loc: Loc) => A.AstConstantAttribute;
    TypedParameter: (name: A.AstId, type: A.AstType, loc: Loc) => A.AstTypedParameter;
};
/**
 * List of all constructors for AST nodes
 */
export type AstSchema = ReturnType<typeof getAstSchema>;

            };
/// <amd-module name="tact-compiler/ast/hash.d.ts" /> 
 declare module "tact-compiler/ast/hash.d.ts" {
                import { AstNode } from "./ast";
export type AstHash = string;
/**
 * Provides functionality to hash AST nodes regardless of identifiers.
 */
export declare class AstHasher {
    private readonly sort;
    private constructor();
    static make(params?: Partial<{
        sort: boolean;
    }>): AstHasher;
    hash(node: AstNode): AstHash;
    /**
     * Generates a string that is used to create a hash.
     */
    private getHashData;
    private hashDestructIdentifiers;
    private hashStructDecl;
    private hashMessageDecl;
    private hashFunctionDef;
    private hashAsmFunctionDef;
    private hashConstantDef;
    private hashTrait;
    private hashContract;
    private hashFields;
    private hashParams;
    private hashTypedParameter;
    private hashAttributes;
    private hashContractAttributes;
    private hashIds;
    private hashDeclarations;
    private hashStatements;
    private hashInstructions;
    private hashStructFieldInitializer;
    private hashFieldDecl;
    private hashContractInit;
    private hashNativeFunctionDecl;
    private hashReceiver;
    private hashFunctionDecl;
    private hashImport;
    private hashConstantDecl;
    private hashModule;
    private hashImports;
    private hashModuleItems;
}

            };
/// <amd-module name="tact-compiler/ast/iterators.d.ts" /> 
 declare module "tact-compiler/ast/iterators.d.ts" {
                import { AstNode } from "./ast";
/**
 * Recursively iterates over each node in an AstNode and applies a callback to each AST element.
 * @public
 * @param node The node to traverse.
 * @param callback The callback function to apply to each AST element.
 */
export declare function traverse(node: AstNode, callback: (node: AstNode) => void): void;

            };
/// <amd-module name="tact-compiler/ast/rename.d.ts" /> 
 declare module "tact-compiler/ast/rename.d.ts" {
                import { AstModuleItem, AstModule, AstNode } from "./ast";
/**
 * An utility class that provides alpha-renaming and topological sort functionality
 * for the AST comparison.
 */
export declare class AstRenamer {
    private sort;
    private currentIdx;
    private renamed;
    private givenNames;
    private constructor();
    static make(params?: Partial<{
        sort: boolean;
    }>): AstRenamer;
    /**
     * Renames the given node based on its AST.
     */
    renameModule(module: AstModule): AstNode;
    private nextIdx;
    /**
     * Generates a new unique node name.
     */
    private generateName;
    /**
     * Tries to get an identifier based on the node definition.
     */
    private getName;
    /**
     * Sets new or an existent name based on node's hash.
     */
    private setName;
    renameModuleItems(items: AstModuleItem[]): AstModuleItem[];
    /**
     * Lexicographically sort items based on their kinds and then by their names.
     */
    private sortModuleItems;
    /**
     * Changes the name of a top-level/contract/trait element without inspecting its body.
     */
    private changeItemName;
    /**
     * Renames the contents of an AstModuleItem based on its kind.
     */
    private renameModuleItemContents;
    /**
     * Sorts attributes within an item if available.
     */
    private sortAttributes;
    /**
     * Renames the contents of a function.
     */
    private renameFunctionContents;
    /**
     * Renames getter's methodId expression.
     */
    private renameFunctionAttributes;
    /**
     * Renames the contents of a constant, focusing on the initializer.
     */
    private renameConstantContents;
    /**
     * Renames the contents of a trait, including its declarations.
     */
    private renameTraitContents;
    /**
     * Renames the contents of a contract, including its declarations and parameters.
     */
    private renameContractContents;
    private renameStatements;
    private renameStatement;
    private renameExpression;
    private renameStructFieldInitializer;
}

            };
/// <amd-module name="tact-compiler/ast/sort.d.ts" /> 
 declare module "tact-compiler/ast/sort.d.ts" {
                import { AstFunctionAttribute, AstConstantAttribute, AstContractAttribute, AstNode } from "./ast";
/**
 * Provides utilities to sort lists of AST nodes.
 */
export declare class AstSorter {
    static sort<T extends AstNode>(items: T[]): T[];
    private static sortPrimitiveTypeDecls;
    static sortAttributes<T extends AstConstantAttribute | AstContractAttribute | AstFunctionAttribute>(attributes: T[]): T[];
}

            };
/// <amd-module name="tact-compiler/bindings/typescript/serializers.d.ts" /> 
 declare module "tact-compiler/bindings/typescript/serializers.d.ts" {
                import { ABITypeRef } from "@ijstech/ton-core";
import { Writer } from "../../utils/Writer";
type Serializer<T> = {
    tsType: (v: T) => string;
    tsLoad: (v: T, slice: string, field: string, w: Writer) => void;
    tsLoadTuple: (v: T, reader: string, field: string, w: Writer, fromGet: boolean) => void;
    tsStore: (v: T, builder: string, field: string, w: Writer) => void;
    tsStoreTuple: (v: T, to: string, field: string, w: Writer) => void;
    abiMatcher: (src: ABITypeRef) => T | null;
};
export declare const serializers: Serializer<any>[];
export {};

            };
/// <amd-module name="tact-compiler/bindings/typescript/writeStruct.d.ts" /> 
 declare module "tact-compiler/bindings/typescript/writeStruct.d.ts" {
                import { ABIType, ABITypeRef } from "@ijstech/ton-core";
import { AllocationCell } from "../../storage/operation";
import { Writer } from "../../utils/Writer";
export declare const maxTupleSize = 15;
export declare function writeStruct(name: string, fields: {
    name: string;
    type: ABITypeRef;
}[], exp: boolean, w: Writer): void;
export declare function writeParser(s: ABIType, allocation: AllocationCell, w: Writer): void;
export declare function writeSerializer(s: ABIType, allocation: AllocationCell, w: Writer): void;
export declare function writeInitSerializer(name: string, allocation: AllocationCell, w: Writer): void;
export declare function writeTupleParser(s: ABIType, w: Writer): void;
export declare function writeGetterTupleParser(s: ABIType, w: Writer): void;
export declare function writeGetParser(name: string, type: ABITypeRef, w: Writer): void;
export declare function writeTupleSerializer(s: ABIType, w: Writer): void;
export declare function writeArgumentToStack(name: string, ref: ABITypeRef, w: Writer): void;
export declare function writeDictParser(s: ABIType, w: Writer): void;

            };
/// <amd-module name="tact-compiler/bindings/writeTypescript.d.ts" /> 
 declare module "tact-compiler/bindings/writeTypescript.d.ts" {
                import { ABIArgument, ContractABI } from "@ijstech/ton-core";
export declare function writeTypescript(abi: ContractABI, init?: {
    code: string;
    system: string | null;
    args: ABIArgument[];
    prefix?: {
        value: number;
        bits: number;
    } | undefined;
}): string;

            };
/// <amd-module name="tact-compiler/browser.d.ts" /> 
 declare module "tact-compiler/browser.d.ts" {
                import { Config } from "./config/parseConfig";
import { ILogger } from "./context/logger";
export declare function run(args: {
    config: Config;
    files: Record<string, string>;
    logger?: ILogger;
}): Promise<{
    ok: boolean;
    error: Error[];
}>;

            };
/// <amd-module name="tact-compiler/config/features.d.ts" /> 
 declare module "tact-compiler/config/features.d.ts" {
                import { CompilerContext } from "../context/context";
export declare function enabledInline(ctx: CompilerContext): boolean;
export declare function enabledDebug(ctx: CompilerContext): boolean;
export declare function enabledExternals(ctx: CompilerContext): boolean;
export declare function enabledIpfsAbiGetter(ctx: CompilerContext): boolean;
export declare function enabledInterfacesGetter(ctx: CompilerContext): boolean;
export declare function featureEnable(ctx: CompilerContext, key: string): CompilerContext;

            };
/// <amd-module name="tact-compiler/config/parseConfig.d.ts" /> 
 declare module "tact-compiler/config/parseConfig.d.ts" {
                import { z } from "zod";
export declare const optionsSchema: z.ZodObject<{
    /**
     * If set to true, enables debug output of a contract and allows usage of `dump()` function,
     * which is useful for debugging purposes.
     *
     * Read more: https://docs.tact-lang.org/book/debug
     */
    debug: z.ZodOptional<z.ZodBoolean>;
    /**
     * If set to true, enables support of external message receivers.
     *
     * Read more: https://docs.tact-lang.org/book/external
     */
    external: z.ZodOptional<z.ZodBoolean>;
    /**
     * If set to true, enables generation of a getter with IPFS links describing the contract's ABI.
     *
     * Read more: https://docs.tact-lang.org/ref/evolution/OTP-003
     */
    ipfsAbiGetter: z.ZodOptional<z.ZodBoolean>;
    /**
     * If set to true, enables generation of a getter with a list of interfaces provided by the contract.
     *
     * Read more: https://docs.tact-lang.org/book/contracts#interfaces
     */
    interfacesGetter: z.ZodOptional<z.ZodBoolean>;
    /**
     * If set to "new", uses new parser. If set to "old", uses legacy parser. Default is "old".
     */
    parser: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"new">, z.ZodLiteral<"old">]>>;
    /**
     * Experimental options that might be removed in the future. Use with caution!
     */
    experimental: z.ZodOptional<z.ZodObject<{
        /**
         * If set to true, enables inlining of all functions in contracts.
         * This can reduce gas usage at the cost of bigger contracts.
         */
        inline: z.ZodOptional<z.ZodBoolean>;
    }, "strict", z.ZodTypeAny, {
        inline?: boolean | undefined;
    }, {
        inline?: boolean | undefined;
    }>>;
}, "strict", z.ZodTypeAny, {
    debug?: boolean | undefined;
    external?: boolean | undefined;
    ipfsAbiGetter?: boolean | undefined;
    interfacesGetter?: boolean | undefined;
    parser?: "new" | "old" | undefined;
    experimental?: {
        inline?: boolean | undefined;
    } | undefined;
}, {
    debug?: boolean | undefined;
    external?: boolean | undefined;
    ipfsAbiGetter?: boolean | undefined;
    interfacesGetter?: boolean | undefined;
    parser?: "new" | "old" | undefined;
    experimental?: {
        inline?: boolean | undefined;
    } | undefined;
}>;
export declare const projectSchema: z.ZodObject<{
    /**
     * Name of the project. All generated files are prefixed with it.
     *
     * Read more: https://docs.tact-lang.org/book/config#projects-name
     */
    name: z.ZodString;
    /**
     * Path to the project's Tact file. You can only specify one Tact file per project.
     *
     * Read more: https://docs.tact-lang.org/book/config#projects-path
     */
    path: z.ZodString;
    /**
     * Path to the directory where all generated files will be placed.
     *
     * Read more: https://docs.tact-lang.org/book/config#projects-output
     */
    output: z.ZodString;
    /**
     * Compilation options for the project.
     *
     * Read more: https://docs.tact-lang.org/book/config#projects-options
     */
    options: z.ZodOptional<z.ZodObject<{
        /**
         * If set to true, enables debug output of a contract and allows usage of `dump()` function,
         * which is useful for debugging purposes.
         *
         * Read more: https://docs.tact-lang.org/book/debug
         */
        debug: z.ZodOptional<z.ZodBoolean>;
        /**
         * If set to true, enables support of external message receivers.
         *
         * Read more: https://docs.tact-lang.org/book/external
         */
        external: z.ZodOptional<z.ZodBoolean>;
        /**
         * If set to true, enables generation of a getter with IPFS links describing the contract's ABI.
         *
         * Read more: https://docs.tact-lang.org/ref/evolution/OTP-003
         */
        ipfsAbiGetter: z.ZodOptional<z.ZodBoolean>;
        /**
         * If set to true, enables generation of a getter with a list of interfaces provided by the contract.
         *
         * Read more: https://docs.tact-lang.org/book/contracts#interfaces
         */
        interfacesGetter: z.ZodOptional<z.ZodBoolean>;
        /**
         * If set to "new", uses new parser. If set to "old", uses legacy parser. Default is "old".
         */
        parser: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"new">, z.ZodLiteral<"old">]>>;
        /**
         * Experimental options that might be removed in the future. Use with caution!
         */
        experimental: z.ZodOptional<z.ZodObject<{
            /**
             * If set to true, enables inlining of all functions in contracts.
             * This can reduce gas usage at the cost of bigger contracts.
             */
            inline: z.ZodOptional<z.ZodBoolean>;
        }, "strict", z.ZodTypeAny, {
            inline?: boolean | undefined;
        }, {
            inline?: boolean | undefined;
        }>>;
    }, "strict", z.ZodTypeAny, {
        debug?: boolean | undefined;
        external?: boolean | undefined;
        ipfsAbiGetter?: boolean | undefined;
        interfacesGetter?: boolean | undefined;
        parser?: "new" | "old" | undefined;
        experimental?: {
            inline?: boolean | undefined;
        } | undefined;
    }, {
        debug?: boolean | undefined;
        external?: boolean | undefined;
        ipfsAbiGetter?: boolean | undefined;
        interfacesGetter?: boolean | undefined;
        parser?: "new" | "old" | undefined;
        experimental?: {
            inline?: boolean | undefined;
        } | undefined;
    }>>;
    /**
     * Compilation mode of the project.
     *
     * Read more: https://docs.tact-lang.org/book/config#projects-mode
     */
    mode: z.ZodOptional<z.ZodEnum<["fullWithDecompilation", "full", "funcOnly", "checkOnly"]>>;
}, "strict", z.ZodTypeAny, {
    path: string;
    name: string;
    output: string;
    options?: {
        debug?: boolean | undefined;
        external?: boolean | undefined;
        ipfsAbiGetter?: boolean | undefined;
        interfacesGetter?: boolean | undefined;
        parser?: "new" | "old" | undefined;
        experimental?: {
            inline?: boolean | undefined;
        } | undefined;
    } | undefined;
    mode?: "fullWithDecompilation" | "full" | "funcOnly" | "checkOnly" | undefined;
}, {
    path: string;
    name: string;
    output: string;
    options?: {
        debug?: boolean | undefined;
        external?: boolean | undefined;
        ipfsAbiGetter?: boolean | undefined;
        interfacesGetter?: boolean | undefined;
        parser?: "new" | "old" | undefined;
        experimental?: {
            inline?: boolean | undefined;
        } | undefined;
    } | undefined;
    mode?: "fullWithDecompilation" | "full" | "funcOnly" | "checkOnly" | undefined;
}>;
export declare const configSchema: z.ZodObject<{
    /**
     * A property for specifying a path or URL to the JSON schema of tact.config.json
     *
     * Read more: https://docs.tact-lang.org/book/config#schema
     */
    $schema: z.ZodOptional<z.ZodString>;
    /**
     * List of Tact projects with respective compilation options. Each .tact file represents its own Tact project.
     *
     * Read more: https://docs.tact-lang.org/book/config#projects
     */
    projects: z.ZodArray<z.ZodObject<{
        /**
         * Name of the project. All generated files are prefixed with it.
         *
         * Read more: https://docs.tact-lang.org/book/config#projects-name
         */
        name: z.ZodString;
        /**
         * Path to the project's Tact file. You can only specify one Tact file per project.
         *
         * Read more: https://docs.tact-lang.org/book/config#projects-path
         */
        path: z.ZodString;
        /**
         * Path to the directory where all generated files will be placed.
         *
         * Read more: https://docs.tact-lang.org/book/config#projects-output
         */
        output: z.ZodString;
        /**
         * Compilation options for the project.
         *
         * Read more: https://docs.tact-lang.org/book/config#projects-options
         */
        options: z.ZodOptional<z.ZodObject<{
            /**
             * If set to true, enables debug output of a contract and allows usage of `dump()` function,
             * which is useful for debugging purposes.
             *
             * Read more: https://docs.tact-lang.org/book/debug
             */
            debug: z.ZodOptional<z.ZodBoolean>;
            /**
             * If set to true, enables support of external message receivers.
             *
             * Read more: https://docs.tact-lang.org/book/external
             */
            external: z.ZodOptional<z.ZodBoolean>;
            /**
             * If set to true, enables generation of a getter with IPFS links describing the contract's ABI.
             *
             * Read more: https://docs.tact-lang.org/ref/evolution/OTP-003
             */
            ipfsAbiGetter: z.ZodOptional<z.ZodBoolean>;
            /**
             * If set to true, enables generation of a getter with a list of interfaces provided by the contract.
             *
             * Read more: https://docs.tact-lang.org/book/contracts#interfaces
             */
            interfacesGetter: z.ZodOptional<z.ZodBoolean>;
            /**
             * If set to "new", uses new parser. If set to "old", uses legacy parser. Default is "old".
             */
            parser: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"new">, z.ZodLiteral<"old">]>>;
            /**
             * Experimental options that might be removed in the future. Use with caution!
             */
            experimental: z.ZodOptional<z.ZodObject<{
                /**
                 * If set to true, enables inlining of all functions in contracts.
                 * This can reduce gas usage at the cost of bigger contracts.
                 */
                inline: z.ZodOptional<z.ZodBoolean>;
            }, "strict", z.ZodTypeAny, {
                inline?: boolean | undefined;
            }, {
                inline?: boolean | undefined;
            }>>;
        }, "strict", z.ZodTypeAny, {
            debug?: boolean | undefined;
            external?: boolean | undefined;
            ipfsAbiGetter?: boolean | undefined;
            interfacesGetter?: boolean | undefined;
            parser?: "new" | "old" | undefined;
            experimental?: {
                inline?: boolean | undefined;
            } | undefined;
        }, {
            debug?: boolean | undefined;
            external?: boolean | undefined;
            ipfsAbiGetter?: boolean | undefined;
            interfacesGetter?: boolean | undefined;
            parser?: "new" | "old" | undefined;
            experimental?: {
                inline?: boolean | undefined;
            } | undefined;
        }>>;
        /**
         * Compilation mode of the project.
         *
         * Read more: https://docs.tact-lang.org/book/config#projects-mode
         */
        mode: z.ZodOptional<z.ZodEnum<["fullWithDecompilation", "full", "funcOnly", "checkOnly"]>>;
    }, "strict", z.ZodTypeAny, {
        path: string;
        name: string;
        output: string;
        options?: {
            debug?: boolean | undefined;
            external?: boolean | undefined;
            ipfsAbiGetter?: boolean | undefined;
            interfacesGetter?: boolean | undefined;
            parser?: "new" | "old" | undefined;
            experimental?: {
                inline?: boolean | undefined;
            } | undefined;
        } | undefined;
        mode?: "fullWithDecompilation" | "full" | "funcOnly" | "checkOnly" | undefined;
    }, {
        path: string;
        name: string;
        output: string;
        options?: {
            debug?: boolean | undefined;
            external?: boolean | undefined;
            ipfsAbiGetter?: boolean | undefined;
            interfacesGetter?: boolean | undefined;
            parser?: "new" | "old" | undefined;
            experimental?: {
                inline?: boolean | undefined;
            } | undefined;
        } | undefined;
        mode?: "fullWithDecompilation" | "full" | "funcOnly" | "checkOnly" | undefined;
    }>, "many">;
}, "strict", z.ZodTypeAny, {
    projects: {
        path: string;
        name: string;
        output: string;
        options?: {
            debug?: boolean | undefined;
            external?: boolean | undefined;
            ipfsAbiGetter?: boolean | undefined;
            interfacesGetter?: boolean | undefined;
            parser?: "new" | "old" | undefined;
            experimental?: {
                inline?: boolean | undefined;
            } | undefined;
        } | undefined;
        mode?: "fullWithDecompilation" | "full" | "funcOnly" | "checkOnly" | undefined;
    }[];
    $schema?: string | undefined;
}, {
    projects: {
        path: string;
        name: string;
        output: string;
        options?: {
            debug?: boolean | undefined;
            external?: boolean | undefined;
            ipfsAbiGetter?: boolean | undefined;
            interfacesGetter?: boolean | undefined;
            parser?: "new" | "old" | undefined;
            experimental?: {
                inline?: boolean | undefined;
            } | undefined;
        } | undefined;
        mode?: "fullWithDecompilation" | "full" | "funcOnly" | "checkOnly" | undefined;
    }[];
    $schema?: string | undefined;
}>;
/**
 * Compiler configuration schema
 *
 * Read more: https://docs.tact-lang.org/book/config
 */
export type Config = z.infer<typeof configSchema>;
/**
 * Per-project configuration options
 *
 * Read more: https://docs.tact-lang.org/book/config#projects
 */
export type ConfigProject = z.infer<typeof projectSchema>;
/**
 * Per-project configuration options
 *
 * Read more: https://docs.tact-lang.org/book/config#projects
 */
export type Options = z.infer<typeof optionsSchema>;
/**
 * Takes a stringified JSON [src] of a schema, converts to JSON and returns a parsed schema if it's valid
 *
 * @throws If the provided JSON string isn't a valid JSON
 * @throws If the provided JSON string isn't valid according to the config schema
 */
export declare function parseConfig(src: string): {
    projects: {
        path: string;
        name: string;
        output: string;
        options?: {
            debug?: boolean | undefined;
            external?: boolean | undefined;
            ipfsAbiGetter?: boolean | undefined;
            interfacesGetter?: boolean | undefined;
            parser?: "new" | "old" | undefined;
            experimental?: {
                inline?: boolean | undefined;
            } | undefined;
        } | undefined;
        mode?: "fullWithDecompilation" | "full" | "funcOnly" | "checkOnly" | undefined;
    }[];
    $schema?: string | undefined;
};
/**
 * Takes a config schema object and verifies that it's valid
 *
 * @throws If the provided object isn't valid according to the config schema
 */
export declare function verifyConfig(config: Config): {
    projects: {
        path: string;
        name: string;
        output: string;
        options?: {
            debug?: boolean | undefined;
            external?: boolean | undefined;
            ipfsAbiGetter?: boolean | undefined;
            interfacesGetter?: boolean | undefined;
            parser?: "new" | "old" | undefined;
            experimental?: {
                inline?: boolean | undefined;
            } | undefined;
        } | undefined;
        mode?: "fullWithDecompilation" | "full" | "funcOnly" | "checkOnly" | undefined;
    }[];
    $schema?: string | undefined;
};

            };
/// <amd-module name="tact-compiler/context/context.d.ts" /> 
 declare module "tact-compiler/context/context.d.ts" {
                type Key = string | number;
export type Store<T> = Map<Key, T>;
type Stores = Map<symbol, Store<any> | undefined>;
export declare class CompilerContext {
    readonly stores: Stores;
    constructor(args?: {
        stores: Stores;
    });
    updateStore: <T>(storeDispatch: symbol, key: Key, value: T) => CompilerContext;
}
export declare function createContextStore<T>(): {
    get(ctx: CompilerContext, key: Key): T | null;
    all(ctx: CompilerContext): Store<T>;
    set(ctx: CompilerContext, key: Key, v: T): CompilerContext;
};
export {};

            };
/// <amd-module name="tact-compiler/context/logger.d.ts" /> 
 declare module "tact-compiler/context/logger.d.ts" {
                export declare enum LogLevel {
    /** Logging is turned off */
    NONE = 0,
    /** Logs only error messages */
    ERROR = 1,
    /** Logs warning and error messages */
    WARN = 2,
    /** Logs informational, warning, and error messages */
    INFO = 3,
    /** Logs debugging, informational, warning, and error messages */
    DEBUG = 4
}
type messageType = string | Error;
/**
 * Interface defining the logging methods used by the `Logger` class, enabling
 * custom logger implementations.
 */
export interface ILogger {
    debug: (message: messageType) => void;
    info: (message: messageType) => void;
    warn: (message: messageType) => void;
    error: (message: messageType) => void;
}
export declare class Logger {
    private level;
    private logMethods;
    constructor(level?: LogLevel);
    protected log(level: LogLevel, message: messageType): void;
    debug(message: messageType): void;
    info(message: messageType): void;
    warn(message: messageType): void;
    error(message: messageType): void;
    setLevel(level: LogLevel): void;
}
export {};

            };
/// <amd-module name="tact-compiler/context/store.d.ts" /> 
 declare module "tact-compiler/context/store.d.ts" {
                import { AstModule, AstConstantDef, AstFunctionDef, AstNativeFunctionDecl, AstTypeDecl, AstAsmFunctionDef } from "../ast/ast";
import { CompilerContext } from "./context";
import { ItemOrigin } from "../grammar/src-info";
import { Parser } from "../grammar/grammar";
/**
 * @public
 */
export type TactSource = {
    code: string;
    path: string;
    origin: ItemOrigin;
};
/**
 * Represents the storage for all AST-related data within the compiler context.
 * @public
 * @property functions AST entries representing top-level functions.
 * @property constants AST entries representing top-level constant definitions.
 * @property types AST entries representing structures, contracts, and traits.
 */
export type AstStore = {
    sources: TactSource[];
    funcSources: {
        code: string;
        path: string;
    }[];
    functions: (AstFunctionDef | AstNativeFunctionDecl | AstAsmFunctionDef)[];
    constants: AstConstantDef[];
    types: AstTypeDecl[];
};
/**
 * Retrieves the raw AST for the given context.
 * @public
 * @param ctx The compiler context from which the AST is retrieved.
 * @throws Will throw an error if the AST is not found in the context.
 * @returns The AST types associated with the context.
 */
export declare function getRawAST(ctx: CompilerContext): AstStore;
/**
 * Parses multiple Tact source files into AST modules.
 * @public
 */
export declare function parseModules(sources: TactSource[], parser: Parser): AstModule[];
/**
 * Extends the compiler context by adding AST entries and source information from
 * given sources and parsed programs.
 * @public
 * @param parsedModules An optional array of previously parsed programs. If not defined, they will be parsed from `sources`.
 * @returns The updated compiler context.
 */
export declare function openContext(ctx: CompilerContext, sources: TactSource[], funcSources: {
    code: string;
    path: string;
}[], parser: Parser, parsedModules?: AstModule[]): CompilerContext;

            };
/// <amd-module name="tact-compiler/error/display-to-json.d.ts" /> 
 declare module "tact-compiler/error/display-to-json.d.ts" {
                /**
 * Render error message to JSON for tests
 */
import { SrcInfo } from "../grammar";
import { ErrorDisplay } from "./display";
export type ErrorJson = ErrorSub | ErrorText | ErrorLink | ErrorAt;
export type ErrorText = {
    kind: "text";
    text: string;
};
export type ErrorSub = {
    kind: "sub";
    parts: string[];
    subst: ErrorJson[];
};
export type ErrorLink = {
    kind: "link";
    text: string;
    loc: SrcInfo;
};
export type ErrorAt = {
    kind: "at";
    body: ErrorJson;
    loc: SrcInfo;
};
export declare const errorJsonEqual: (left: ErrorJson, right: ErrorJson) => boolean;
export declare const displayToJson: ErrorDisplay<ErrorJson>;

            };
/// <amd-module name="tact-compiler/error/display-to-string.d.ts" /> 
 declare module "tact-compiler/error/display-to-string.d.ts" {
                /**
 * Render error message to string for compiler CLI
 */
import { ErrorDisplay } from "./display";
export declare const displayToString: ErrorDisplay<string>;

            };
/// <amd-module name="tact-compiler/error/display.d.ts" /> 
 declare module "tact-compiler/error/display.d.ts" {
                /**
 * Describes DSL for displaying errors
 */
import { SrcInfo } from "../grammar";
export interface ErrorDisplay<T> {
    at: (loc: SrcInfo, body: T) => T;
    text: (text: string) => T;
    sub: (text: TemplateStringsArray, ...subst: T[]) => T;
    link: (text: string, loc: SrcInfo) => T;
}

            };
/// <amd-module name="tact-compiler/error/errors.d.ts" /> 
 declare module "tact-compiler/error/errors.d.ts" {
                import { AstFuncId, AstId, AstTypeId } from "../ast/ast";
import { SrcInfo } from "../grammar";
export declare class TactError extends Error {
    readonly loc?: SrcInfo;
    constructor(message: string, loc?: SrcInfo);
}
export declare class TactCompilationError extends TactError {
    constructor(message: string, loc?: SrcInfo);
}
export declare class TactInternalCompilerError extends TactError {
    constructor(message: string, loc?: SrcInfo);
}
export declare class TactConstEvalError extends TactCompilationError {
    fatal: boolean;
    constructor(message: string, fatal: boolean, loc: SrcInfo);
}
export declare function locationStr(sourceInfo: SrcInfo): string;
export declare function throwCompilationError(message: string, source?: SrcInfo): never;
export declare function throwInternalCompilerError(message: string, source?: SrcInfo): never;
export declare function throwConstEvalError(message: string, fatal: boolean, source: SrcInfo): never;
export declare function idTextErr(ident: AstId | AstFuncId | AstTypeId | string): string;
export type TactErrorCollection = Error | TactCompilationError | TactInternalCompilerError | TactConstEvalError;

            };
/// <amd-module name="tact-compiler/func/funcCompile.d.ts" /> 
 declare module "tact-compiler/func/funcCompile.d.ts" {
                import { ILogger } from "../context/logger";
export type FuncCompilationResult = {
    ok: false;
    log: string;
    fift: string | null;
    output: Buffer | null;
} | {
    ok: true;
    log: string;
    fift: string;
    output: Buffer;
};
export declare function funcCompile(args: {
    entries: string[];
    sources: {
        path: string;
        content: string;
    }[];
    logger: ILogger;
}): Promise<FuncCompilationResult>;

            };
/// <amd-module name="tact-compiler/generator/createABI.d.ts" /> 
 declare module "tact-compiler/generator/createABI.d.ts" {
                import { ContractABI } from "@ijstech/ton-core";
import { CompilerContext } from "../context/context";
export declare function createABI(ctx: CompilerContext, name: string): ContractABI;

            };
/// <amd-module name="tact-compiler/generator/emitter/createPadded.d.ts" /> 
 declare module "tact-compiler/generator/emitter/createPadded.d.ts" {
                export declare function createPadded(src: string): string;

            };
/// <amd-module name="tact-compiler/generator/emitter/emit.d.ts" /> 
 declare module "tact-compiler/generator/emitter/emit.d.ts" {
                import { Maybe } from "@ijstech/ton-core";
import { WrittenFunction } from "../Writer";
export declare function emit(args: {
    header?: Maybe<string>;
    functions?: Maybe<WrittenFunction[]>;
}): string;

            };
/// <amd-module name="tact-compiler/generator/writeProgram.d.ts" /> 
 declare module "tact-compiler/generator/writeProgram.d.ts" {
                import { CompilerContext } from "../context/context";
import { ContractABI } from "@ijstech/ton-core";
export declare function writeProgram(ctx: CompilerContext, abiSrc: ContractABI, basename: string, debug?: boolean): Promise<{
    entrypoint: string;
    files: {
        name: string;
        code: string;
    }[];
    abi: string;
}>;

            };
/// <amd-module name="tact-compiler/generator/Writer.d.ts" /> 
 declare module "tact-compiler/generator/Writer.d.ts" {
                import { CompilerContext } from "../context/context";
type Flag = "inline" | "impure" | "inline_ref";
type Body = {
    kind: "generic";
    code: string;
} | {
    kind: "asm";
    shuffle: string;
    code: string;
} | {
    kind: "skip";
};
export type WrittenFunction = {
    name: string;
    code: Body;
    signature: string;
    flags: Set<Flag>;
    depends: Set<string>;
    comment: string | null;
    context: string | null;
};
export declare class WriterContext {
    #private;
    readonly ctx: CompilerContext;
    constructor(ctx: CompilerContext, name: string);
    get name(): string;
    clone(): WriterContext;
    extract(debug?: boolean): WrittenFunction[];
    skip(name: string): void;
    fun(name: string, handler: () => void): void;
    asm(shuffle: string, code: string): void;
    body(handler: () => void): void;
    main(handler: () => void): void;
    signature(sig: string): void;
    flag(flag: Flag): void;
    used(name: string): string;
    comment(src: string): void;
    context(src: string): void;
    currentContext(): string | null;
    inIndent: (handler: () => void) => void;
    append(src?: string): void;
    write(src?: string): void;
    isRendered(key: string): boolean;
    markRendered(key: string): void;
}
export {};

            };
/// <amd-module name="tact-compiler/generator/writeReport.d.ts" /> 
 declare module "tact-compiler/generator/writeReport.d.ts" {
                import { CompilerContext } from "../context/context";
import { PackageFileFormat } from "../packaging/fileFormat";
export declare function writeReport(ctx: CompilerContext, pkg: PackageFileFormat): string;

            };
/// <amd-module name="tact-compiler/generator/writers/cast.d.ts" /> 
 declare module "tact-compiler/generator/writers/cast.d.ts" {
                import { TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function cast(from: TypeRef, to: TypeRef, expression: string, ctx: WriterContext): string;

            };
/// <amd-module name="tact-compiler/generator/writers/freshIdentifier.d.ts" /> 
 declare module "tact-compiler/generator/writers/freshIdentifier.d.ts" {
                export declare function freshIdentifier(prefix: string): string;

            };
/// <amd-module name="tact-compiler/generator/writers/id.d.ts" /> 
 declare module "tact-compiler/generator/writers/id.d.ts" {
                import { AstId } from "../../ast/ast";
export declare function funcIdOf(ident: AstId | string): string;
export declare function funcInitIdOf(ident: AstId | string): string;

            };
/// <amd-module name="tact-compiler/generator/writers/ops.d.ts" /> 
 declare module "tact-compiler/generator/writers/ops.d.ts" {
                import { WriterContext } from "../Writer";
export declare const ops: {
    writer: (type: string, ctx: WriterContext) => string;
    writerCell: (type: string, ctx: WriterContext) => string;
    writerCellOpt: (type: string, ctx: WriterContext) => string;
    reader: (type: string, ctx: WriterContext) => string;
    readerNonModifying: (type: string, ctx: WriterContext) => string;
    readerBounced: (type: string, ctx: WriterContext) => string;
    readerOpt: (type: string, ctx: WriterContext) => string;
    typeField: (type: string, name: string, ctx: WriterContext) => string;
    typeTensorCast: (type: string, ctx: WriterContext) => string;
    typeNotNull: (type: string, ctx: WriterContext) => string;
    typeAsOptional: (type: string, ctx: WriterContext) => string;
    typeToTuple: (type: string, ctx: WriterContext) => string;
    typeToOptTuple: (type: string, ctx: WriterContext) => string;
    typeFromTuple: (type: string, ctx: WriterContext) => string;
    typeFromOptTuple: (type: string, ctx: WriterContext) => string;
    typeToExternal: (type: string, ctx: WriterContext) => string;
    typeToOptExternal: (type: string, ctx: WriterContext) => string;
    typeConstructor: (type: string, fields: string[], ctx: WriterContext) => string;
    contractInit: (type: string, ctx: WriterContext) => string;
    contractInitChild: (type: string, ctx: WriterContext) => string;
    contractLoad: (type: string, ctx: WriterContext) => string;
    contractStore: (type: string, ctx: WriterContext) => string;
    contractRouter: (type: string, kind: "internal" | "external") => string;
    receiveEmpty: (type: string, kind: "internal" | "external") => string;
    receiveType: (type: string, kind: "internal" | "external", msg: string) => string;
    receiveAnyText: (type: string, kind: "internal" | "external") => string;
    receiveText: (type: string, kind: "internal" | "external", hash: string) => string;
    receiveAny: (type: string, kind: "internal" | "external") => string;
    receiveTypeBounce: (type: string, msg: string) => string;
    receiveBounceAny: (type: string) => string;
    extension: (type: string, name: string) => string;
    global: (name: string) => string;
    nonModifying: (name: string) => string;
    str: (id: string, ctx: WriterContext) => string;
};

            };
/// <amd-module name="tact-compiler/generator/writers/resolveFuncFlatPack.d.ts" /> 
 declare module "tact-compiler/generator/writers/resolveFuncFlatPack.d.ts" {
                import { TypeDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function resolveFuncFlatPack(descriptor: TypeRef | TypeDescription | string, name: string, ctx: WriterContext, optional?: boolean): string[];

            };
/// <amd-module name="tact-compiler/generator/writers/resolveFuncFlatTypes.d.ts" /> 
 declare module "tact-compiler/generator/writers/resolveFuncFlatTypes.d.ts" {
                import { TypeDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function resolveFuncFlatTypes(descriptor: TypeRef | TypeDescription | string, ctx: WriterContext, optional?: boolean): string[];

            };
/// <amd-module name="tact-compiler/generator/writers/resolveFuncPrimitive.d.ts" /> 
 declare module "tact-compiler/generator/writers/resolveFuncPrimitive.d.ts" {
                import { TypeDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function resolveFuncPrimitive(descriptor: TypeRef | TypeDescription | string, ctx: WriterContext): boolean;

            };
/// <amd-module name="tact-compiler/generator/writers/resolveFuncTupleType.d.ts" /> 
 declare module "tact-compiler/generator/writers/resolveFuncTupleType.d.ts" {
                import { TypeDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function resolveFuncTupleType(descriptor: TypeRef | TypeDescription | string, ctx: WriterContext): string;

            };
/// <amd-module name="tact-compiler/generator/writers/resolveFuncType.d.ts" /> 
 declare module "tact-compiler/generator/writers/resolveFuncType.d.ts" {
                import { TypeDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function resolveFuncType(descriptor: TypeRef | TypeDescription | string, ctx: WriterContext, optional?: boolean, usePartialFields?: boolean): string;

            };
/// <amd-module name="tact-compiler/generator/writers/resolveFuncTypeFromAbi.d.ts" /> 
 declare module "tact-compiler/generator/writers/resolveFuncTypeFromAbi.d.ts" {
                import { ABITypeRef } from "@ijstech/ton-core";
import { WriterContext } from "../Writer";
export declare function resolveFuncTypeFromAbi(fields: ABITypeRef[], ctx: WriterContext): string;

            };
/// <amd-module name="tact-compiler/generator/writers/resolveFuncTypeFromAbiUnpack.d.ts" /> 
 declare module "tact-compiler/generator/writers/resolveFuncTypeFromAbiUnpack.d.ts" {
                import { ABITypeRef } from "@ijstech/ton-core";
import { WriterContext } from "../Writer";
export declare function resolveFuncTypeFromAbiUnpack(name: string, fields: {
    name: string;
    type: ABITypeRef;
}[], ctx: WriterContext): string;

            };
/// <amd-module name="tact-compiler/generator/writers/resolveFuncTypeUnpack.d.ts" /> 
 declare module "tact-compiler/generator/writers/resolveFuncTypeUnpack.d.ts" {
                import { TypeDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function resolveFuncTypeUnpack(descriptor: TypeRef | TypeDescription | string, name: string, ctx: WriterContext, optional?: boolean, usePartialFields?: boolean): string;

            };
/// <amd-module name="tact-compiler/generator/writers/writeAccessors.d.ts" /> 
 declare module "tact-compiler/generator/writers/writeAccessors.d.ts" {
                import { ItemOrigin } from "../../grammar";
import { TypeDescription } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function writeAccessors(type: TypeDescription, origin: ItemOrigin, ctx: WriterContext): void;

            };
/// <amd-module name="tact-compiler/generator/writers/writeConstant.d.ts" /> 
 declare module "tact-compiler/generator/writers/writeConstant.d.ts" {
                import { Address, Cell, Slice } from "@ijstech/ton-core";
import { WriterContext } from "../Writer";
export declare function writeString(str: string, ctx: WriterContext): string;
export declare function writeComment(str: string, ctx: WriterContext): string;
export declare function writeAddress(address: Address, ctx: WriterContext): string;
export declare function writeCell(cell: Cell, ctx: WriterContext): string;
export declare function writeSlice(slice: Slice, ctx: WriterContext): string;

            };
/// <amd-module name="tact-compiler/generator/writers/writeContract.d.ts" /> 
 declare module "tact-compiler/generator/writers/writeContract.d.ts" {
                import { ItemOrigin } from "../../grammar";
import { InitDescription, TypeDescription } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function writeStorageOps(type: TypeDescription, origin: ItemOrigin, ctx: WriterContext): void;
export declare function writeInit(t: TypeDescription, init: InitDescription, ctx: WriterContext): void;
export declare function writeMainContract(type: TypeDescription, abiLink: string, ctx: WriterContext): void;

            };
/// <amd-module name="tact-compiler/generator/writers/writeExpression.d.ts" /> 
 declare module "tact-compiler/generator/writers/writeExpression.d.ts" {
                import { AstExpression, AstId, AstLiteral } from "../../ast/ast";
import { WriterContext } from "../Writer";
export declare function writeValue(val: AstLiteral, wCtx: WriterContext): string;
export declare function writePathExpression(path: AstId[]): string;
export declare function writeExpression(f: AstExpression, wCtx: WriterContext): string;

            };
/// <amd-module name="tact-compiler/generator/writers/writeFunction.d.ts" /> 
 declare module "tact-compiler/generator/writers/writeFunction.d.ts" {
                import { AstExpression, AstStatement } from "../../ast/ast";
import { FunctionDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function writeCastedExpression(expression: AstExpression, to: TypeRef, ctx: WriterContext): string;
export declare function writeStatement(f: AstStatement, self: string | null, returns: TypeRef | null, ctx: WriterContext): void;
export declare function writeFunction(f: FunctionDescription, ctx: WriterContext): void;
export declare function writeGetter(f: FunctionDescription, wCtx: WriterContext): void;

            };
/// <amd-module name="tact-compiler/generator/writers/writeInterfaces.d.ts" /> 
 declare module "tact-compiler/generator/writers/writeInterfaces.d.ts" {
                import { TypeDescription } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function writeInterfaces(type: TypeDescription, ctx: WriterContext): void;

            };
/// <amd-module name="tact-compiler/generator/writers/writeRouter.d.ts" /> 
 declare module "tact-compiler/generator/writers/writeRouter.d.ts" {
                import { ReceiverDescription, TypeDescription } from "../../types/types";
import { WriterContext } from "../Writer";
export declare function commentPseudoOpcode(comment: string): string;
export declare function writeRouter(type: TypeDescription, kind: "internal" | "external", ctx: WriterContext): void;
export declare function writeReceiver(self: TypeDescription, f: ReceiverDescription, ctx: WriterContext): void;

            };
/// <amd-module name="tact-compiler/generator/writers/writeSerialization.d.ts" /> 
 declare module "tact-compiler/generator/writers/writeSerialization.d.ts" {
                import { ItemOrigin } from "../../grammar";
import { StorageAllocation } from "../../storage/StorageAllocation";
import { WriterContext } from "../Writer";
export declare function writeSerializer(name: string, forceInline: boolean, allocation: StorageAllocation, origin: ItemOrigin, ctx: WriterContext): void;
export declare function writeOptionalSerializer(name: string, origin: ItemOrigin, ctx: WriterContext): void;
export declare function writeParser(name: string, forceInline: boolean, allocation: StorageAllocation, origin: ItemOrigin, ctx: WriterContext): void;
export declare function writeBouncedParser(name: string, forceInline: boolean, allocation: StorageAllocation, origin: ItemOrigin, ctx: WriterContext): void;
export declare function writeOptionalParser(name: string, origin: ItemOrigin, ctx: WriterContext): void;

            };
/// <amd-module name="tact-compiler/generator/writers/writeStdlib.d.ts" /> 
 declare module "tact-compiler/generator/writers/writeStdlib.d.ts" {
                import { WriterContext } from "../Writer";
export declare function writeStdlib(ctx: WriterContext): void;

            };
/// <amd-module name="tact-compiler/grammar/grammar.d.ts" /> 
 declare module "tact-compiler/grammar/grammar.d.ts" {
                import { AstExpression, AstImport, AstModule, FactoryAst } from "../ast/ast";
import { ItemOrigin } from "./src-info";
export type Parser = {
    parse: (src: string, path: string, origin: ItemOrigin) => AstModule;
    parseExpression: (sourceCode: string) => AstExpression;
    parseImports: (src: string, path: string, origin: ItemOrigin) => AstImport[];
};
export declare const defaultParser = "new";
export declare const getParser: (ast: FactoryAst, version: "old" | "new") => Parser;

            };
/// <amd-module name="tact-compiler/grammar/next/grammar.d.ts" /> 
 declare module "tact-compiler/grammar/next/grammar.d.ts" {
                import * as $ from "@tonstudio/parser-runtime";
export declare namespace $ast {
    type Module = $.Located<{
        readonly $: "Module";
        readonly imports: readonly Import[];
        readonly items: readonly moduleItem[];
    }>;
    type Import = $.Located<{
        readonly $: "Import";
        readonly path: StringLiteral;
    }>;
    type PrimitiveTypeDecl = $.Located<{
        readonly $: "PrimitiveTypeDecl";
        readonly name: TypeId;
    }>;
    type $Function = $.Located<{
        readonly $: "Function";
        readonly attributes: readonly FunctionAttribute[];
        readonly name: Id;
        readonly parameters: parameterList<Parameter>;
        readonly returnType: ascription | undefined;
        readonly body: FunctionDefinition | FunctionDeclaration;
    }>;
    type AsmFunction = $.Located<{
        readonly $: "AsmFunction";
        readonly shuffle: shuffle | undefined;
        readonly attributes: readonly FunctionAttribute[];
        readonly name: Id;
        readonly parameters: parameterList<Parameter>;
        readonly returnType: ascription | undefined;
        readonly instructions: assembly;
    }>;
    type NativeFunctionDecl = $.Located<{
        readonly $: "NativeFunctionDecl";
        readonly nativeName: FuncId;
        readonly attributes: readonly FunctionAttribute[];
        readonly name: Id;
        readonly parameters: parameterList<Parameter>;
        readonly returnType: ascription | undefined;
    }>;
    type Constant = $.Located<{
        readonly $: "Constant";
        readonly attributes: readonly ConstantAttribute[];
        readonly name: Id;
        readonly type: ascription;
        readonly body: ConstantDefinition | ConstantDeclaration;
    }>;
    type StructDecl = $.Located<{
        readonly $: "StructDecl";
        readonly name: TypeId;
        readonly fields: structFields;
    }>;
    type MessageDecl = $.Located<{
        readonly $: "MessageDecl";
        readonly opcode: expression | undefined;
        readonly name: TypeId;
        readonly fields: structFields;
    }>;
    type Contract = $.Located<{
        readonly $: "Contract";
        readonly attributes: readonly ContractAttribute[];
        readonly name: Id;
        readonly traits: inheritedTraits | undefined;
        readonly declarations: readonly contractItemDecl[];
    }>;
    type Trait = $.Located<{
        readonly $: "Trait";
        readonly attributes: readonly ContractAttribute[];
        readonly name: Id;
        readonly traits: inheritedTraits | undefined;
        readonly declarations: readonly traitItemDecl[];
    }>;
    type moduleItem = PrimitiveTypeDecl | $Function | AsmFunction | NativeFunctionDecl | Constant | StructDecl | MessageDecl | Contract | Trait;
    type ContractInit = $.Located<{
        readonly $: "ContractInit";
        readonly parameters: parameterList<Parameter>;
        readonly body: statements;
    }>;
    type Receiver = $.Located<{
        readonly $: "Receiver";
        readonly type: receiverType;
        readonly param: receiverParam;
        readonly body: statements;
    }>;
    type FieldDecl = $.Located<{
        readonly $: "FieldDecl";
        readonly name: Id;
        readonly type: ascription;
        readonly as: asType | undefined;
        readonly expression: expression | undefined;
    }>;
    type semicolon = ";" | "}";
    type storageVar = FieldDecl;
    type contractItemDecl = ContractInit | Receiver | $Function | Constant | storageVar;
    type traitItemDecl = Receiver | $Function | Constant | storageVar;
    type FunctionDefinition = $.Located<{
        readonly $: "FunctionDefinition";
        readonly body: statements;
    }>;
    type FunctionDeclaration = $.Located<{
        readonly $: "FunctionDeclaration";
    }>;
    type Id = $.Located<{
        readonly $: "Id";
        readonly name: string;
    }>;
    type IntegerLiteralDec = $.Located<{
        readonly $: "IntegerLiteralDec";
        readonly digits: underscored<digit>;
    }>;
    type shuffle = {
        readonly ids: readonly Id[];
        readonly to: readonly IntegerLiteralDec[] | undefined;
    };
    type ConstantAttribute = $.Located<{
        readonly $: "ConstantAttribute";
        readonly name: keyword<"virtual"> | keyword<"override"> | keyword<"abstract">;
    }>;
    type ConstantDefinition = $.Located<{
        readonly $: "ConstantDefinition";
        readonly expression: expression;
    }>;
    type ConstantDeclaration = $.Located<{
        readonly $: "ConstantDeclaration";
    }>;
    type inter<A, B> = {
        readonly head: A;
        readonly tail: readonly {
            readonly op: B;
            readonly right: A;
        }[];
    };
    type structFields = inter<FieldDecl, ";"> | undefined;
    type keyword<T> = T;
    type commaList<T> = inter<T, ",">;
    type inheritedTraits = commaList<Id>;
    type ContractAttribute = $.Located<{
        readonly $: "ContractAttribute";
        readonly name: StringLiteral;
    }>;
    type FunctionAttribute = $.Located<{
        readonly $: "FunctionAttribute";
        readonly name: GetAttribute | keyword<"mutates"> | keyword<"extends"> | keyword<"virtual"> | keyword<"override"> | keyword<"inline"> | keyword<"abstract">;
    }>;
    type GetAttribute = $.Located<{
        readonly $: "GetAttribute";
        readonly methodId: expression | undefined;
    }>;
    type receiverType = "bounced" | keyword<"receive"> | keyword<"external">;
    type Parameter = $.Located<{
        readonly $: "Parameter";
        readonly name: Id;
        readonly type: ascription;
    }>;
    type StringLiteral = $.Located<{
        readonly $: "StringLiteral";
        readonly value: string;
    }>;
    type receiverParam = Parameter | StringLiteral | undefined;
    type assembly = string;
    type multiLineComment = string;
    type singleLineComment = string;
    type comment = multiLineComment | singleLineComment;
    type assemblyItem = {} | comment | {} | readonly {}[];
    type assemblySequence = readonly assemblyItem[];
    type TypeOptional = $.Located<{
        readonly $: "TypeOptional";
        readonly child: TypeId;
    }>;
    type TypeRegular = $.Located<{
        readonly $: "TypeRegular";
        readonly child: TypeId;
    }>;
    type TypeMap = $.Located<{
        readonly $: "TypeMap";
        readonly key: TypeId;
        readonly keyAs: asType | undefined;
        readonly value: TypeId;
        readonly valueAs: asType | undefined;
    }>;
    type TypeBounced = $.Located<{
        readonly $: "TypeBounced";
        readonly child: TypeId;
    }>;
    type $type = TypeOptional | TypeRegular | TypeMap | TypeBounced;
    type ascription = $type;
    type TypeId = $.Located<{
        readonly $: "TypeId";
        readonly name: string;
    }>;
    type asType = Id;
    type StatementLet = $.Located<{
        readonly $: "StatementLet";
        readonly name: Id;
        readonly type: ascription | undefined;
        readonly init: expression;
    }>;
    type StatementDestruct = $.Located<{
        readonly $: "StatementDestruct";
        readonly type: TypeId;
        readonly fields: inter<destructItem, ",">;
        readonly rest: optionalRest;
        readonly init: expression;
    }>;
    type StatementBlock = $.Located<{
        readonly $: "StatementBlock";
        readonly body: statements;
    }>;
    type StatementReturn = $.Located<{
        readonly $: "StatementReturn";
        readonly expression: expression | undefined;
    }>;
    type StatementCondition = $.Located<{
        readonly $: "StatementCondition";
        readonly condition: expression;
        readonly trueBranch: statements;
        readonly falseBranch: FalseBranch | StatementCondition | undefined;
    }>;
    type StatementWhile = $.Located<{
        readonly $: "StatementWhile";
        readonly condition: parens;
        readonly body: statements;
    }>;
    type StatementRepeat = $.Located<{
        readonly $: "StatementRepeat";
        readonly condition: parens;
        readonly body: statements;
    }>;
    type StatementUntil = $.Located<{
        readonly $: "StatementUntil";
        readonly body: statements;
        readonly condition: parens;
    }>;
    type StatementTry = $.Located<{
        readonly $: "StatementTry";
        readonly body: statements;
        readonly handler: {
            readonly name: Id;
            readonly body: statements;
        } | undefined;
    }>;
    type StatementForEach = $.Located<{
        readonly $: "StatementForEach";
        readonly key: Id;
        readonly value: Id;
        readonly expression: expression;
        readonly body: statements;
    }>;
    type StatementExpression = $.Located<{
        readonly $: "StatementExpression";
        readonly expression: expression;
    }>;
    type StatementAssign = $.Located<{
        readonly $: "StatementAssign";
        readonly left: expression;
        readonly operator: augmentedOp | undefined;
        readonly right: expression;
    }>;
    type statement = StatementLet | StatementDestruct | StatementBlock | StatementReturn | StatementCondition | StatementWhile | StatementRepeat | StatementUntil | StatementTry | StatementForEach | StatementExpression | StatementAssign;
    type statements = readonly statement[];
    type augmentedOp = "||" | "&&" | ">>" | "<<" | "-" | "+" | "*" | "/" | "%" | "|" | "&" | "^";
    type FalseBranch = $.Located<{
        readonly $: "FalseBranch";
        readonly body: statements;
    }>;
    type RegularField = $.Located<{
        readonly $: "RegularField";
        readonly fieldName: Id;
        readonly varName: Id;
    }>;
    type PunnedField = $.Located<{
        readonly $: "PunnedField";
        readonly name: Id;
    }>;
    type destructItem = RegularField | PunnedField;
    type RestArgument = $.Located<{
        readonly $: "RestArgument";
    }>;
    type NoRestArgument = $.Located<{
        readonly $: "NoRestArgument";
    }>;
    type optionalRest = RestArgument | NoRestArgument;
    type Conditional = $.Located<{
        readonly $: "Conditional";
        readonly head: or;
        readonly tail: {
            readonly thenBranch: or;
            readonly elseBranch: Conditional;
        } | undefined;
    }>;
    type expression = Conditional;
    type Binary<T, U> = $.Located<{
        readonly $: "Binary";
        readonly exprs: inter<T, Operator<U>>;
    }>;
    type Unary = $.Located<{
        readonly $: "Unary";
        readonly prefixes: readonly Operator<"-" | "+" | "!" | "~">[];
        readonly expression: Suffix;
    }>;
    type mul = Binary<Unary, "*" | "/" | "%">;
    type add = Binary<mul, "+" | "-">;
    type bitwiseShift = Binary<add, "<<" | ">>">;
    type compare = Binary<bitwiseShift, "<=" | "<" | ">=" | ">">;
    type equality = Binary<compare, "!=" | "==">;
    type bitwiseAnd = Binary<equality, "&">;
    type bitwiseXor = Binary<bitwiseAnd, "^">;
    type bitwiseOr = Binary<bitwiseXor, "|">;
    type and = Binary<bitwiseOr, "&&">;
    type or = Binary<and, "||">;
    type Suffix = $.Located<{
        readonly $: "Suffix";
        readonly expression: primary;
        readonly suffixes: readonly suffix[];
    }>;
    type Operator<U> = $.Located<{
        readonly $: "Operator";
        readonly name: U;
    }>;
    type SuffixUnboxNotNull = $.Located<{
        readonly $: "SuffixUnboxNotNull";
    }>;
    type SuffixCall = $.Located<{
        readonly $: "SuffixCall";
        readonly params: parameterList<expression>;
    }>;
    type SuffixFieldAccess = $.Located<{
        readonly $: "SuffixFieldAccess";
        readonly name: Id;
    }>;
    type suffix = SuffixUnboxNotNull | SuffixCall | SuffixFieldAccess;
    type Parens = $.Located<{
        readonly $: "Parens";
        readonly child: parens;
    }>;
    type StructInstance = $.Located<{
        readonly $: "StructInstance";
        readonly type: TypeId;
        readonly fields: commaList<StructFieldInitializer> | undefined;
    }>;
    type IntegerLiteral = $.Located<{
        readonly $: "IntegerLiteral";
        readonly value: IntegerLiteralHex | IntegerLiteralBin | IntegerLiteralOct | IntegerLiteralDec;
    }>;
    type BoolLiteral = $.Located<{
        readonly $: "BoolLiteral";
        readonly value: "true" | "false";
    }>;
    type InitOf = $.Located<{
        readonly $: "InitOf";
        readonly name: Id;
        readonly params: parameterList<expression>;
    }>;
    type Null = $.Located<{
        readonly $: "Null";
    }>;
    type primary = Parens | StructInstance | IntegerLiteral | BoolLiteral | InitOf | Null | StringLiteral | Id;
    type parens = expression;
    type StructFieldInitializer = $.Located<{
        readonly $: "StructFieldInitializer";
        readonly name: Id;
        readonly init: expression | undefined;
    }>;
    type parameterList<T> = commaList<T> | undefined;
    type IntegerLiteralHex = $.Located<{
        readonly $: "IntegerLiteralHex";
        readonly digits: underscored<hexDigit>;
    }>;
    type IntegerLiteralBin = $.Located<{
        readonly $: "IntegerLiteralBin";
        readonly digits: underscored<"0" | "1">;
    }>;
    type IntegerLiteralOct = $.Located<{
        readonly $: "IntegerLiteralOct";
        readonly digits: underscored<string>;
    }>;
    type underscored<T> = string;
    type digit = string;
    type idPart = string | string | string | "_";
    type FuncId = $.Located<{
        readonly $: "FuncId";
        readonly accessor: "." | "~" | undefined;
        readonly id: string;
    }>;
    type hexDigit = string | string | string;
    type escapeChar = "\\" | "\"" | "n" | "r" | "t" | "v" | "b" | "f" | string | string | string;
    type reservedWord = keyword<"extend" | "public" | "fun" | "let" | "return" | "receive" | "native" | "primitive" | "null" | "if" | "else" | "while" | "repeat" | "do" | "until" | "try" | "catch" | "foreach" | "as" | "map" | "mutates" | "extends" | "external" | "import" | "with" | "trait" | "initOf" | "override" | "abstract" | "virtual" | "inline" | "const">;
    type space = " " | "\t" | "\r" | "\n" | comment;
    type JustImports = $.Located<{
        readonly $: "JustImports";
        readonly imports: readonly Import[];
    }>;
}
export declare const Module: $.Parser<$ast.Module>;
export declare const Import: $.Parser<$ast.Import>;
export declare const PrimitiveTypeDecl: $.Parser<$ast.PrimitiveTypeDecl>;
export declare const $Function: $.Parser<$ast.$Function>;
export declare const AsmFunction: $.Parser<$ast.AsmFunction>;
export declare const NativeFunctionDecl: $.Parser<$ast.NativeFunctionDecl>;
export declare const Constant: $.Parser<$ast.Constant>;
export declare const StructDecl: $.Parser<$ast.StructDecl>;
export declare const MessageDecl: $.Parser<$ast.MessageDecl>;
export declare const Contract: $.Parser<$ast.Contract>;
export declare const Trait: $.Parser<$ast.Trait>;
export declare const moduleItem: $.Parser<$ast.moduleItem>;
export declare const ContractInit: $.Parser<$ast.ContractInit>;
export declare const Receiver: $.Parser<$ast.Receiver>;
export declare const FieldDecl: $.Parser<$ast.FieldDecl>;
export declare const semicolon: $.Parser<$ast.semicolon>;
export declare const storageVar: $.Parser<$ast.storageVar>;
export declare const contractItemDecl: $.Parser<$ast.contractItemDecl>;
export declare const traitItemDecl: $.Parser<$ast.traitItemDecl>;
export declare const FunctionDefinition: $.Parser<$ast.FunctionDefinition>;
export declare const FunctionDeclaration: $.Parser<$ast.FunctionDeclaration>;
export declare const Id: $.Parser<$ast.Id>;
export declare const IntegerLiteralDec: $.Parser<$ast.IntegerLiteralDec>;
export declare const shuffle: $.Parser<$ast.shuffle>;
export declare const ConstantAttribute: $.Parser<$ast.ConstantAttribute>;
export declare const ConstantDefinition: $.Parser<$ast.ConstantDefinition>;
export declare const ConstantDeclaration: $.Parser<$ast.ConstantDeclaration>;
export declare const inter: <A, B>(A: $.Parser<A>, B: $.Parser<B>) => $.Parser<$ast.inter<A, B>>;
export declare const structFields: $.Parser<$ast.structFields>;
export declare const keyword: <T>(T: $.Parser<T>) => $.Parser<$ast.keyword<T>>;
export declare const commaList: <T>(T: $.Parser<T>) => $.Parser<$ast.commaList<T>>;
export declare const inheritedTraits: $.Parser<$ast.inheritedTraits>;
export declare const ContractAttribute: $.Parser<$ast.ContractAttribute>;
export declare const FunctionAttribute: $.Parser<$ast.FunctionAttribute>;
export declare const GetAttribute: $.Parser<$ast.GetAttribute>;
export declare const receiverType: $.Parser<$ast.receiverType>;
export declare const Parameter: $.Parser<$ast.Parameter>;
export declare const StringLiteral: $.Parser<$ast.StringLiteral>;
export declare const receiverParam: $.Parser<$ast.receiverParam>;
export declare const assembly: $.Parser<$ast.assembly>;
export declare const multiLineComment: $.Parser<$ast.multiLineComment>;
export declare const singleLineComment: $.Parser<$ast.singleLineComment>;
export declare const comment: $.Parser<$ast.comment>;
export declare const assemblyItem: $.Parser<$ast.assemblyItem>;
export declare const assemblySequence: $.Parser<$ast.assemblySequence>;
export declare const TypeOptional: $.Parser<$ast.TypeOptional>;
export declare const TypeRegular: $.Parser<$ast.TypeRegular>;
export declare const TypeMap: $.Parser<$ast.TypeMap>;
export declare const TypeBounced: $.Parser<$ast.TypeBounced>;
export declare const $type: $.Parser<$ast.$type>;
export declare const ascription: $.Parser<$ast.ascription>;
export declare const TypeId: $.Parser<$ast.TypeId>;
export declare const asType: $.Parser<$ast.asType>;
export declare const StatementLet: $.Parser<$ast.StatementLet>;
export declare const StatementDestruct: $.Parser<$ast.StatementDestruct>;
export declare const StatementBlock: $.Parser<$ast.StatementBlock>;
export declare const StatementReturn: $.Parser<$ast.StatementReturn>;
export declare const StatementCondition: $.Parser<$ast.StatementCondition>;
export declare const StatementWhile: $.Parser<$ast.StatementWhile>;
export declare const StatementRepeat: $.Parser<$ast.StatementRepeat>;
export declare const StatementUntil: $.Parser<$ast.StatementUntil>;
export declare const StatementTry: $.Parser<$ast.StatementTry>;
export declare const StatementForEach: $.Parser<$ast.StatementForEach>;
export declare const StatementExpression: $.Parser<$ast.StatementExpression>;
export declare const StatementAssign: $.Parser<$ast.StatementAssign>;
export declare const statement: $.Parser<$ast.statement>;
export declare const statements: $.Parser<$ast.statements>;
export declare const augmentedOp: $.Parser<$ast.augmentedOp>;
export declare const FalseBranch: $.Parser<$ast.FalseBranch>;
export declare const RegularField: $.Parser<$ast.RegularField>;
export declare const PunnedField: $.Parser<$ast.PunnedField>;
export declare const destructItem: $.Parser<$ast.destructItem>;
export declare const RestArgument: $.Parser<$ast.RestArgument>;
export declare const NoRestArgument: $.Parser<$ast.NoRestArgument>;
export declare const optionalRest: $.Parser<$ast.optionalRest>;
export declare const Conditional: $.Parser<$ast.Conditional>;
export declare const expression: $.Parser<$ast.expression>;
export declare const Binary: <T, U>(T: $.Parser<T>, U: $.Parser<U>) => $.Parser<$ast.Binary<T, U>>;
export declare const Unary: $.Parser<$ast.Unary>;
export declare const mul: $.Parser<$ast.mul>;
export declare const add: $.Parser<$ast.add>;
export declare const bitwiseShift: $.Parser<$ast.bitwiseShift>;
export declare const compare: $.Parser<$ast.compare>;
export declare const equality: $.Parser<$ast.equality>;
export declare const bitwiseAnd: $.Parser<$ast.bitwiseAnd>;
export declare const bitwiseXor: $.Parser<$ast.bitwiseXor>;
export declare const bitwiseOr: $.Parser<$ast.bitwiseOr>;
export declare const and: $.Parser<$ast.and>;
export declare const or: $.Parser<$ast.or>;
export declare const Suffix: $.Parser<$ast.Suffix>;
export declare const Operator: <U>(U: $.Parser<U>) => $.Parser<$ast.Operator<U>>;
export declare const SuffixUnboxNotNull: $.Parser<$ast.SuffixUnboxNotNull>;
export declare const SuffixCall: $.Parser<$ast.SuffixCall>;
export declare const SuffixFieldAccess: $.Parser<$ast.SuffixFieldAccess>;
export declare const suffix: $.Parser<$ast.suffix>;
export declare const Parens: $.Parser<$ast.Parens>;
export declare const StructInstance: $.Parser<$ast.StructInstance>;
export declare const IntegerLiteral: $.Parser<$ast.IntegerLiteral>;
export declare const BoolLiteral: $.Parser<$ast.BoolLiteral>;
export declare const InitOf: $.Parser<$ast.InitOf>;
export declare const Null: $.Parser<$ast.Null>;
export declare const primary: $.Parser<$ast.primary>;
export declare const parens: $.Parser<$ast.parens>;
export declare const StructFieldInitializer: $.Parser<$ast.StructFieldInitializer>;
export declare const parameterList: <T>(T: $.Parser<T>) => $.Parser<$ast.parameterList<T>>;
export declare const IntegerLiteralHex: $.Parser<$ast.IntegerLiteralHex>;
export declare const IntegerLiteralBin: $.Parser<$ast.IntegerLiteralBin>;
export declare const IntegerLiteralOct: $.Parser<$ast.IntegerLiteralOct>;
export declare const underscored: <T>(T: $.Parser<T>) => $.Parser<$ast.underscored<T>>;
export declare const digit: $.Parser<$ast.digit>;
export declare const idPart: $.Parser<$ast.idPart>;
export declare const FuncId: $.Parser<$ast.FuncId>;
export declare const hexDigit: $.Parser<$ast.hexDigit>;
export declare const escapeChar: $.Parser<$ast.escapeChar>;
export declare const reservedWord: $.Parser<$ast.reservedWord>;
export declare const space: $.Parser<$ast.space>;
export declare const JustImports: $.Parser<$ast.JustImports>;

            };
/// <amd-module name="tact-compiler/grammar/parser-error.d.ts" /> 
 declare module "tact-compiler/grammar/parser-error.d.ts" {
                import { ErrorDisplay } from "../error/display";
export declare const syntaxErrorSchema: <T, U>(display: ErrorDisplay<T>, handle: (t: T) => U) => {
    constant: {
        duplicate: (attr: string) => U;
        notAbstract: () => U;
        tooAbstract: () => U;
    };
    function: {
        duplicate: (attr: string) => U;
        notAbstract: () => U;
        tooAbstract: () => U;
    };
    topLevelConstantWithAttribute: () => U;
    literalTooLong: () => U;
    extraneousComma: () => U;
    duplicateField: (name: string) => U;
    restShouldBeLast: () => U;
    importWithBackslash: () => U;
    reservedVarPrefix: (prefix: string) => U;
    notCallable: () => U;
    noBouncedWithoutArg: () => U;
    noBouncedWithString: () => U;
    noConstantDecl: () => U;
    noFunctionDecl: () => U;
    expected: (expects: ReadonlySet<string>) => U;
    invalidFuncId: () => U;
    reservedFuncId: () => U;
    numericFuncId: () => U;
    leadingZeroUnderscore: () => U;
};
export type SyntaxErrors<T> = ReturnType<typeof syntaxErrorSchema<unknown, T>>;

            };
/// <amd-module name="tact-compiler/grammar/prev/grammar.d.ts" /> 
 declare module "tact-compiler/grammar/prev/grammar.d.ts" {
                import { AstExpression, AstModule, AstImport, FactoryAst } from "../../ast/ast";
import { ItemOrigin } from "../src-info";
/**
 * @deprecated
 */
export declare const getParser: (ast: FactoryAst) => {
    parse: (src: string, path: string, origin: ItemOrigin) => AstModule;
    parseExpression: (sourceCode: string) => AstExpression;
    parseImports: (src: string, path: string, origin: ItemOrigin) => AstImport[];
};

            };
/// <amd-module name="tact-compiler/grammar/prev/grammar.ohm-bundle.d.ts" /> 
 declare module "tact-compiler/grammar/prev/grammar.ohm-bundle.d.ts" {
                // AUTOGENERATED FILE
// This file was generated from grammar.ohm by `ohm generateBundles`.

import {
  BaseActionDict,
  Grammar,
  IterationNode,
  Node,
  NonterminalNode,
  Semantics,
  TerminalNode
} from 'ohm-js';

export interface TactActionDict<T> extends BaseActionDict<T> {
  Module?: (this: NonterminalNode, arg0: IterationNode, arg1: IterationNode) => T;
  ModuleItem?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Import?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  JustImports?: (this: NonterminalNode, arg0: IterationNode, arg1: IterationNode) => T;
  PrimitiveTypeDecl?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  ModuleFunction?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AsmFunction?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: IterationNode, arg3: NonterminalNode, arg4: NonterminalNode, arg5: NonterminalNode, arg6: IterationNode, arg7: IterationNode, arg8: TerminalNode, arg9: IterationNode, arg10: TerminalNode) => T;
  ModuleConstant?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  NativeFunctionDecl?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: IterationNode, arg5: NonterminalNode, arg6: NonterminalNode, arg7: NonterminalNode, arg8: IterationNode, arg9: IterationNode, arg10: TerminalNode) => T;
  Type_optional?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode) => T;
  Type_regular?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Type_map?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: IterationNode, arg5: TerminalNode, arg6: NonterminalNode, arg7: IterationNode, arg8: IterationNode, arg9: TerminalNode) => T;
  Type_bounced?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  Type?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FieldDecl?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: IterationNode, arg5: IterationNode, arg6: IterationNode) => T;
  ConstantAttribute_virtual?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ConstantAttribute_override?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ConstantAttribute_abstract?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ConstantAttribute?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ConstantDefinition?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: NonterminalNode, arg5: TerminalNode, arg6: NonterminalNode, arg7: TerminalNode) => T;
  ConstantDeclaration?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: NonterminalNode, arg5: TerminalNode) => T;
  StructDecl_regular?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode, arg4: TerminalNode) => T;
  StructDecl_message?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: IterationNode, arg3: IterationNode, arg4: NonterminalNode, arg5: TerminalNode, arg6: NonterminalNode, arg7: TerminalNode) => T;
  StructDecl?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  StructField?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  StructFields?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  Contract?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: IterationNode, arg5: TerminalNode, arg6: IterationNode, arg7: TerminalNode) => T;
  ContractItemDecl?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Trait?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: IterationNode, arg5: TerminalNode, arg6: IterationNode, arg7: TerminalNode) => T;
  InheritedTraits?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  TraitItemDecl?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  StorageVar?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode) => T;
  ContractInit?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: IterationNode, arg4: TerminalNode) => T;
  ContractAttribute_interface?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  ContractAttribute?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FunctionAttribute_getter?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: IterationNode, arg3: IterationNode) => T;
  FunctionAttribute_mutates?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FunctionAttribute_extends?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FunctionAttribute_virtual?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FunctionAttribute_override?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FunctionAttribute_inline?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FunctionAttribute_abstract?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FunctionAttribute?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AsmShuffle?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: IterationNode, arg3: IterationNode, arg4: TerminalNode) => T;
  FunctionDefinition?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: IterationNode, arg5: IterationNode, arg6: TerminalNode, arg7: IterationNode, arg8: TerminalNode) => T;
  FunctionDeclaration?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: IterationNode, arg5: IterationNode, arg6: TerminalNode) => T;
  Parameters?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: TerminalNode) => T;
  Parameter?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Receiver_regular?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: IterationNode, arg3: TerminalNode, arg4: TerminalNode, arg5: IterationNode, arg6: TerminalNode) => T;
  Receiver_comment?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: TerminalNode, arg5: IterationNode, arg6: TerminalNode) => T;
  Receiver_bounced?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: TerminalNode, arg5: IterationNode, arg6: TerminalNode) => T;
  Receiver_externalRegular?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: IterationNode, arg3: TerminalNode, arg4: TerminalNode, arg5: IterationNode, arg6: TerminalNode) => T;
  Receiver_externalComment?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: TerminalNode, arg5: IterationNode, arg6: TerminalNode) => T;
  Receiver?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AsmInstruction_internal?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: TerminalNode, arg4: NonterminalNode) => T;
  AsmInstruction_list?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: TerminalNode, arg4: NonterminalNode) => T;
  AsmInstruction_listNoStateCheck?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: TerminalNode, arg4: NonterminalNode) => T;
  AsmInstruction_string?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode, arg3: NonterminalNode) => T;
  AsmInstruction_tick?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  AsmInstruction_char?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode) => T;
  AsmInstruction_hexLiteral?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: IterationNode, arg3: TerminalNode, arg4: NonterminalNode) => T;
  AsmInstruction_binLiteral?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode, arg3: NonterminalNode) => T;
  AsmInstruction_custom?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AsmInstruction?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  asmInstruction?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  asmWord?: (this: NonterminalNode, arg0: IterationNode) => T;
  Statement?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  StatementBlock?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  StatementLet?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode, arg4: TerminalNode, arg5: NonterminalNode, arg6: TerminalNode) => T;
  StatementReturn?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  StatementExpression?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode) => T;
  StatementAssign?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  StatementCondition_noElse?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: IterationNode, arg4: TerminalNode) => T;
  StatementCondition_withElse?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: IterationNode, arg4: TerminalNode, arg5: NonterminalNode, arg6: TerminalNode, arg7: IterationNode, arg8: TerminalNode) => T;
  StatementCondition_withElseIf?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: IterationNode, arg4: TerminalNode, arg5: NonterminalNode, arg6: NonterminalNode) => T;
  StatementCondition?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  StatementWhile?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: TerminalNode, arg5: IterationNode, arg6: TerminalNode) => T;
  StatementRepeat?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: TerminalNode, arg5: IterationNode, arg6: TerminalNode) => T;
  StatementUntil?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: IterationNode, arg3: TerminalNode, arg4: NonterminalNode, arg5: TerminalNode, arg6: NonterminalNode, arg7: TerminalNode, arg8: TerminalNode) => T;
  StatementTry_noCatch?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: IterationNode, arg3: TerminalNode) => T;
  StatementTry_withCatch?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: IterationNode, arg3: TerminalNode, arg4: NonterminalNode, arg5: TerminalNode, arg6: NonterminalNode, arg7: TerminalNode, arg8: TerminalNode, arg9: IterationNode, arg10: TerminalNode) => T;
  StatementTry?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  StatementForEach?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: NonterminalNode, arg5: TerminalNode, arg6: NonterminalNode, arg7: TerminalNode, arg8: TerminalNode, arg9: IterationNode, arg10: TerminalNode) => T;
  StatementDestruct?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode, arg4: NonterminalNode, arg5: TerminalNode, arg6: TerminalNode, arg7: NonterminalNode, arg8: TerminalNode) => T;
  EndOfIdentifiers_ignoreUnspecifiedFields?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  EndOfIdentifiers_regular?: (this: NonterminalNode, arg0: IterationNode) => T;
  EndOfIdentifiers?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  DestructItem_regular?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  DestructItem_punned?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  DestructItem?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Expression?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionConditional_ternary?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: NonterminalNode) => T;
  ExpressionConditional?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionOr_or?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionOr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionAnd_and?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionAnd?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionBitwiseOr_bitwiseOr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionBitwiseOr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionBitwiseXor_bitwiseXor?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionBitwiseXor?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionBitwiseAnd_bitwiseAnd?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionBitwiseAnd?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionEquality_not?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionEquality_eq?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionEquality?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionCompare_gt?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionCompare_gte?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionCompare_lt?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionCompare_lte?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionCompare?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionBitwiseShift_shl?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionBitwiseShift_shr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionBitwiseShift?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionAdd_add?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionAdd_sub?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionAdd?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionMul_mul?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionMul_div?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionMul_rem?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionMul?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionUnary_minus?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  ExpressionUnary_plus?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  ExpressionUnary_not?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  ExpressionUnary_bitwiseNot?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  ExpressionUnary?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionPostfix?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionUnboxNotNull?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode) => T;
  ExpressionFieldAccess?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpressionMethodCall?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: NonterminalNode) => T;
  ExpressionPrimary?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpressionParens?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  ExpressionStructInstance?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: TerminalNode) => T;
  ExpressionStaticCall?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  ExpressionInitOf?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  StructFieldInitializer_full?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  StructFieldInitializer_punned?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  StructFieldInitializer?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Arguments?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: TerminalNode) => T;
  typeId?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  typeIdPart?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  integerLiteral?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  integerLiteralDec_nonZeroIntegerLiteralDec?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode) => T;
  integerLiteralDec_integerLiteralWithLeadingZero?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode) => T;
  integerLiteralDec?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  integerLiteralHex?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode) => T;
  integerLiteralBin?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode) => T;
  integerLiteralOct?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode) => T;
  binDigit?: (this: NonterminalNode, arg0: TerminalNode) => T;
  octDigit?: (this: NonterminalNode, arg0: TerminalNode) => T;
  nonZeroDigit?: (this: NonterminalNode, arg0: TerminalNode) => T;
  letterAsciiLC?: (this: NonterminalNode, arg0: TerminalNode) => T;
  letterAsciiUC?: (this: NonterminalNode, arg0: TerminalNode) => T;
  letterAscii?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  letterDigitUnderscore?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  idStart?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  idPart?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  id?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  funcInvalidId_notUnderscore?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notArithOperator?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notComparisonOperator?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notBitwiseOperator?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notAssignOperator?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notDelimiter?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notControlKeyword?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notTypeKeyword?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notKeyword?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notDirective?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  funcInvalidId_notDecimalNumber?: (this: NonterminalNode, arg0: IterationNode, arg1: IterationNode, arg2: TerminalNode) => T;
  funcInvalidId_notHexadecimalNumber?: (this: NonterminalNode, arg0: IterationNode, arg1: TerminalNode, arg2: IterationNode, arg3: TerminalNode) => T;
  funcInvalidId?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  funcPlainId?: (this: NonterminalNode, arg0: IterationNode) => T;
  funcQuotedId?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  funcId?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode) => T;
  boolLiteral?: (this: NonterminalNode, arg0: TerminalNode) => T;
  stringLiteral?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  nonQuoteOrBackslashChar?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  escapeSequence_backslash?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_doubleQuote?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_newline?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_carriageReturn?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_tab?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_verticalTab?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_backspace?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_formFeed?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_unicodeCodePoint?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode, arg4: IterationNode, arg5: IterationNode, arg6: IterationNode, arg7: TerminalNode) => T;
  escapeSequence_unicodeEscape?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: NonterminalNode) => T;
  escapeSequence_hexEscape?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  escapeSequence?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  keyword?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  contract?: (this: NonterminalNode, arg0: TerminalNode) => T;
  let?: (this: NonterminalNode, arg0: TerminalNode) => T;
  fun?: (this: NonterminalNode, arg0: TerminalNode) => T;
  return?: (this: NonterminalNode, arg0: TerminalNode) => T;
  receive?: (this: NonterminalNode, arg0: TerminalNode) => T;
  extend?: (this: NonterminalNode, arg0: TerminalNode) => T;
  external?: (this: NonterminalNode, arg0: TerminalNode) => T;
  native?: (this: NonterminalNode, arg0: TerminalNode) => T;
  primitive?: (this: NonterminalNode, arg0: TerminalNode) => T;
  public?: (this: NonterminalNode, arg0: TerminalNode) => T;
  null?: (this: NonterminalNode, arg0: TerminalNode) => T;
  if?: (this: NonterminalNode, arg0: TerminalNode) => T;
  else?: (this: NonterminalNode, arg0: TerminalNode) => T;
  while?: (this: NonterminalNode, arg0: TerminalNode) => T;
  repeat?: (this: NonterminalNode, arg0: TerminalNode) => T;
  do?: (this: NonterminalNode, arg0: TerminalNode) => T;
  until?: (this: NonterminalNode, arg0: TerminalNode) => T;
  try?: (this: NonterminalNode, arg0: TerminalNode) => T;
  catch?: (this: NonterminalNode, arg0: TerminalNode) => T;
  foreach?: (this: NonterminalNode, arg0: TerminalNode) => T;
  as?: (this: NonterminalNode, arg0: TerminalNode) => T;
  map?: (this: NonterminalNode, arg0: TerminalNode) => T;
  mutates?: (this: NonterminalNode, arg0: TerminalNode) => T;
  extends?: (this: NonterminalNode, arg0: TerminalNode) => T;
  import?: (this: NonterminalNode, arg0: TerminalNode) => T;
  with?: (this: NonterminalNode, arg0: TerminalNode) => T;
  trait?: (this: NonterminalNode, arg0: TerminalNode) => T;
  initOf?: (this: NonterminalNode, arg0: TerminalNode) => T;
  virtual?: (this: NonterminalNode, arg0: TerminalNode) => T;
  override?: (this: NonterminalNode, arg0: TerminalNode) => T;
  inline?: (this: NonterminalNode, arg0: TerminalNode) => T;
  const?: (this: NonterminalNode, arg0: TerminalNode) => T;
  abstract?: (this: NonterminalNode, arg0: TerminalNode) => T;
  reservedWord?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  whiteSpace?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  space?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  comment?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  lineTerminator?: (this: NonterminalNode, arg0: TerminalNode) => T;
  multiLineComment?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  singleLineComment?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode) => T;
}

export interface TactSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: TactActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: TactActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: TactActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: TactActionDict<T>): this;
}

export interface TactGrammar extends Grammar {
  createSemantics(): TactSemantics;
  extendSemantics(superSemantics: TactSemantics): TactSemantics;
}

declare const grammar: TactGrammar;
export default grammar;


            };
/// <amd-module name="tact-compiler/grammar/prev/parser-error.d.ts" /> 
 declare module "tact-compiler/grammar/prev/parser-error.d.ts" {
                import { MatchResult } from "ohm-js";
import { ErrorDisplay } from "../../error/display";
import { ItemOrigin, SrcInfo } from "../src-info";
/**
 * @deprecated
 */
export declare const parserErrorSchema: (display: ErrorDisplay<string>) => {
    generic: (matchResult: MatchResult, path: string, origin: ItemOrigin) => never;
    constant: {
        duplicate: (attr: string) => (source: SrcInfo) => never;
        notAbstract: () => (source: SrcInfo) => never;
        tooAbstract: () => (source: SrcInfo) => never;
    };
    function: {
        duplicate: (attr: string) => (source: SrcInfo) => never;
        notAbstract: () => (source: SrcInfo) => never;
        tooAbstract: () => (source: SrcInfo) => never;
    };
    topLevelConstantWithAttribute: () => (source: SrcInfo) => never;
    literalTooLong: () => (source: SrcInfo) => never;
    extraneousComma: () => (source: SrcInfo) => never;
    duplicateField: (name: string) => (source: SrcInfo) => never;
    restShouldBeLast: () => (source: SrcInfo) => never;
    importWithBackslash: () => (source: SrcInfo) => never;
    reservedVarPrefix: (prefix: string) => (source: SrcInfo) => never;
    notCallable: () => (source: SrcInfo) => never;
    noBouncedWithoutArg: () => (source: SrcInfo) => never;
    noBouncedWithString: () => (source: SrcInfo) => never;
    noConstantDecl: () => (source: SrcInfo) => never;
    noFunctionDecl: () => (source: SrcInfo) => never;
    expected: (expects: ReadonlySet<string>) => (source: SrcInfo) => never;
    invalidFuncId: () => (source: SrcInfo) => never;
    reservedFuncId: () => (source: SrcInfo) => never;
    numericFuncId: () => (source: SrcInfo) => never;
    leadingZeroUnderscore: () => (source: SrcInfo) => never;
};
/**
 * @deprecated
 */
export type ParserErrors = ReturnType<typeof parserErrorSchema>;

            };
/// <amd-module name="tact-compiler/grammar/prev/src-info.d.ts" /> 
 declare module "tact-compiler/grammar/prev/src-info.d.ts" {
                import { Interval } from "ohm-js";
import { ItemOrigin, SrcInfo } from "../src-info";
/**
 * @deprecated
 */
export declare const getSrcInfoFromOhm: ({ sourceString, startIdx, endIdx }: Interval, file: string | null, origin: ItemOrigin) => SrcInfo;

            };
/// <amd-module name="tact-compiler/grammar/src-info.d.ts" /> 
 declare module "tact-compiler/grammar/src-info.d.ts" {
                export type ItemOrigin = "stdlib" | "user";
type LineAndColumnInfo = {
    lineNum: number;
    colNum: number;
    toString(...ranges: number[][]): string;
};
type Interval = {
    contents: string;
    getLineAndColumnMessage(): string;
    getLineAndColumn(): LineAndColumnInfo;
    startIdx: number;
    endIdx: number;
};
declare const srcInfoSymbol: unique symbol;
export declare const isSrcInfo: (t: unknown) => t is SrcInfo;
export interface SrcInfo {
    file: string | null;
    contents: string;
    interval: Interval;
    origin: ItemOrigin;
    /**
     * Tag so that custom snapshot serializer can distinguish it
     */
    [srcInfoSymbol]: true;
    /**
     * toJSON method is provided, so that it's not serialized into snapshots
     */
    toJSON: () => object;
}
export declare const srcInfoEqual: (left: SrcInfo, right: SrcInfo) => boolean;
export declare const getSrcInfo: (sourceString: string, startIdx: number, endIdx: number, file: string | null, origin: ItemOrigin) => SrcInfo;
export declare const dummySrcInfo: SrcInfo;
export {};

            };
/// <amd-module name="tact-compiler/imports/parseImportPath.d.ts" /> 
 declare module "tact-compiler/imports/parseImportPath.d.ts" {
                export declare function parseImportPath(src: string): string[] | null;

            };
/// <amd-module name="tact-compiler/imports/resolveImports.d.ts" /> 
 declare module "tact-compiler/imports/resolveImports.d.ts" {
                import { ItemOrigin, Parser } from "../grammar";
import { VirtualFileSystem } from "../vfs/VirtualFileSystem";
export declare function resolveImports(args: {
    entrypoint: string;
    project: VirtualFileSystem;
    stdlib: VirtualFileSystem;
    parser: Parser;
}): {
    tact: {
        code: string;
        path: string;
        origin: ItemOrigin;
    }[];
    func: {
        code: string;
        path: string;
        origin: ItemOrigin;
    }[];
};

            };
/// <amd-module name="tact-compiler/imports/resolveLibrary.d.ts" /> 
 declare module "tact-compiler/imports/resolveLibrary.d.ts" {
                import { VirtualFileSystem } from "../vfs/VirtualFileSystem";
type ResolveLibraryArgs = {
    path: string;
    name: string;
    project: VirtualFileSystem;
    stdlib: VirtualFileSystem;
};
type ResolveLibraryResult = {
    ok: true;
    path: string;
    kind: "func" | "tact";
    source: "project" | "stdlib";
} | {
    ok: false;
};
export declare function resolveLibrary(args: ResolveLibraryArgs): ResolveLibraryResult;
export {};

            };
/// <amd-module name="tact-compiler/imports/stdlib.d.ts" /> 
 declare module "tact-compiler/imports/stdlib.d.ts" {
                declare const files: Record<string, string>;
export default files;

            };
/// <amd-module name="tact-compiler/node.d.ts" /> 
 declare module "tact-compiler/node.d.ts" {
                import { ConfigProject } from "./config/parseConfig";
type AdditionalCliOptions = {
    mode?: ConfigProject["mode"];
};
export declare function run(args: {
    fileName?: string;
    configPath?: string;
    projectNames?: string[];
    additionalCliOptions?: AdditionalCliOptions;
    suppressLog?: boolean;
}): Promise<{
    ok: boolean;
    error: Error[];
}>;
export { createNodeFileSystem } from "./vfs/createNodeFileSystem";
export { parseAndEvalExpression } from "./optimizer/interpreter";
export { showValue } from "./types/types";

            };
/// <amd-module name="tact-compiler/optimizer/algebraic.d.ts" /> 
 declare module "tact-compiler/optimizer/algebraic.d.ts" {
                import { AstExpression } from "../ast/ast";
import { ExpressionTransformer, Rule } from "./types";
export declare class AddZero extends Rule {
    private additiveOperators;
    applyRule(ast: AstExpression, { util }: ExpressionTransformer): AstExpression;
}
export declare class MultiplyZero extends Rule {
    applyRule(ast: AstExpression, { util }: ExpressionTransformer): AstExpression;
}
export declare class MultiplyOne extends Rule {
    applyRule(ast: AstExpression, _optimizer: ExpressionTransformer): AstExpression;
}
export declare class SubtractSelf extends Rule {
    applyRule(ast: AstExpression, { util }: ExpressionTransformer): AstExpression;
}
export declare class AddSelf extends Rule {
    applyRule(ast: AstExpression, { applyRules, util }: ExpressionTransformer): AstExpression;
}
export declare class OrTrue extends Rule {
    applyRule(ast: AstExpression, { util }: ExpressionTransformer): AstExpression;
}
export declare class AndFalse extends Rule {
    applyRule(ast: AstExpression, { util }: ExpressionTransformer): AstExpression;
}
export declare class OrFalse extends Rule {
    applyRule(ast: AstExpression, _optimizer: ExpressionTransformer): AstExpression;
}
export declare class AndTrue extends Rule {
    applyRule(ast: AstExpression, _optimizer: ExpressionTransformer): AstExpression;
}
export declare class OrSelf extends Rule {
    applyRule(ast: AstExpression, _optimizer: ExpressionTransformer): AstExpression;
}
export declare class AndSelf extends Rule {
    applyRule(ast: AstExpression, _optimizer: ExpressionTransformer): AstExpression;
}
export declare class ExcludedMiddle extends Rule {
    applyRule(ast: AstExpression, { util }: ExpressionTransformer): AstExpression;
}
export declare class Contradiction extends Rule {
    applyRule(ast: AstExpression, { util }: ExpressionTransformer): AstExpression;
}
export declare class DoubleNegation extends Rule {
    applyRule(ast: AstExpression, _optimizer: ExpressionTransformer): AstExpression;
}
export declare class NegateTrue extends Rule {
    applyRule(ast: AstExpression, { util }: ExpressionTransformer): AstExpression;
}
export declare class NegateFalse extends Rule {
    applyRule(ast: AstExpression, { util }: ExpressionTransformer): AstExpression;
}

            };
/// <amd-module name="tact-compiler/optimizer/associative.d.ts" /> 
 declare module "tact-compiler/optimizer/associative.d.ts" {
                import { SrcInfo } from "../grammar";
import { AstBinaryOperation, AstExpression, AstLiteral } from "../ast/ast";
import { ExpressionTransformer, Rule } from "./types";
import { AstUtil } from "./util";
type TransformData = {
    simplifiedExpression: AstExpression;
    safetyCondition: boolean;
};
type Transform = (x1: AstExpression, c1: AstLiteral, c2: AstLiteral, util: AstUtil, s: SrcInfo) => TransformData;
declare abstract class AssociativeRewriteRule extends Rule {
    private associativeOps;
    private commutativeOps;
    constructor();
    areAssociative(op1: AstBinaryOperation, op2: AstBinaryOperation): boolean;
    isCommutative(op: AstBinaryOperation): boolean;
}
declare abstract class AllowableOpRule extends AssociativeRewriteRule {
    private allowedOps;
    constructor();
    isAllowedOp(op: AstBinaryOperation): boolean;
    areAllowedOps(op: AstBinaryOperation[]): boolean;
}
export declare class AssociativeRule1 extends AllowableOpRule {
    applyRule(ast: AstExpression, { applyRules, util }: ExpressionTransformer): AstExpression;
}
export declare class AssociativeRule2 extends AllowableOpRule {
    applyRule(ast: AstExpression, { applyRules, util }: ExpressionTransformer): AstExpression;
}
export declare class AssociativeRule3 extends Rule {
    private leftAssocTransforms;
    private rightAssocTransforms;
    private rightCommuteTransforms;
    private leftCommuteTransforms;
    private standardAdditiveCondition;
    private shiftedAdditiveCondition;
    private oppositeAdditiveCondition;
    private standardMultiplicativeCondition;
    constructor();
    private lookupTransform;
    protected getLeftAssociativityTransform(keyOp1: AstBinaryOperation, keyOp2: AstBinaryOperation): Transform | undefined;
    protected getRightAssociativityTransform(keyOp1: AstBinaryOperation, keyOp2: AstBinaryOperation): Transform | undefined;
    protected getLeftCommutativityTransform(keyOp1: AstBinaryOperation, keyOp2: AstBinaryOperation): Transform | undefined;
    protected getRightCommutativityTransform(keyOp1: AstBinaryOperation, keyOp2: AstBinaryOperation): Transform | undefined;
    applyRule(ast: AstExpression, { applyRules, util }: ExpressionTransformer): AstExpression;
}
export {};

            };
/// <amd-module name="tact-compiler/optimizer/constEval.d.ts" /> 
 declare module "tact-compiler/optimizer/constEval.d.ts" {
                import { CompilerContext } from "../context/context";
import { AstBinaryOperation, AstExpression, AstUnaryOperation, AstLiteral } from "../ast/ast";
import { AstUtil } from "./util";
import { InterpreterConfig } from "./interpreter";
import { SrcInfo } from "../grammar";
export declare const getOptimizer: (util: AstUtil) => {
    partiallyEvalUnaryOp: (op: AstUnaryOperation, operand: AstExpression, source: SrcInfo, ctx: CompilerContext) => AstExpression;
    partiallyEvalBinaryOp: (op: AstBinaryOperation, left: AstExpression, right: AstExpression, source: SrcInfo, ctx: CompilerContext) => AstExpression;
    partiallyEvalExpression: (ast: AstExpression, ctx: CompilerContext, interpreterConfig?: InterpreterConfig) => AstExpression;
};
export declare function evalConstantExpression(ast: AstExpression, ctx: CompilerContext, util: AstUtil, interpreterConfig?: InterpreterConfig): AstLiteral;

            };
/// <amd-module name="tact-compiler/optimizer/interpreter.d.ts" /> 
 declare module "tact-compiler/optimizer/interpreter.d.ts" {
                import { CompilerContext } from "../context/context";
import { AstAddress, AstBinaryOperation, AstBoolean, AstCell, AstCommentValue, AstCondition, AstConditional, AstConstantDef, AstContract, AstExpression, AstFieldAccess, AstFunctionDef, AstId, AstInitOf, AstLiteral, AstMessageDecl, AstMethodCall, AstModuleItem, AstNativeFunctionDecl, AstNull, AstNumber, AstOpBinary, AstOpUnary, AstPrimitiveTypeDecl, AstSimplifiedString, AstSlice, FactoryAst, AstStatement, AstStatementAssign, AstStatementAugmentedAssign, AstStatementDestruct, AstStatementExpression, AstStatementForEach, AstStatementLet, AstStatementRepeat, AstStatementReturn, AstStatementTry, AstStatementTryCatch, AstStatementUntil, AstStatementWhile, AstStaticCall, AstString, AstStructDecl, AstStructInstance, AstStructValue, AstTrait, AstUnaryOperation, AstStatementBlock } from "../ast/ast";
import { AstUtil } from "./util";
import { Parser } from "../grammar/grammar";
import { SrcInfo } from "../grammar";
export declare function throwNonFatalErrorConstEval(msg: string, source: SrcInfo): never;
type EvalResult = {
    kind: "ok";
    value: AstLiteral;
} | {
    kind: "error";
    message: string;
};
export declare function ensureInt(val: AstExpression): AstNumber;
export declare function ensureBoolean(val: AstExpression): AstBoolean;
export declare function ensureString(val: AstExpression): AstString;
export declare function ensureSimplifiedString(val: AstExpression): AstSimplifiedString;
export declare function evalUnaryOp(op: AstUnaryOperation, valOperand: AstLiteral, source: SrcInfo, util: AstUtil): AstLiteral;
export declare function evalBinaryOp(op: AstBinaryOperation, valLeft: AstLiteral, valRightContinuation: () => AstLiteral, // It needs to be a continuation, because some binary operators short-circuit
source: SrcInfo, util: AstUtil): AstLiteral;
export declare function interpretEscapeSequences(stringLiteral: string, source: SrcInfo): string;
export type InterpreterConfig = {
    maxLoopIterations: bigint;
};
export declare function parseAndEvalExpression(sourceCode: string, ast?: FactoryAst, parser?: Parser, util?: AstUtil): EvalResult;
export declare class Interpreter {
    private envStack;
    private context;
    private config;
    private util;
    constructor(util: AstUtil, context?: CompilerContext, config?: InterpreterConfig);
    interpretModuleItem(ast: AstModuleItem): void;
    interpretConstantDef(ast: AstConstantDef): void;
    interpretFunctionDef(ast: AstFunctionDef): void;
    interpretStructDecl(ast: AstStructDecl): void;
    interpretMessageDecl(ast: AstMessageDecl): void;
    interpretPrimitiveTypeDecl(ast: AstPrimitiveTypeDecl): void;
    interpretFunctionDecl(ast: AstNativeFunctionDecl): void;
    interpretContract(ast: AstContract): void;
    interpretTrait(ast: AstTrait): void;
    interpretExpression(ast: AstExpression): AstLiteral;
    interpretName(ast: AstId): AstLiteral;
    interpretMethodCall(ast: AstMethodCall): AstLiteral;
    interpretInitOf(ast: AstInitOf): AstLiteral;
    interpretNull(ast: AstNull): AstNull;
    interpretBoolean(ast: AstBoolean): AstBoolean;
    interpretNumber(ast: AstNumber): AstNumber;
    interpretString(ast: AstString): AstSimplifiedString;
    interpretCommentValue(ast: AstCommentValue): AstCommentValue;
    interpretSimplifiedString(ast: AstSimplifiedString): AstSimplifiedString;
    interpretAddress(ast: AstAddress): AstAddress;
    interpretCell(ast: AstCell): AstCell;
    interpretSlice(ast: AstSlice): AstSlice;
    interpretUnaryOp(ast: AstOpUnary): AstLiteral;
    interpretBinaryOp(ast: AstOpBinary): AstLiteral;
    interpretConditional(ast: AstConditional): AstLiteral;
    interpretStructInstance(ast: AstStructInstance): AstStructValue;
    interpretStructValue(ast: AstStructValue): AstStructValue;
    interpretFieldAccess(ast: AstFieldAccess): AstLiteral;
    interpretStaticCall(ast: AstStaticCall): AstLiteral;
    private evalStaticFunction;
    interpretStatement(ast: AstStatement): void;
    interpretLetStatement(ast: AstStatementLet): void;
    interpretDestructStatement(ast: AstStatementDestruct): void;
    interpretAssignStatement(ast: AstStatementAssign): void;
    interpretAugmentedAssignStatement(ast: AstStatementAugmentedAssign): void;
    interpretConditionStatement(ast: AstCondition): void;
    interpretExpressionStatement(ast: AstStatementExpression): void;
    interpretForEachStatement(ast: AstStatementForEach): void;
    interpretRepeatStatement(ast: AstStatementRepeat): void;
    interpretReturnStatement(ast: AstStatementReturn): void;
    interpretTryStatement(ast: AstStatementTry): void;
    interpretTryCatchStatement(ast: AstStatementTryCatch): void;
    interpretUntilStatement(ast: AstStatementUntil): void;
    interpretWhileStatement(ast: AstStatementWhile): void;
    interpretBlockStatement(ast: AstStatementBlock): void;
}
export {};

            };
/// <amd-module name="tact-compiler/optimizer/standardOptimizer.d.ts" /> 
 declare module "tact-compiler/optimizer/standardOptimizer.d.ts" {
                import { AstExpression } from "../ast/ast";
import { ExpressionTransformer } from "./types";
import { AstUtil } from "./util";
export declare class StandardOptimizer implements ExpressionTransformer {
    util: AstUtil;
    private rules;
    constructor(util: AstUtil);
    applyRules: (ast: AstExpression) => AstExpression;
}

            };
/// <amd-module name="tact-compiler/optimizer/types.d.ts" /> 
 declare module "tact-compiler/optimizer/types.d.ts" {
                import { AstExpression } from "../ast/ast";
import { AstUtil } from "./util";
export interface ExpressionTransformer {
    util: AstUtil;
    applyRules(ast: AstExpression): AstExpression;
}
export declare abstract class Rule {
    abstract applyRule(ast: AstExpression, optimizer: ExpressionTransformer): AstExpression;
}

            };
/// <amd-module name="tact-compiler/optimizer/util.d.ts" /> 
 declare module "tact-compiler/optimizer/util.d.ts" {
                import { Address, Cell, Slice } from "@ijstech/ton-core";
import { AstExpression, AstUnaryOperation, AstBinaryOperation, AstNumber, AstBoolean, AstSimplifiedString, AstNull, AstCell, AstSlice, AstAddress, AstLiteral, AstStructValue, AstStructFieldValue, AstId, AstCommentValue, FactoryAst } from "../ast/ast";
import { SrcInfo } from "../grammar";
export declare const getAstUtil: ({ createNode }: FactoryAst) => {
    makeUnaryExpression: (op: AstUnaryOperation, operand: AstExpression) => AstExpression;
    makeBinaryExpression: (op: AstBinaryOperation, left: AstExpression, right: AstExpression) => AstExpression;
    makeNumberLiteral: (n: bigint, loc: SrcInfo) => AstNumber;
    makeBooleanLiteral: (b: boolean, loc: SrcInfo) => AstBoolean;
    makeSimplifiedStringLiteral: (s: string, loc: SrcInfo) => AstSimplifiedString;
    makeCommentLiteral: (s: string, loc: SrcInfo) => AstCommentValue;
    makeNullLiteral: (loc: SrcInfo) => AstNull;
    makeCellLiteral: (c: Cell, loc: SrcInfo) => AstCell;
    makeSliceLiteral: (s: Slice, loc: SrcInfo) => AstSlice;
    makeAddressLiteral: (a: Address, loc: SrcInfo) => AstAddress;
    makeStructFieldValue: (fieldName: string, val: AstLiteral, loc: SrcInfo) => AstStructFieldValue;
    makeStructValue: (fields: AstStructFieldValue[], type: AstId, loc: SrcInfo) => AstStructValue;
};
export type AstUtil = ReturnType<typeof getAstUtil>;
export declare function checkIsUnaryOpNode(ast: AstExpression): boolean;
export declare function checkIsBinaryOpNode(ast: AstExpression): boolean;
export declare function checkIsBinaryOp_With_RightValue(ast: AstExpression): boolean;
export declare function checkIsBinaryOp_With_LeftValue(ast: AstExpression): boolean;
export declare function checkIsNumber(ast: AstExpression, n: bigint): boolean;
export declare function checkIsName(ast: AstExpression): boolean;
export declare function checkIsBoolean(ast: AstExpression, b: boolean): boolean;
export declare function divFloor(a: bigint, b: bigint): bigint;
export declare function abs(a: bigint): bigint;
export declare function sign(a: bigint): bigint;
export declare function modFloor(a: bigint, b: bigint): bigint;

            };
/// <amd-module name="tact-compiler/packaging/fileFormat.d.ts" /> 
 declare module "tact-compiler/packaging/fileFormat.d.ts" {
                import { z } from "zod";
export declare const fileFormat: z.ZodObject<{
    name: z.ZodString;
    code: z.ZodString;
    abi: z.ZodString;
    init: z.ZodObject<{
        kind: z.ZodLiteral<"direct">;
        args: z.ZodArray<z.ZodObject<{
            name: z.ZodString;
            type: z.ZodUnion<[z.ZodObject<{
                kind: z.ZodLiteral<"simple">;
                type: z.ZodString;
                optional: z.ZodNullable<z.ZodOptional<z.ZodBoolean>>;
                format: z.ZodNullable<z.ZodOptional<z.ZodUnion<[z.ZodBoolean, z.ZodNumber, z.ZodString]>>>;
            }, "strip", z.ZodTypeAny, {
                type: string;
                kind: "simple";
                optional?: boolean | null | undefined;
                format?: string | number | boolean | null | undefined;
            }, {
                type: string;
                kind: "simple";
                optional?: boolean | null | undefined;
                format?: string | number | boolean | null | undefined;
            }>, z.ZodObject<{
                kind: z.ZodLiteral<"dict">;
                format: z.ZodNullable<z.ZodOptional<z.ZodUnion<[z.ZodBoolean, z.ZodNumber, z.ZodString]>>>;
                key: z.ZodString;
                keyFormat: z.ZodNullable<z.ZodOptional<z.ZodUnion<[z.ZodBoolean, z.ZodNumber, z.ZodString]>>>;
                value: z.ZodString;
                valueFormat: z.ZodNullable<z.ZodOptional<z.ZodUnion<[z.ZodBoolean, z.ZodNumber, z.ZodString]>>>;
            }, "strip", z.ZodTypeAny, {
                value: string;
                kind: "dict";
                key: string;
                format?: string | number | boolean | null | undefined;
                keyFormat?: string | number | boolean | null | undefined;
                valueFormat?: string | number | boolean | null | undefined;
            }, {
                value: string;
                kind: "dict";
                key: string;
                format?: string | number | boolean | null | undefined;
                keyFormat?: string | number | boolean | null | undefined;
                valueFormat?: string | number | boolean | null | undefined;
            }>]>;
        }, "strip", z.ZodTypeAny, {
            type: {
                type: string;
                kind: "simple";
                optional?: boolean | null | undefined;
                format?: string | number | boolean | null | undefined;
            } | {
                value: string;
                kind: "dict";
                key: string;
                format?: string | number | boolean | null | undefined;
                keyFormat?: string | number | boolean | null | undefined;
                valueFormat?: string | number | boolean | null | undefined;
            };
            name: string;
        }, {
            type: {
                type: string;
                kind: "simple";
                optional?: boolean | null | undefined;
                format?: string | number | boolean | null | undefined;
            } | {
                value: string;
                kind: "dict";
                key: string;
                format?: string | number | boolean | null | undefined;
                keyFormat?: string | number | boolean | null | undefined;
                valueFormat?: string | number | boolean | null | undefined;
            };
            name: string;
        }>, "many">;
        prefix: z.ZodOptional<z.ZodObject<{
            bits: z.ZodNumber;
            value: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            value: number;
            bits: number;
        }, {
            value: number;
            bits: number;
        }>>;
        deployment: z.ZodUnion<[z.ZodObject<{
            kind: z.ZodLiteral<"direct">;
        }, "strip", z.ZodTypeAny, {
            kind: "direct";
        }, {
            kind: "direct";
        }>, z.ZodObject<{
            kind: z.ZodLiteral<"system-cell">;
            system: z.ZodNullable<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            kind: "system-cell";
            system: string | null;
        }, {
            kind: "system-cell";
            system: string | null;
        }>]>;
    }, "strip", z.ZodTypeAny, {
        args: {
            type: {
                type: string;
                kind: "simple";
                optional?: boolean | null | undefined;
                format?: string | number | boolean | null | undefined;
            } | {
                value: string;
                kind: "dict";
                key: string;
                format?: string | number | boolean | null | undefined;
                keyFormat?: string | number | boolean | null | undefined;
                valueFormat?: string | number | boolean | null | undefined;
            };
            name: string;
        }[];
        kind: "direct";
        deployment: {
            kind: "direct";
        } | {
            kind: "system-cell";
            system: string | null;
        };
        prefix?: {
            value: number;
            bits: number;
        } | undefined;
    }, {
        args: {
            type: {
                type: string;
                kind: "simple";
                optional?: boolean | null | undefined;
                format?: string | number | boolean | null | undefined;
            } | {
                value: string;
                kind: "dict";
                key: string;
                format?: string | number | boolean | null | undefined;
                keyFormat?: string | number | boolean | null | undefined;
                valueFormat?: string | number | boolean | null | undefined;
            };
            name: string;
        }[];
        kind: "direct";
        deployment: {
            kind: "direct";
        } | {
            kind: "system-cell";
            system: string | null;
        };
        prefix?: {
            value: number;
            bits: number;
        } | undefined;
    }>;
    sources: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    compiler: z.ZodObject<{
        name: z.ZodString;
        version: z.ZodString;
        parameters: z.ZodNullable<z.ZodOptional<z.ZodString>>;
    }, "strip", z.ZodTypeAny, {
        name: string;
        version: string;
        parameters?: string | null | undefined;
    }, {
        name: string;
        version: string;
        parameters?: string | null | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    code: string;
    name: string;
    init: {
        args: {
            type: {
                type: string;
                kind: "simple";
                optional?: boolean | null | undefined;
                format?: string | number | boolean | null | undefined;
            } | {
                value: string;
                kind: "dict";
                key: string;
                format?: string | number | boolean | null | undefined;
                keyFormat?: string | number | boolean | null | undefined;
                valueFormat?: string | number | boolean | null | undefined;
            };
            name: string;
        }[];
        kind: "direct";
        deployment: {
            kind: "direct";
        } | {
            kind: "system-cell";
            system: string | null;
        };
        prefix?: {
            value: number;
            bits: number;
        } | undefined;
    };
    abi: string;
    compiler: {
        name: string;
        version: string;
        parameters?: string | null | undefined;
    };
    sources?: Record<string, string> | undefined;
}, {
    code: string;
    name: string;
    init: {
        args: {
            type: {
                type: string;
                kind: "simple";
                optional?: boolean | null | undefined;
                format?: string | number | boolean | null | undefined;
            } | {
                value: string;
                kind: "dict";
                key: string;
                format?: string | number | boolean | null | undefined;
                keyFormat?: string | number | boolean | null | undefined;
                valueFormat?: string | number | boolean | null | undefined;
            };
            name: string;
        }[];
        kind: "direct";
        deployment: {
            kind: "direct";
        } | {
            kind: "system-cell";
            system: string | null;
        };
        prefix?: {
            value: number;
            bits: number;
        } | undefined;
    };
    abi: string;
    compiler: {
        name: string;
        version: string;
        parameters?: string | null | undefined;
    };
    sources?: Record<string, string> | undefined;
}>;
export type PackageFileFormat = z.infer<typeof fileFormat>;

            };
/// <amd-module name="tact-compiler/packaging/packageCode.d.ts" /> 
 declare module "tact-compiler/packaging/packageCode.d.ts" {
                import { PackageFileFormat } from "./fileFormat";
export declare function packageCode(pkg: PackageFileFormat): string;

            };
/// <amd-module name="tact-compiler/pipeline/build.d.ts" /> 
 declare module "tact-compiler/pipeline/build.d.ts" {
                import { ConfigProject } from "../config/parseConfig";
import { CompilerContext } from "../context/context";
import { ILogger } from "../context/logger";
import { VirtualFileSystem } from "../vfs/VirtualFileSystem";
import { FactoryAst } from "../ast/ast";
import { TactErrorCollection } from "../error/errors";
import { Parser } from "../grammar";
export declare function enableFeatures(ctx: CompilerContext, logger: ILogger, config: ConfigProject): CompilerContext;
export declare function build(args: {
    config: ConfigProject;
    project: VirtualFileSystem;
    stdlib: string | VirtualFileSystem;
    logger?: ILogger;
    parser?: Parser;
    ast?: FactoryAst;
}): Promise<{
    ok: boolean;
    error: TactErrorCollection[];
}>;

            };
/// <amd-module name="tact-compiler/pipeline/compile.d.ts" /> 
 declare module "tact-compiler/pipeline/compile.d.ts" {
                import { CompilerContext } from "../context/context";
export declare function compile(ctx: CompilerContext, name: string, basename: string): Promise<{
    output: {
        entrypoint: string;
        files: {
            name: string;
            code: string;
        }[];
        abi: string;
    };
    ctx: CompilerContext;
}>;

            };
/// <amd-module name="tact-compiler/pipeline/precompile.d.ts" /> 
 declare module "tact-compiler/pipeline/precompile.d.ts" {
                import { CompilerContext } from "../context/context";
import { VirtualFileSystem } from "../vfs/VirtualFileSystem";
import { AstModule, FactoryAst } from "../ast/ast";
import { Parser } from "../grammar";
export declare function precompile(ctx: CompilerContext, project: VirtualFileSystem, stdlib: VirtualFileSystem, entrypoint: string, parser: Parser, ast: FactoryAst, parsedModules?: AstModule[]): CompilerContext;

            };
/// <amd-module name="tact-compiler/pipeline/version.d.ts" /> 
 declare module "tact-compiler/pipeline/version.d.ts" {
                export declare function __DANGER__disableVersionNumber(): void;
export declare function getCompilerVersion(): string;

            };
/// <amd-module name="tact-compiler/prettyPrinter.d.ts" /> 
 declare module "tact-compiler/prettyPrinter.d.ts" {
                import * as A from "./ast/ast";
export declare const ppAstTypeId: typeof A.idText;
export declare const ppAstTypeIdWithStorage: (type: A.AstTypeId, storageType: A.AstId | null) => string;
export declare const ppAstMapType: ({ keyType, keyStorageType, valueType, valueStorageType, }: A.AstMapType) => string;
export declare const ppAstBouncedMessageType: ({ messageType, }: A.AstBouncedMessageType) => string;
export declare const ppAstOptionalType: ({ typeArg }: A.AstOptionalType) => string;
export declare const ppAstType: (input: A.AstType) => string;
export declare const unaryOperatorType: Record<A.AstUnaryOperation, "post" | "pre">;
export declare const checkPostfix: (operator: A.AstUnaryOperation) => boolean;
/**
 * Description of precedence of certain type of AST node
 */
export type Precedence = {
    /**
     * Add parentheses around `code` if in this `parent` position we need brackets
     * @param check Position-checking function from parent
     * @param code Code to put parentheses around
     * @returns
     */
    brace: (position: (childPrecedence: number) => boolean, code: string) => string;
    /**
     * Used in positions where grammar rule mentions itself
     *
     * Passed down when a position allows same unparenthesized operator
     * For example, on left side of addition we can use another addition without
     * parentheses: `1 + 2 + 3` means `(1 + 2) + 3`. Thus for left-associative
     * operators we pass `self` to their left argument printer.
     */
    self: (childPrecedence: number) => boolean;
    /**
     * Used in positions where grammar rule mentions other rule
     *
     * Passed down when a position disallows same unparenthesized operator
     * For example, on the right side of subtraction we can't use another subtraction
     * without parentheses: `1 - (2 - 3)` is not the same as `(1 - 2) - 3`. Thus for
     * left-associative operators we pass `child` to their right argument printer.
     */
    child: (childPrecedence: number) => boolean;
};
/**
 * Given numeric value of precedence, where higher values stand for higher binding power,
 * create a helper object for precedence checking
 */
export declare const makePrecedence: (myPrecedence: number) => Precedence;
export declare const lowestPrecedence: Precedence;
export declare const conditionalPrecedence: Precedence;
export declare const binaryPrecedence: Readonly<Record<A.AstBinaryOperation, Precedence>>;
export declare const prefixPrecedence: Precedence;
export declare const postfixPrecedence: Precedence;
/**
 * Expression printer takes an expression and a function from parent AST node printer that checks
 * whether expressions with given precedence should be parenthesized in parent context
 */
export type ExprPrinter<T> = (expr: T) => (check: (childPrecedence: number) => boolean) => string;
/**
 * Wrapper for AST nodes that should never be parenthesized, and thus do not require information
 * about the position they're printed in
 *
 * Takes a regular printer function and returns corresponding ExprPrinter that ignores all
 * position and precedence information
 */
export declare const ppLeaf: <T>(printer: (t: T) => string) => ExprPrinter<T>;
export declare const ppExprArgs: (args: A.AstExpression[]) => string;
export declare const ppAstStructFieldInit: (param: A.AstStructFieldInitializer) => string;
export declare const ppAstStructFieldValue: (param: A.AstStructFieldValue) => string;
export declare const ppAstStructInstance: ({ type, args }: A.AstStructInstance) => string;
export declare const ppAstStructValue: ({ type, args }: A.AstStructValue) => string;
export declare const ppAstInitOf: ({ contract, args }: A.AstInitOf) => string;
export declare const ppAstNumber: typeof A.astNumToString;
export declare const ppAstBoolean: ({ value }: A.AstBoolean) => string;
export declare const ppAstId: ({ text }: A.AstId) => string;
export declare const ppAstNull: (_expr: A.AstNull) => string;
export declare const ppAstString: ({ value }: A.AstString) => string;
export declare const ppAstCommentValue: ({ value }: A.AstCommentValue) => string;
export declare const ppAstSimplifiedString: ({ value }: A.AstSimplifiedString) => string;
export declare const ppAstAddress: ({ value }: A.AstAddress) => string;
export declare const ppAstCell: ({ value }: A.AstCell) => string;
export declare const ppAstSlice: ({ value }: A.AstSlice) => string;
export declare const ppAstStaticCall: ({ function: func, args }: A.AstStaticCall) => string;
export declare const ppAstMethodCall: ExprPrinter<A.AstMethodCall>;
export declare const ppAstFieldAccess: ExprPrinter<A.AstFieldAccess>;
export declare const ppAstOpUnary: ExprPrinter<A.AstOpUnary>;
export declare const ppAstOpBinary: ExprPrinter<A.AstOpBinary>;
export declare const ppAstConditional: ExprPrinter<A.AstConditional>;
export declare const ppAstExpressionNested: (input: A.AstExpression) => (check: (childPrecedence: number) => boolean) => string;
export declare const ppAstExpression: (expr: A.AstExpression) => string;
/**
 * An intermediate language that is only concerned of spacing and indentation
 */
type Context<U> = {
    /**
     * Line of code with \n implied
     */
    row: (s: string) => U;
    /**
     * Stacks lines after each other
     */
    block: (rows: readonly U[]) => U;
    /**
     * Similar to `block`, but adjacent lines of groups get concatenated
     * [a, b] + [c, d] = [a, bc, d]
     */
    concat: (rows: readonly U[]) => U;
    /**
     * Same as `indent`, but indents `rows` 1 level deeper and adds `{` and `}`
     */
    braced: (rows: readonly U[]) => U;
    /**
     * Print a list of `items` with `print`
     */
    list: <T>(items: readonly T[], print: Printer<T>) => readonly U[];
    /**
     * Display `items` with `print` in groups distinguished by return value of `getTag`
     */
    grouped: <T, V>(options: {
        items: readonly T[];
        /**
         * Items with the same tag are displayed without extra empty line between them
         *
         * Use NaN for tag whenever items should always be displayed with empty line,
         * because NaN !== NaN
         */
        getTag: (t: T) => V;
        print: Printer<T>;
    }) => readonly U[];
};
/**
 * Prints AST node of type `T` into an intermediate language of row of type `U`
 *
 * We enforce `U` to be a generic argument so that no implementation can (ab)use
 * the fact it's a string and generate some indentation without resorting to
 * methods of `Context`.
 */
type Printer<T> = (item: T) => <U>(ctx: Context<U>) => U;
export declare const ppAstModule: Printer<A.AstModule>;
export declare const ppAstStruct: Printer<A.AstStructDecl>;
export declare const ppAstContract: Printer<A.AstContract>;
export declare const ppAstPrimitiveTypeDecl: Printer<A.AstPrimitiveTypeDecl>;
export declare const ppAstFunctionDef: Printer<A.AstFunctionDef>;
export declare const ppAsmShuffle: ({ args, ret }: A.AstAsmShuffle) => string;
export declare const ppAstAsmFunctionDef: Printer<A.AstAsmFunctionDef>;
export declare const ppAstNativeFunction: Printer<A.AstNativeFunctionDecl>;
export declare const ppAstTrait: Printer<A.AstTrait>;
export declare const ppAstConstant: Printer<A.AstConstantDef>;
export declare const ppAstMessage: Printer<A.AstMessageDecl>;
export declare const ppModuleItem: Printer<A.AstModuleItem>;
export declare const ppAstFieldDecl: Printer<A.AstFieldDecl>;
export declare const ppAstReceiver: Printer<A.AstReceiver>;
export declare const ppAstFunctionDecl: Printer<A.AstFunctionDecl>;
export declare const ppAstConstDecl: Printer<A.AstConstantDecl>;
export declare const ppTraitBody: Printer<A.AstTraitDeclaration>;
export declare const ppAstInitFunction: Printer<A.AstContractInit>;
export declare const ppContractBody: Printer<A.AstContractDeclaration>;
export declare const ppAstImport: Printer<A.AstImport>;
export declare const ppAstFunctionSignature: ({ name, attributes, return: retTy, params, }: A.AstFunctionDef | A.AstAsmFunctionDef | A.AstFunctionDecl) => string;
export declare const ppAstFunctionAttribute: (attr: A.AstFunctionAttribute) => string;
export declare const ppAstReceiverHeader: (input: A.AstReceiverKind) => string;
export declare const ppAstFuncId: (func: A.AstFuncId) => string;
export declare const ppStatementBlock: Printer<A.AstStatement[]>;
export declare const ppAsmInstructionsBlock: Printer<A.AstAsmInstruction[]>;
export declare const ppAstStatementLet: Printer<A.AstStatementLet>;
export declare const ppAstStatementReturn: Printer<A.AstStatementReturn>;
export declare const ppAstStatementExpression: Printer<A.AstStatementExpression>;
export declare const ppAstStatementAssign: Printer<A.AstStatementAssign>;
export declare const ppAstStatementAugmentedAssign: Printer<A.AstStatementAugmentedAssign>;
export declare const ppAstCondition: Printer<A.AstCondition>;
export declare const ppAstStatementWhile: Printer<A.AstStatementWhile>;
export declare const ppAstStatementRepeat: Printer<A.AstStatementRepeat>;
export declare const ppAstStatementUntil: Printer<A.AstStatementUntil>;
export declare const ppAstStatementForEach: Printer<A.AstStatementForEach>;
export declare const ppAstStatementTry: Printer<A.AstStatementTry>;
export declare const ppAstStatementTryCatch: Printer<A.AstStatementTryCatch>;
export declare const ppAstStatementDestruct: Printer<A.AstStatementDestruct>;
export declare const ppAstStatementBlock: Printer<A.AstStatementBlock>;
export declare const ppAstStatement: Printer<A.AstStatement>;
export declare const exprNode: <T>(exprPrinter: (expr: T) => string) => Printer<T>;
export declare const ppAstNode: Printer<A.AstNode>;
/**
 * Pretty-prints an AST node into a string representation.
 * @param node The AST node to format.
 * @returns A string that represents the formatted AST node.
 */
export declare const prettyPrint: (node: A.AstNode) => string;
export {};

            };
/// <amd-module name="tact-compiler/storage/allocator.d.ts" /> 
 declare module "tact-compiler/storage/allocator.d.ts" {
                import { ABITypeRef } from "@ijstech/ton-core";
import { AllocationCell, AllocationOperation, AllocationOperationType } from "./operation";
export declare function getAllocationOperationFromField(src: ABITypeRef, structLoader: (name: string) => {
    bits: number;
    refs: number;
}): AllocationOperationType;
export declare function allocate(type: {
    reserved: {
        bits: number;
        refs: number;
    };
    ops: AllocationOperation[];
}): AllocationCell;

            };
/// <amd-module name="tact-compiler/storage/operation.d.ts" /> 
 declare module "tact-compiler/storage/operation.d.ts" {
                import { ABITypeRef } from "@ijstech/ton-core";
export type AllocationCell = {
    ops: AllocationOperation[];
    size: {
        bits: number;
        refs: number;
    };
    next: AllocationCell | null;
};
export type AllocationOperation = {
    name: string;
    type: ABITypeRef;
    op: AllocationOperationType;
};
export type AllocationOperationType = {
    kind: "int" | "uint";
    bits: number;
    optional: boolean;
} | {
    kind: "boolean";
    optional: boolean;
} | {
    kind: "varint16" | "varint32" | "varuint16" | "varuint32";
    optional: boolean;
} | {
    kind: "address";
    optional: boolean;
} | {
    kind: "struct";
    type: string;
    ref: boolean;
    optional: boolean;
    size: {
        bits: number;
        refs: number;
    };
} | {
    kind: "cell";
    optional: boolean;
    format: "default" | "remainder";
} | {
    kind: "slice";
    optional: boolean;
    format: "default" | "remainder";
} | {
    kind: "builder";
    optional: boolean;
    format: "default" | "remainder";
} | {
    kind: "map";
} | {
    kind: "string";
    optional: boolean;
} | {
    kind: "fixed-bytes";
    bytes: number;
    optional: boolean;
};

            };
/// <amd-module name="tact-compiler/storage/resolveAllocation.d.ts" /> 
 declare module "tact-compiler/storage/resolveAllocation.d.ts" {
                import { CompilerContext } from "../context/context";
import { TypeDescription } from "../types/types";
import { StorageAllocation } from "./StorageAllocation";
export declare function getAllocation(ctx: CompilerContext, name: string): StorageAllocation;
export declare function getAllocations(ctx: CompilerContext): {
    allocation: StorageAllocation;
    type: TypeDescription;
}[];
export declare function getSortedTypes(ctx: CompilerContext): TypeDescription[];
export declare function resolveAllocations(ctx: CompilerContext): CompilerContext;

            };
/// <amd-module name="tact-compiler/storage/StorageAllocation.d.ts" /> 
 declare module "tact-compiler/storage/StorageAllocation.d.ts" {
                import { AllocationCell, AllocationOperation } from "./operation";
export type StorageAllocation = {
    ops: AllocationOperation[];
    header: {
        value: number;
        bits: number;
    } | null;
    size: {
        bits: number;
        refs: number;
    };
    root: AllocationCell;
};

            };
/// <amd-module name="tact-compiler/test/benchmarks/contracts/output/benchmark_functions_Functions.d.ts" /> 
 declare module "tact-compiler/test/benchmarks/contracts/output/benchmark_functions_Functions.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Add = {
    $$type: 'Add';
    value: bigint;
};
export declare function storeAdd(src: Add): (builder: Builder) => void;
export declare function loadAdd(slice: Slice): {
    $$type: "Add";
    value: bigint;
};
export type Sub = {
    $$type: 'Sub';
    value: bigint;
};
export declare function storeSub(src: Sub): (builder: Builder) => void;
export declare function loadSub(slice: Slice): {
    $$type: "Sub";
    value: bigint;
};
export type Functions$Data = {
    $$type: 'Functions$Data';
    value: bigint;
};
export declare function storeFunctions$Data(src: Functions$Data): (builder: Builder) => void;
export declare function loadFunctions$Data(slice: Slice): {
    $$type: "Functions$Data";
    value: bigint;
};
export declare const Functions_getterMapping: {
    [key: string]: string;
};
export declare class Functions implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Functions>;
    static fromAddress(address: Address): Functions;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Add | Sub): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/benchmarks/contracts/output/benchmark_functions_inline_Functions.d.ts" /> 
 declare module "tact-compiler/test/benchmarks/contracts/output/benchmark_functions_inline_Functions.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Add = {
    $$type: 'Add';
    value: bigint;
};
export declare function storeAdd(src: Add): (builder: Builder) => void;
export declare function loadAdd(slice: Slice): {
    $$type: "Add";
    value: bigint;
};
export type Sub = {
    $$type: 'Sub';
    value: bigint;
};
export declare function storeSub(src: Sub): (builder: Builder) => void;
export declare function loadSub(slice: Slice): {
    $$type: "Sub";
    value: bigint;
};
export type Functions$Data = {
    $$type: 'Functions$Data';
    value: bigint;
};
export declare function storeFunctions$Data(src: Functions$Data): (builder: Builder) => void;
export declare function loadFunctions$Data(slice: Slice): {
    $$type: "Functions$Data";
    value: bigint;
};
export declare const Functions_getterMapping: {
    [key: string]: string;
};
export declare class Functions implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Functions>;
    static fromAddress(address: Address): Functions;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Add | Sub): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_Bar.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_Bar.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const Bar_getterMapping: {
    [key: string]: string;
};
export declare class Bar implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Bar>;
    static fromAddress(address: Address): Bar;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_Example.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_Example.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const Example_getterMapping: {
    [key: string]: string;
};
export declare class Example implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Example>;
    static fromAddress(address: Address): Example;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Binary | Octal | Decimal | Hexadecimal): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_Issue74.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_Issue74.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const Issue74_getterMapping: {
    [key: string]: string;
};
export declare class Issue74 implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Issue74>;
    static fromAddress(address: Address): Issue74;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "send"): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_LargeContract.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_LargeContract.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const LargeContract_getterMapping: {
    [key: string]: string;
};
export declare class LargeContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<LargeContract>;
    static fromAddress(address: Address): LargeContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    getGetTest0(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest1(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest2(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest3(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest4(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest5(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest6(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest7(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest8(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest9(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest10(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest11(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest12(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest13(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest14(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest15(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest16(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest17(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest18(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest19(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest20(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest21(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest22(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest23(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest24(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest25(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest26(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest27(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest28(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest29(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest30(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest31(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest32(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest33(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest34(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest35(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest36(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest37(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest38(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest39(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest40(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest41(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest42(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest43(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest44(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest45(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest46(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest47(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest48(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest49(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest50(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest51(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest52(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest53(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest54(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest55(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest56(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest57(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest58(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest59(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest60(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest61(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest62(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest63(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest64(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest65(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest66(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest67(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest68(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest69(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest70(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest71(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest72(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest73(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest74(provider: ContractProvider, index: bigint): Promise<bigint | null>;
    getGetTest75(provider: ContractProvider, index: bigint): Promise<bigint | null>;
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_Maps.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_Maps.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const Maps_getterMapping: {
    [key: string]: string;
};
export declare class Maps implements Contract {
    static init(arg: Dictionary<bigint, boolean>): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(arg: Dictionary<bigint, boolean>): Promise<Maps>;
    static fromAddress(address: Address): Maps;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "set keys" | "delete keys" | "clear" | Replace | Deploy): Promise<void>;
    getOneItem(provider: ContractProvider, key: bigint): Promise<Address | null>;
    getItemCheck(provider: ContractProvider): Promise<string>;
    getAllItems(provider: ContractProvider): Promise<Dictionary<Address, TokenInfo>>;
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_MapUintBool.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_MapUintBool.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const MapUintBool_getterMapping: {
    [key: string]: string;
};
export declare class MapUintBool implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapUintBool>;
    static fromAddress(address: Address): MapUintBool;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_MutatingMethodOnNonLvalues.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_MutatingMethodOnNonLvalues.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const MutatingMethodOnNonLvalues_getterMapping: {
    [key: string]: string;
};
export declare class MutatingMethodOnNonLvalues implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MutatingMethodOnNonLvalues>;
    static fromAddress(address: Address): MutatingMethodOnNonLvalues;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "foo"): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_Test.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_Test.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const Test_getterMapping: {
    [key: string]: string;
};
export declare class Test implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Test>;
    static fromAddress(address: Address): Test;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "test"): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_TestContract.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_TestContract.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const TestContract_getterMapping: {
    [key: string]: string;
};
export declare class TestContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<TestContract>;
    static fromAddress(address: Address): TestContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    getTestEq(provider: ContractProvider, s: Dictionary<bigint, bigint>): Promise<boolean>;
    getTestNeq(provider: ContractProvider, s: Dictionary<bigint, bigint>): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/codegen/output/codegen_TestGlobalFunctionShadowing.d.ts" /> 
 declare module "tact-compiler/test/codegen/output/codegen_TestGlobalFunctionShadowing.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyMessage = {
    $$type: 'MyMessage';
};
export declare function storeMyMessage(src: MyMessage): (builder: Builder) => void;
export declare function loadMyMessage(slice: Slice): {
    $$type: "MyMessage";
};
export type Issue74$Data = {
    $$type: 'Issue74$Data';
};
export declare function storeIssue74$Data(src: Issue74$Data): (builder: Builder) => void;
export declare function loadIssue74$Data(slice: Slice): {
    $$type: "Issue74$Data";
};
export type LargeContract$Data = {
    $$type: 'LargeContract$Data';
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export declare function storeLargeContract$Data(src: LargeContract$Data): (builder: Builder) => void;
export declare function loadLargeContract$Data(slice: Slice): {
    $$type: "LargeContract$Data";
    testMap0: Dictionary<bigint, bigint>;
    testMap1: Dictionary<bigint, bigint>;
    testMap2: Dictionary<bigint, bigint>;
    testMap3: Dictionary<bigint, bigint>;
    testMap4: Dictionary<bigint, bigint>;
    testMap5: Dictionary<bigint, bigint>;
    testMap6: Dictionary<bigint, bigint>;
    testMap7: Dictionary<bigint, bigint>;
    testMap8: Dictionary<bigint, bigint>;
    testMap9: Dictionary<bigint, bigint>;
    testMap10: Dictionary<bigint, bigint>;
    testMap11: Dictionary<bigint, bigint>;
    testMap12: Dictionary<bigint, bigint>;
    testMap13: Dictionary<bigint, bigint>;
    testMap14: Dictionary<bigint, bigint>;
    testMap15: Dictionary<bigint, bigint>;
    testMap16: Dictionary<bigint, bigint>;
    testMap17: Dictionary<bigint, bigint>;
    testMap18: Dictionary<bigint, bigint>;
    testMap19: Dictionary<bigint, bigint>;
    testMap20: Dictionary<bigint, bigint>;
    testMap21: Dictionary<bigint, bigint>;
    testMap22: Dictionary<bigint, bigint>;
    testMap23: Dictionary<bigint, bigint>;
    testMap24: Dictionary<bigint, bigint>;
    testMap25: Dictionary<bigint, bigint>;
    testMap26: Dictionary<bigint, bigint>;
    testMap27: Dictionary<bigint, bigint>;
    testMap28: Dictionary<bigint, bigint>;
    testMap29: Dictionary<bigint, bigint>;
    testMap30: Dictionary<bigint, bigint>;
    testMap31: Dictionary<bigint, bigint>;
    testMap32: Dictionary<bigint, bigint>;
    testMap33: Dictionary<bigint, bigint>;
    testMap34: Dictionary<bigint, bigint>;
    testMap35: Dictionary<bigint, bigint>;
    testMap36: Dictionary<bigint, bigint>;
    testMap37: Dictionary<bigint, bigint>;
    testMap38: Dictionary<bigint, bigint>;
    testMap39: Dictionary<bigint, bigint>;
    testMap40: Dictionary<bigint, bigint>;
    testMap41: Dictionary<bigint, bigint>;
    testMap42: Dictionary<bigint, bigint>;
    testMap43: Dictionary<bigint, bigint>;
    testMap44: Dictionary<bigint, bigint>;
    testMap45: Dictionary<bigint, bigint>;
    testMap46: Dictionary<bigint, bigint>;
    testMap47: Dictionary<bigint, bigint>;
    testMap48: Dictionary<bigint, bigint>;
    testMap49: Dictionary<bigint, bigint>;
    testMap50: Dictionary<bigint, bigint>;
    testMap51: Dictionary<bigint, bigint>;
    testMap52: Dictionary<bigint, bigint>;
    testMap53: Dictionary<bigint, bigint>;
    testMap54: Dictionary<bigint, bigint>;
    testMap55: Dictionary<bigint, bigint>;
    testMap56: Dictionary<bigint, bigint>;
    testMap57: Dictionary<bigint, bigint>;
    testMap58: Dictionary<bigint, bigint>;
    testMap59: Dictionary<bigint, bigint>;
    testMap60: Dictionary<bigint, bigint>;
    testMap61: Dictionary<bigint, bigint>;
    testMap62: Dictionary<bigint, bigint>;
};
export type TokenInfo = {
    $$type: 'TokenInfo';
    ticker: string;
    decimals: bigint;
};
export declare function storeTokenInfo(src: TokenInfo): (builder: Builder) => void;
export declare function loadTokenInfo(slice: Slice): {
    $$type: "TokenInfo";
    ticker: string;
    decimals: bigint;
};
export type Replace = {
    $$type: 'Replace';
    items: Dictionary<bigint, Address>;
};
export declare function storeReplace(src: Replace): (builder: Builder) => void;
export declare function loadReplace(slice: Slice): {
    $$type: "Replace";
    items: Dictionary<bigint, Address>;
};
export type Maps$Data = {
    $$type: 'Maps$Data';
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export declare function storeMaps$Data(src: Maps$Data): (builder: Builder) => void;
export declare function loadMaps$Data(slice: Slice): {
    $$type: "Maps$Data";
    mi1: Dictionary<bigint, TokenInfo>;
    mi2: Dictionary<bigint, boolean>;
    mi3: Dictionary<bigint, bigint>;
    mi4: Dictionary<bigint, Address>;
    ma1: Dictionary<Address, TokenInfo>;
    ma2: Dictionary<Address, boolean>;
    ma3: Dictionary<Address, bigint>;
    ma4: Dictionary<Address, Address>;
};
export type FunCKeywords = {
    $$type: 'FunCKeywords';
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export declare function storeFunCKeywords(src: FunCKeywords): (builder: Builder) => void;
export declare function loadFunCKeywords(slice: Slice): {
    $$type: "FunCKeywords";
    var: bigint;
    ifnot: bigint;
    then: bigint;
    elseifnot: bigint;
    int: bigint;
    cell: bigint;
    slice: bigint;
    builder: bigint;
    cont: bigint;
    tuple: bigint;
    type: bigint;
    forall: bigint;
    extern: bigint;
    global: bigint;
    asm: bigint;
    impure: bigint;
    inline_ref: bigint;
    auto_apply: bigint;
    method_id: bigint;
    operator: bigint;
    infix: bigint;
    infixl: bigint;
    infixr: bigint;
};
export type Bar$Data = {
    $$type: 'Bar$Data';
    f: FunCKeywords;
};
export declare function storeBar$Data(src: Bar$Data): (builder: Builder) => void;
export declare function loadBar$Data(slice: Slice): {
    $$type: "Bar$Data";
    f: {
        $$type: "FunCKeywords";
        var: bigint;
        ifnot: bigint;
        then: bigint;
        elseifnot: bigint;
        int: bigint;
        cell: bigint;
        slice: bigint;
        builder: bigint;
        cont: bigint;
        tuple: bigint;
        type: bigint;
        forall: bigint;
        extern: bigint;
        global: bigint;
        asm: bigint;
        impure: bigint;
        inline_ref: bigint;
        auto_apply: bigint;
        method_id: bigint;
        operator: bigint;
        infix: bigint;
        infixl: bigint;
        infixr: bigint;
    };
};
export type Binary = {
    $$type: 'Binary';
};
export declare function storeBinary(src: Binary): (builder: Builder) => void;
export declare function loadBinary(slice: Slice): {
    $$type: "Binary";
};
export type Octal = {
    $$type: 'Octal';
};
export declare function storeOctal(src: Octal): (builder: Builder) => void;
export declare function loadOctal(slice: Slice): {
    $$type: "Octal";
};
export type Decimal = {
    $$type: 'Decimal';
};
export declare function storeDecimal(src: Decimal): (builder: Builder) => void;
export declare function loadDecimal(slice: Slice): {
    $$type: "Decimal";
};
export type Hexadecimal = {
    $$type: 'Hexadecimal';
};
export declare function storeHexadecimal(src: Hexadecimal): (builder: Builder) => void;
export declare function loadHexadecimal(slice: Slice): {
    $$type: "Hexadecimal";
};
export type Example$Data = {
    $$type: 'Example$Data';
};
export declare function storeExample$Data(src: Example$Data): (builder: Builder) => void;
export declare function loadExample$Data(slice: Slice): {
    $$type: "Example$Data";
};
export type Position = {
    $$type: 'Position';
    tokenId: bigint;
    foo: bigint | null;
};
export declare function storePosition(src: Position): (builder: Builder) => void;
export declare function loadPosition(slice: Slice): {
    $$type: "Position";
    tokenId: bigint;
    foo: bigint | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export type Foo = {
    $$type: 'Foo';
    x: bigint;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    x: bigint;
};
export type MutatingMethodOnNonLvalues$Data = {
    $$type: 'MutatingMethodOnNonLvalues$Data';
};
export declare function storeMutatingMethodOnNonLvalues$Data(src: MutatingMethodOnNonLvalues$Data): (builder: Builder) => void;
export declare function loadMutatingMethodOnNonLvalues$Data(slice: Slice): {
    $$type: "MutatingMethodOnNonLvalues$Data";
};
export type TestGlobalFunctionShadowing$Data = {
    $$type: 'TestGlobalFunctionShadowing$Data';
};
export declare function storeTestGlobalFunctionShadowing$Data(src: TestGlobalFunctionShadowing$Data): (builder: Builder) => void;
export declare function loadTestGlobalFunctionShadowing$Data(slice: Slice): {
    $$type: "TestGlobalFunctionShadowing$Data";
};
export type MapUintBool$Data = {
    $$type: 'MapUintBool$Data';
    m: Dictionary<bigint, boolean>;
};
export declare function storeMapUintBool$Data(src: MapUintBool$Data): (builder: Builder) => void;
export declare function loadMapUintBool$Data(slice: Slice): {
    $$type: "MapUintBool$Data";
    m: Dictionary<bigint, boolean>;
};
export type TestContract$Data = {
    $$type: 'TestContract$Data';
};
export declare function storeTestContract$Data(src: TestContract$Data): (builder: Builder) => void;
export declare function loadTestContract$Data(slice: Slice): {
    $$type: "TestContract$Data";
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export declare const TestGlobalFunctionShadowing_getterMapping: {
    [key: string]: string;
};
export declare class TestGlobalFunctionShadowing implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<TestGlobalFunctionShadowing>;
    static fromAddress(address: Address): TestGlobalFunctionShadowing;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "foo"): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/compilation-failed/util.d.ts" /> 
 declare module "tact-compiler/test/compilation-failed/util.d.ts" {
                export declare function itShouldNotCompile(params: {
    testName: string;
    errorMessage: string;
}): void;

            };
/// <amd-module name="tact-compiler/test/contracts.build.d.ts" /> 
 declare module "tact-compiler/test/contracts.build.d.ts" {
                export {};

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/address_AddressTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/address_AddressTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type AddressTester$Data = {
    $$type: 'AddressTester$Data';
};
export declare function storeAddressTester$Data(src: AddressTester$Data): (builder: Builder) => void;
export declare function loadAddressTester$Data(slice: Slice): {
    $$type: "AddressTester$Data";
};
export declare const AddressTester_getterMapping: {
    [key: string]: string;
};
export declare class AddressTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<AddressTester>;
    static fromAddress(address: Address): AddressTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTest1(provider: ContractProvider): Promise<Address>;
    getTest2(provider: ContractProvider): Promise<Address>;
    getTest3(provider: ContractProvider): Promise<Address>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/allocation_Test.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/allocation_Test.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type SetCost = {
    $$type: 'SetCost';
    cost: bigint | null;
};
export declare function storeSetCost(src: SetCost): (builder: Builder) => void;
export declare function loadSetCost(slice: Slice): {
    $$type: "SetCost";
    cost: bigint | null;
};
export type Struct2 = {
    $$type: 'Struct2';
    c: string;
    d: string;
    e: string;
    f: string;
};
export declare function storeStruct2(src: Struct2): (builder: Builder) => void;
export declare function loadStruct2(slice: Slice): {
    $$type: "Struct2";
    c: string;
    d: string;
    e: string;
    f: string;
};
export type Test$Data = {
    $$type: 'Test$Data';
    owner: Address;
    seqno: bigint;
    a: bigint;
    b: bigint;
    struct2: Struct2;
    author3: Address | null;
    cost: bigint | null;
    address: Address | null;
    price: bigint | null;
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
    owner: Address;
    seqno: bigint;
    a: bigint;
    b: bigint;
    struct2: {
        $$type: "Struct2";
        c: string;
        d: string;
        e: string;
        f: string;
    };
    author3: Address | null;
    cost: bigint | null;
    address: Address | null;
    price: bigint | null;
};
export declare const Test_getterMapping: {
    [key: string]: string;
};
export declare class Test implements Contract {
    static init(owner: Address, struct2: Struct2): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(owner: Address, struct2: Struct2): Promise<Test>;
    static fromAddress(address: Address): Test;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: SetCost | Deploy): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/asm-functions_AsmFunctionsTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/asm-functions_AsmFunctionsTester.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type AsmFunctionsTester$Data = {
    $$type: 'AsmFunctionsTester$Data';
};
export declare function storeAsmFunctionsTester$Data(src: AsmFunctionsTester$Data): (builder: Builder) => void;
export declare function loadAsmFunctionsTester$Data(slice: Slice): {
    $$type: "AsmFunctionsTester$Data";
};
export type MapIntIntSlice = {
    $$type: 'MapIntIntSlice';
    val: Dictionary<bigint, bigint>;
    rem: Slice;
};
export declare function storeMapIntIntSlice(src: MapIntIntSlice): (builder: Builder) => void;
export declare function loadMapIntIntSlice(slice: Slice): {
    $$type: "MapIntIntSlice";
    val: Dictionary<bigint, bigint>;
    rem: Slice;
};
export type IntSlice = {
    $$type: 'IntSlice';
    val: bigint;
    rem: Slice;
};
export declare function storeIntSlice(src: IntSlice): (builder: Builder) => void;
export declare function loadIntSlice(slice: Slice): {
    $$type: "IntSlice";
    val: bigint;
    rem: Slice;
};
export type SliceInt = {
    $$type: 'SliceInt';
    rem: Slice;
    val: bigint;
};
export declare function storeSliceInt(src: SliceInt): (builder: Builder) => void;
export declare function loadSliceInt(slice: Slice): {
    $$type: "SliceInt";
    rem: Slice;
    val: bigint;
};
export type Two = {
    $$type: 'Two';
    a: bigint;
    b: bigint;
};
export declare function storeTwo(src: Two): (builder: Builder) => void;
export declare function loadTwo(slice: Slice): {
    $$type: "Two";
    a: bigint;
    b: bigint;
};
export type TwoInTwo = {
    $$type: 'TwoInTwo';
    a: Two;
    b: Two;
};
export declare function storeTwoInTwo(src: TwoInTwo): (builder: Builder) => void;
export declare function loadTwoInTwo(slice: Slice): {
    $$type: "TwoInTwo";
    a: {
        $$type: "Two";
        a: bigint;
        b: bigint;
    };
    b: {
        $$type: "Two";
        a: bigint;
        b: bigint;
    };
};
export declare const AsmFunctionsTester_getterMapping: {
    [key: string]: string;
};
export declare class AsmFunctionsTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<AsmFunctionsTester>;
    static fromAddress(address: Address): AsmFunctionsTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestAsmStoreDict(provider: ContractProvider): Promise<boolean>;
    getTestAsmLoadCoins(provider: ContractProvider): Promise<boolean>;
    getTestAsmLoadCoinsMut(provider: ContractProvider): Promise<boolean>;
    getTestAsmLoadCoinsMutRuntime(provider: ContractProvider, c: Cell): Promise<bigint>;
    getTestAsmLoadInt(provider: ContractProvider): Promise<boolean>;
    getTestAsmDebugStr(provider: ContractProvider): Promise<boolean>;
    getTestAsmCreateUseWord(provider: ContractProvider): Promise<boolean>;
    getTestAsmSecondToLast(provider: ContractProvider): Promise<boolean>;
    getTestAsmSecondToLastRuntime(provider: ContractProvider, s1: Two, s2: Two): Promise<bigint>;
    getTestAsmFirst(provider: ContractProvider): Promise<boolean>;
    getTestAsmFirstRuntime(provider: ContractProvider, s1: TwoInTwo, s2: TwoInTwo, s3: TwoInTwo): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/block-statements_Test.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/block-statements_Test.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export declare const Test_getterMapping: {
    [key: string]: string;
};
export declare class Test implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Test>;
    static fromAddress(address: Address): Test;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "test" | Deploy): Promise<void>;
    getA(provider: ContractProvider): Promise<bigint>;
    getB(provider: ContractProvider): Promise<bigint>;
    getC(provider: ContractProvider): Promise<bigint>;
    getD(provider: ContractProvider): Promise<bigint>;
    getE(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/bounced-routing_SampleContract.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/bounced-routing_SampleContract.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type EntryFirst = {
    $$type: 'EntryFirst';
    amountToAdd: bigint;
    toAddress: Address;
};
export declare function storeEntryFirst(src: EntryFirst): (builder: Builder) => void;
export declare function loadEntryFirst(slice: Slice): {
    $$type: "EntryFirst";
    amountToAdd: bigint;
    toAddress: Address;
};
export type EntrySecond = {
    $$type: 'EntrySecond';
    amountToAdd: bigint;
    toAddress: Address;
};
export declare function storeEntrySecond(src: EntrySecond): (builder: Builder) => void;
export declare function loadEntrySecond(slice: Slice): {
    $$type: "EntrySecond";
    amountToAdd: bigint;
    toAddress: Address;
};
export type First = {
    $$type: 'First';
    amount: bigint;
    myCoins: bigint;
    myBool3: boolean;
    anAddress: Address;
};
export declare function storeFirst(src: First): (builder: Builder) => void;
export declare function loadFirst(slice: Slice): {
    $$type: "First";
    amount: bigint;
    myCoins: bigint;
    myBool3: boolean;
    anAddress: Address;
};
export type Second = {
    $$type: 'Second';
    amount_bigger: bigint;
    myBool: boolean;
    thisDoesNotFit: bigint;
    myAddress: Address;
    myBool2: boolean;
    myStruct: MyStruct;
    myStruct2: MyStruct;
};
export declare function storeSecond(src: Second): (builder: Builder) => void;
export declare function loadSecond(slice: Slice): {
    $$type: "Second";
    amount_bigger: bigint;
    myBool: boolean;
    thisDoesNotFit: bigint;
    myAddress: Address;
    myBool2: boolean;
    myStruct: {
        $$type: "MyStruct";
        amount: bigint;
    };
    myStruct2: {
        $$type: "MyStruct";
        amount: bigint;
    };
};
export type Large = {
    $$type: 'Large';
    address: Address;
    value: bigint;
};
export declare function storeLarge(src: Large): (builder: Builder) => void;
export declare function loadLarge(slice: Slice): {
    $$type: "Large";
    address: Address;
    value: bigint;
};
export type SmallBounce = {
    $$type: 'SmallBounce';
    amount: bigint;
    myBool3: boolean;
};
export declare function storeSmallBounce(src: SmallBounce): (builder: Builder) => void;
export declare function loadSmallBounce(slice: Slice): {
    $$type: "SmallBounce";
    amount: bigint;
    myBool3: boolean;
};
export type MyStruct = {
    $$type: 'MyStruct';
    amount: bigint;
};
export declare function storeMyStruct(src: MyStruct): (builder: Builder) => void;
export declare function loadMyStruct(slice: Slice): {
    $$type: "MyStruct";
    amount: bigint;
};
export type SampleContract$Data = {
    $$type: 'SampleContract$Data';
    a: bigint;
};
export declare function storeSampleContract$Data(src: SampleContract$Data): (builder: Builder) => void;
export declare function loadSampleContract$Data(slice: Slice): {
    $$type: "SampleContract$Data";
    a: bigint;
};
export type SampleContract2$Data = {
    $$type: 'SampleContract2$Data';
};
export declare function storeSampleContract2$Data(src: SampleContract2$Data): (builder: Builder) => void;
export declare function loadSampleContract2$Data(slice: Slice): {
    $$type: "SampleContract2$Data";
};
export declare const SampleContract_getterMapping: {
    [key: string]: string;
};
export declare class SampleContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<SampleContract>;
    static fromAddress(address: Address): SampleContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | EntryFirst | EntrySecond | First | Second | "Increment"): Promise<void>;
    getAmount(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/bounced-routing_SampleContract2.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/bounced-routing_SampleContract2.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type EntryFirst = {
    $$type: 'EntryFirst';
    amountToAdd: bigint;
    toAddress: Address;
};
export declare function storeEntryFirst(src: EntryFirst): (builder: Builder) => void;
export declare function loadEntryFirst(slice: Slice): {
    $$type: "EntryFirst";
    amountToAdd: bigint;
    toAddress: Address;
};
export type EntrySecond = {
    $$type: 'EntrySecond';
    amountToAdd: bigint;
    toAddress: Address;
};
export declare function storeEntrySecond(src: EntrySecond): (builder: Builder) => void;
export declare function loadEntrySecond(slice: Slice): {
    $$type: "EntrySecond";
    amountToAdd: bigint;
    toAddress: Address;
};
export type First = {
    $$type: 'First';
    amount: bigint;
    myCoins: bigint;
    myBool3: boolean;
    anAddress: Address;
};
export declare function storeFirst(src: First): (builder: Builder) => void;
export declare function loadFirst(slice: Slice): {
    $$type: "First";
    amount: bigint;
    myCoins: bigint;
    myBool3: boolean;
    anAddress: Address;
};
export type Second = {
    $$type: 'Second';
    amount_bigger: bigint;
    myBool: boolean;
    thisDoesNotFit: bigint;
    myAddress: Address;
    myBool2: boolean;
    myStruct: MyStruct;
    myStruct2: MyStruct;
};
export declare function storeSecond(src: Second): (builder: Builder) => void;
export declare function loadSecond(slice: Slice): {
    $$type: "Second";
    amount_bigger: bigint;
    myBool: boolean;
    thisDoesNotFit: bigint;
    myAddress: Address;
    myBool2: boolean;
    myStruct: {
        $$type: "MyStruct";
        amount: bigint;
    };
    myStruct2: {
        $$type: "MyStruct";
        amount: bigint;
    };
};
export type Large = {
    $$type: 'Large';
    address: Address;
    value: bigint;
};
export declare function storeLarge(src: Large): (builder: Builder) => void;
export declare function loadLarge(slice: Slice): {
    $$type: "Large";
    address: Address;
    value: bigint;
};
export type SmallBounce = {
    $$type: 'SmallBounce';
    amount: bigint;
    myBool3: boolean;
};
export declare function storeSmallBounce(src: SmallBounce): (builder: Builder) => void;
export declare function loadSmallBounce(slice: Slice): {
    $$type: "SmallBounce";
    amount: bigint;
    myBool3: boolean;
};
export type MyStruct = {
    $$type: 'MyStruct';
    amount: bigint;
};
export declare function storeMyStruct(src: MyStruct): (builder: Builder) => void;
export declare function loadMyStruct(slice: Slice): {
    $$type: "MyStruct";
    amount: bigint;
};
export type SampleContract$Data = {
    $$type: 'SampleContract$Data';
    a: bigint;
};
export declare function storeSampleContract$Data(src: SampleContract$Data): (builder: Builder) => void;
export declare function loadSampleContract$Data(slice: Slice): {
    $$type: "SampleContract$Data";
    a: bigint;
};
export type SampleContract2$Data = {
    $$type: 'SampleContract2$Data';
};
export declare function storeSampleContract2$Data(src: SampleContract2$Data): (builder: Builder) => void;
export declare function loadSampleContract2$Data(slice: Slice): {
    $$type: "SampleContract2$Data";
};
export declare const SampleContract2_getterMapping: {
    [key: string]: string;
};
export declare class SampleContract2 implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<SampleContract2>;
    static fromAddress(address: Address): SampleContract2;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | First | Second): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/constants_ConstantTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/constants_ConstantTester.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type S = {
    $$type: 'S';
    a: boolean;
    b: bigint;
};
export declare function storeS(src: S): (builder: Builder) => void;
export declare function loadS(slice: Slice): {
    $$type: "S";
    a: boolean;
    b: bigint;
};
export type T = {
    $$type: 'T';
    a: bigint;
    s: S;
};
export declare function storeT(src: T): (builder: Builder) => void;
export declare function loadT(slice: Slice): {
    $$type: "T";
    a: bigint;
    s: {
        $$type: "S";
        a: boolean;
        b: bigint;
    };
};
export type ConstantTester$Data = {
    $$type: 'ConstantTester$Data';
};
export declare function storeConstantTester$Data(src: ConstantTester$Data): (builder: Builder) => void;
export declare function loadConstantTester$Data(slice: Slice): {
    $$type: "ConstantTester$Data";
};
export declare const ConstantTester_getterMapping: {
    [key: string]: string;
};
export declare class ConstantTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<ConstantTester>;
    static fromAddress(address: Address): ConstantTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getSomething1(provider: ContractProvider): Promise<bigint>;
    getSomething2(provider: ContractProvider): Promise<bigint | null>;
    getSomething3(provider: ContractProvider): Promise<bigint>;
    getSomething4(provider: ContractProvider): Promise<bigint>;
    getSomething5(provider: ContractProvider): Promise<string>;
    getSomething6(provider: ContractProvider): Promise<bigint>;
    getSomething7(provider: ContractProvider): Promise<bigint>;
    getSomething8(provider: ContractProvider): Promise<bigint>;
    getSomething9(provider: ContractProvider): Promise<Address>;
    getSomething10(provider: ContractProvider): Promise<Address>;
    getSomething11(provider: ContractProvider): Promise<bigint>;
    getSomething12(provider: ContractProvider): Promise<bigint>;
    getSomething13(provider: ContractProvider): Promise<bigint>;
    getSomething14(provider: ContractProvider): Promise<bigint>;
    getSomething15(provider: ContractProvider): Promise<bigint>;
    getSomething16(provider: ContractProvider): Promise<bigint>;
    getSomething17(provider: ContractProvider): Promise<bigint>;
    getSomething18(provider: ContractProvider): Promise<bigint>;
    getSomething19(provider: ContractProvider): Promise<bigint>;
    getSomething20(provider: ContractProvider): Promise<bigint>;
    getSomething21(provider: ContractProvider): Promise<bigint>;
    getSomething22(provider: ContractProvider): Promise<bigint>;
    getSomething23(provider: ContractProvider): Promise<bigint>;
    getSomething24(provider: ContractProvider): Promise<bigint>;
    getSomething25(provider: ContractProvider): Promise<bigint>;
    getSomething26(provider: ContractProvider): Promise<bigint>;
    getSomething27(provider: ContractProvider): Promise<bigint>;
    getSomething28(provider: ContractProvider): Promise<bigint>;
    getSomething29(provider: ContractProvider): Promise<bigint | null>;
    getSomething30(provider: ContractProvider): Promise<bigint | null>;
    getSomething31(provider: ContractProvider): Promise<bigint>;
    getSomething32(provider: ContractProvider): Promise<bigint>;
    getSomething33(provider: ContractProvider): Promise<Dictionary<bigint, bigint>>;
    getSomething34(provider: ContractProvider): Promise<Dictionary<bigint, bigint>>;
    getSomething35(provider: ContractProvider): Promise<{
        $$type: "S";
        a: boolean;
        b: bigint;
    }>;
    getSomething36(provider: ContractProvider): Promise<{
        $$type: "S";
        a: boolean;
        b: bigint;
    }>;
    getSomething37(provider: ContractProvider): Promise<{
        $$type: "T";
        a: bigint;
        s: {
            $$type: "S";
            a: boolean;
            b: bigint;
        };
    }>;
    getSomething38(provider: ContractProvider): Promise<bigint>;
    getSomething39(provider: ContractProvider): Promise<boolean>;
    getSomething40(provider: ContractProvider): Promise<boolean>;
    getSomething41(provider: ContractProvider): Promise<Address>;
    getSomething42(provider: ContractProvider): Promise<Address>;
    getSomething43(provider: ContractProvider): Promise<Address>;
    getSomething44(provider: ContractProvider): Promise<Address>;
    getGlobalConst1(provider: ContractProvider): Promise<bigint>;
    getGlobalConst2(provider: ContractProvider): Promise<bigint>;
    getGlobalConst3(provider: ContractProvider): Promise<bigint>;
    getGlobalConst4(provider: ContractProvider): Promise<bigint>;
    getGlobalConst5(provider: ContractProvider): Promise<bigint>;
    getGlobalConst6(provider: ContractProvider): Promise<bigint>;
    getGlobalConst7(provider: ContractProvider): Promise<bigint>;
    getGlobalConst8(provider: ContractProvider): Promise<bigint>;
    getGlobalConst9(provider: ContractProvider): Promise<bigint>;
    getGlobalConst10(provider: ContractProvider): Promise<bigint>;
    getGlobalConst11(provider: ContractProvider): Promise<bigint>;
    getGlobalConst12(provider: ContractProvider): Promise<bigint>;
    getGlobalConst13(provider: ContractProvider): Promise<bigint>;
    getMinInt1(provider: ContractProvider): Promise<bigint>;
    getMinInt2(provider: ContractProvider): Promise<bigint>;
    getMinInt3(provider: ContractProvider): Promise<bigint>;
    getGlobalConst(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/contract-methods_Test.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/contract-methods_Test.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
    flags: bigint;
    oneMoreVar: bigint;
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
    flags: bigint;
    oneMoreVar: bigint;
};
export declare const Test_getterMapping: {
    [key: string]: string;
};
export declare class Test implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Test>;
    static fromAddress(address: Address): Test;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/debug_Debug.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/debug_Debug.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type Debug$Data = {
    $$type: 'Debug$Data';
};
export declare function storeDebug$Data(src: Debug$Data): (builder: Builder) => void;
export declare function loadDebug$Data(slice: Slice): {
    $$type: "Debug$Data";
};
export declare const Debug_getterMapping: {
    [key: string]: string;
};
export declare class Debug implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Debug>;
    static fromAddress(address: Address): Debug;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "Debug" | Deploy): Promise<void>;
    getDebug(provider: ContractProvider): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/deep_A.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/deep_A.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type A$Data = {
    $$type: 'A$Data';
};
export declare function storeA$Data(src: A$Data): (builder: Builder) => void;
export declare function loadA$Data(slice: Slice): {
    $$type: "A$Data";
};
export type B$Data = {
    $$type: 'B$Data';
    parent: Address;
};
export declare function storeB$Data(src: B$Data): (builder: Builder) => void;
export declare function loadB$Data(slice: Slice): {
    $$type: "B$Data";
    parent: Address;
};
export type C$Data = {
    $$type: 'C$Data';
    parent: Address;
};
export declare function storeC$Data(src: C$Data): (builder: Builder) => void;
export declare function loadC$Data(slice: Slice): {
    $$type: "C$Data";
    parent: Address;
};
export declare const A_getterMapping: {
    [key: string]: string;
};
export declare class A implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<A>;
    static fromAddress(address: Address): A;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "Message"): Promise<void>;
    getGetNext(provider: ContractProvider): Promise<{
        $$type: "StateInit";
        code: Cell;
        data: Cell;
    }>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/deep_B.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/deep_B.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type A$Data = {
    $$type: 'A$Data';
};
export declare function storeA$Data(src: A$Data): (builder: Builder) => void;
export declare function loadA$Data(slice: Slice): {
    $$type: "A$Data";
};
export type B$Data = {
    $$type: 'B$Data';
    parent: Address;
};
export declare function storeB$Data(src: B$Data): (builder: Builder) => void;
export declare function loadB$Data(slice: Slice): {
    $$type: "B$Data";
    parent: Address;
};
export type C$Data = {
    $$type: 'C$Data';
    parent: Address;
};
export declare function storeC$Data(src: C$Data): (builder: Builder) => void;
export declare function loadC$Data(slice: Slice): {
    $$type: "C$Data";
    parent: Address;
};
export declare const B_getterMapping: {
    [key: string]: string;
};
export declare class B implements Contract {
    static init(parent: Address): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(parent: Address): Promise<B>;
    static fromAddress(address: Address): B;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "Message"): Promise<void>;
    getGetNext(provider: ContractProvider): Promise<{
        $$type: "StateInit";
        code: Cell;
        data: Cell;
    }>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/deep_C.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/deep_C.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type A$Data = {
    $$type: 'A$Data';
};
export declare function storeA$Data(src: A$Data): (builder: Builder) => void;
export declare function loadA$Data(slice: Slice): {
    $$type: "A$Data";
};
export type B$Data = {
    $$type: 'B$Data';
    parent: Address;
};
export declare function storeB$Data(src: B$Data): (builder: Builder) => void;
export declare function loadB$Data(slice: Slice): {
    $$type: "B$Data";
    parent: Address;
};
export type C$Data = {
    $$type: 'C$Data';
    parent: Address;
};
export declare function storeC$Data(src: C$Data): (builder: Builder) => void;
export declare function loadC$Data(slice: Slice): {
    $$type: "C$Data";
    parent: Address;
};
export declare const C_getterMapping: {
    [key: string]: string;
};
export declare class C implements Contract {
    static init(parent: Address): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(parent: Address): Promise<C>;
    static fromAddress(address: Address): C;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "Message" | "Message2"): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/dns_DNSTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/dns_DNSTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type DNSResolveResult = {
    $$type: 'DNSResolveResult';
    prefix: bigint;
    record: Cell | null;
};
export declare function storeDNSResolveResult(src: DNSResolveResult): (builder: Builder) => void;
export declare function loadDNSResolveResult(slice: Slice): {
    $$type: "DNSResolveResult";
    prefix: bigint;
    record: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type DNSTester$Data = {
    $$type: 'DNSTester$Data';
    tmpC: Cell;
};
export declare function storeDNSTester$Data(src: DNSTester$Data): (builder: Builder) => void;
export declare function loadDNSTester$Data(slice: Slice): {
    $$type: "DNSTester$Data";
    tmpC: Cell;
};
export declare const DNSTester_getterMapping: {
    [key: string]: string;
};
export declare class DNSTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<DNSTester>;
    static fromAddress(address: Address): DNSTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "test dnsInternalNormalize throws" | Deploy): Promise<void>;
    getStringToInternal(provider: ContractProvider, src: string): Promise<Slice | null>;
    getInternalNormalize(provider: ContractProvider, src: Slice): Promise<Slice>;
    getDnsInternalVerify(provider: ContractProvider, subdomain: Slice): Promise<boolean>;
    getDnsExtractTopDomainLength(provider: ContractProvider, subdomain: Slice): Promise<bigint>;
    getDnsExtractTopDomain(provider: ContractProvider, subdomain: Slice): Promise<Slice>;
    getDnsresolve(provider: ContractProvider, subdomain: Slice, category: bigint): Promise<{
        $$type: "DNSResolveResult";
        prefix: bigint;
        record: Cell | null;
    }>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/external-fallbacks_ExternalFallbacksTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/external-fallbacks_ExternalFallbacksTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Add = {
    $$type: 'Add';
    x: bigint;
};
export declare function storeAdd(src: Add): (builder: Builder) => void;
export declare function loadAdd(slice: Slice): {
    $$type: "Add";
    x: bigint;
};
export type ExternalFallbacksTester$Data = {
    $$type: 'ExternalFallbacksTester$Data';
    a: bigint;
};
export declare function storeExternalFallbacksTester$Data(src: ExternalFallbacksTester$Data): (builder: Builder) => void;
export declare function loadExternalFallbacksTester$Data(slice: Slice): {
    $$type: "ExternalFallbacksTester$Data";
    a: bigint;
};
export declare const ExternalFallbacksTester_getterMapping: {
    [key: string]: string;
};
export declare class ExternalFallbacksTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<ExternalFallbacksTester>;
    static fromAddress(address: Address): ExternalFallbacksTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | Add): Promise<void>;
    sendExternal(provider: ContractProvider, message: null | Add): Promise<void>;
    getGetA(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/getters_Test.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/getters_Test.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type S = {
    $$type: 'S';
    a: bigint;
    b: bigint;
};
export declare function storeS(src: S): (builder: Builder) => void;
export declare function loadS(slice: Slice): {
    $$type: "S";
    a: bigint;
    b: bigint;
};
export type SetIdAndData = {
    $$type: 'SetIdAndData';
    id: bigint;
    data: Cell;
};
export declare function storeSetIdAndData(src: SetIdAndData): (builder: Builder) => void;
export declare function loadSetIdAndData(slice: Slice): {
    $$type: "SetIdAndData";
    id: bigint;
    data: Cell;
};
export type Test$Data = {
    $$type: 'Test$Data';
    id: bigint;
    anotherData: Cell;
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
    id: bigint;
    anotherData: Cell;
};
export declare const Test_getterMapping: {
    [key: string]: string;
};
export declare class Test implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Test>;
    static fromAddress(address: Address): Test;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: SetIdAndData | Deploy): Promise<void>;
    getTestGetter(provider: ContractProvider): Promise<bigint>;
    gettest_getter(provider: ContractProvider): Promise<bigint>;
    getTest_getter(provider: ContractProvider): Promise<bigint>;
    getContractData(provider: ContractProvider): Promise<{
        $$type: "Test$Data";
        id: bigint;
        anotherData: Cell;
    }>;
    getStructAsInput(provider: ContractProvider, s: S): Promise<{
        $$type: "S";
        a: bigint;
        b: bigint;
    }>;
    getMessageAsInput1(provider: ContractProvider, m: SetIdAndData): Promise<bigint>;
    getMessageAsInput2(provider: ContractProvider, m: SetIdAndData): Promise<{
        $$type: "SetIdAndData";
        id: bigint;
        data: Cell;
    }>;
    getContractAsInput(provider: ContractProvider, test: Test$Data): Promise<{
        $$type: "Test$Data";
        id: bigint;
        anotherData: Cell;
    }>;
    getMethodIdExpr(provider: ContractProvider): Promise<boolean>;
    getMethodIdConst(provider: ContractProvider): Promise<bigint>;
    getMethodIdMin(provider: ContractProvider): Promise<boolean>;
    getMethodIdMax(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/implicit-init_MyContract.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/implicit-init_MyContract.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type MyContract$Data = {
    $$type: 'MyContract$Data';
    counter: bigint;
};
export declare function storeMyContract$Data(src: MyContract$Data): (builder: Builder) => void;
export declare function loadMyContract$Data(slice: Slice): {
    $$type: "MyContract$Data";
    counter: bigint;
};
export declare const MyContract_getterMapping: {
    [key: string]: string;
};
export declare class MyContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MyContract>;
    static fromAddress(address: Address): MyContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "increment" | Deploy): Promise<void>;
    getGetCounter(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/init-of-message_Test.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/init-of-message_Test.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type InitData = {
    $$type: 'InitData';
    seller: Address;
    nonce: bigint;
};
export declare function storeInitData(src: InitData): (builder: Builder) => void;
export declare function loadInitData(slice: Slice): {
    $$type: "InitData";
    seller: Address;
    nonce: bigint;
};
export type Test$Data = {
    $$type: 'Test$Data';
    seller: Address;
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
    seller: Address;
};
export declare const Test_getterMapping: {
    [key: string]: string;
};
export declare class Test implements Contract {
    static init(i: InitData): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(i: InitData): Promise<Test>;
    static fromAddress(address: Address): Test;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/init-return_Test.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/init-return_Test.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
    a: bigint;
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
    a: bigint;
};
export declare const Test_getterMapping: {
    [key: string]: string;
};
export declare class Test implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Test>;
    static fromAddress(address: Address): Test;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getA(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/initof-2_TestInit.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/initof-2_TestInit.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type Foo = {
    $$type: 'Foo';
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
};
export type TestNested$Data = {
    $$type: 'TestNested$Data';
};
export declare function storeTestNested$Data(src: TestNested$Data): (builder: Builder) => void;
export declare function loadTestNested$Data(slice: Slice): {
    $$type: "TestNested$Data";
};
export type TestInit$Data = {
    $$type: 'TestInit$Data';
};
export declare function storeTestInit$Data(src: TestInit$Data): (builder: Builder) => void;
export declare function loadTestInit$Data(slice: Slice): {
    $$type: "TestInit$Data";
};
export declare const TestInit_getterMapping: {
    [key: string]: string;
};
export declare class TestInit implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<TestInit>;
    static fromAddress(address: Address): TestInit;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Foo | Deploy): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/initof-2_TestNested.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/initof-2_TestNested.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type Foo = {
    $$type: 'Foo';
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
};
export type TestNested$Data = {
    $$type: 'TestNested$Data';
};
export declare function storeTestNested$Data(src: TestNested$Data): (builder: Builder) => void;
export declare function loadTestNested$Data(slice: Slice): {
    $$type: "TestNested$Data";
};
export type TestInit$Data = {
    $$type: 'TestInit$Data';
};
export declare function storeTestInit$Data(src: TestInit$Data): (builder: Builder) => void;
export declare function loadTestInit$Data(slice: Slice): {
    $$type: "TestInit$Data";
};
export declare const TestNested_getterMapping: {
    [key: string]: string;
};
export declare class TestNested implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<TestNested>;
    static fromAddress(address: Address): TestNested;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Deploy): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/initof-3_A.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/initof-3_A.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type B$Data = {
    $$type: 'B$Data';
    owner: Address;
};
export declare function storeB$Data(src: B$Data): (builder: Builder) => void;
export declare function loadB$Data(slice: Slice): {
    $$type: "B$Data";
    owner: Address;
};
export type A$Data = {
    $$type: 'A$Data';
};
export declare function storeA$Data(src: A$Data): (builder: Builder) => void;
export declare function loadA$Data(slice: Slice): {
    $$type: "A$Data";
};
export declare const A_getterMapping: {
    [key: string]: string;
};
export declare class A implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<A>;
    static fromAddress(address: Address): A;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "aa"): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/initof-3_B.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/initof-3_B.d.ts" {
                import { Cell, Slice, Address, Builder, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type B$Data = {
    $$type: 'B$Data';
    owner: Address;
};
export declare function storeB$Data(src: B$Data): (builder: Builder) => void;
export declare function loadB$Data(slice: Slice): {
    $$type: "B$Data";
    owner: Address;
};
export type A$Data = {
    $$type: 'A$Data';
};
export declare function storeA$Data(src: A$Data): (builder: Builder) => void;
export declare function loadA$Data(slice: Slice): {
    $$type: "A$Data";
};
export declare const B_getterMapping: {
    [key: string]: string;
};
export declare class B implements Contract {
    static init(addr: Address): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(addr: Address): Promise<B>;
    static fromAddress(address: Address): B;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/initof_Child.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/initof_Child.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Self$Data = {
    $$type: 'Self$Data';
};
export declare function storeSelf$Data(src: Self$Data): (builder: Builder) => void;
export declare function loadSelf$Data(slice: Slice): {
    $$type: "Self$Data";
};
export type ChildAddress = {
    $$type: 'ChildAddress';
    address: Address;
};
export declare function storeChildAddress(src: ChildAddress): (builder: Builder) => void;
export declare function loadChildAddress(slice: Slice): {
    $$type: "ChildAddress";
    address: Address;
};
export type Child$Data = {
    $$type: 'Child$Data';
    owner: Address;
};
export declare function storeChild$Data(src: Child$Data): (builder: Builder) => void;
export declare function loadChild$Data(slice: Slice): {
    $$type: "Child$Data";
    owner: Address;
};
export type Parent$Data = {
    $$type: 'Parent$Data';
    childMyAddress: Address;
};
export declare function storeParent$Data(src: Parent$Data): (builder: Builder) => void;
export declare function loadParent$Data(slice: Slice): {
    $$type: "Parent$Data";
    childMyAddress: Address;
};
export declare const Child_getterMapping: {
    [key: string]: string;
};
export declare class Child implements Contract {
    static init(owner: Address): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(owner: Address): Promise<Child>;
    static fromAddress(address: Address): Child;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/initof_Parent.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/initof_Parent.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Self$Data = {
    $$type: 'Self$Data';
};
export declare function storeSelf$Data(src: Self$Data): (builder: Builder) => void;
export declare function loadSelf$Data(slice: Slice): {
    $$type: "Self$Data";
};
export type ChildAddress = {
    $$type: 'ChildAddress';
    address: Address;
};
export declare function storeChildAddress(src: ChildAddress): (builder: Builder) => void;
export declare function loadChildAddress(slice: Slice): {
    $$type: "ChildAddress";
    address: Address;
};
export type Child$Data = {
    $$type: 'Child$Data';
    owner: Address;
};
export declare function storeChild$Data(src: Child$Data): (builder: Builder) => void;
export declare function loadChild$Data(slice: Slice): {
    $$type: "Child$Data";
    owner: Address;
};
export type Parent$Data = {
    $$type: 'Parent$Data';
    childMyAddress: Address;
};
export declare function storeParent$Data(src: Parent$Data): (builder: Builder) => void;
export declare function loadParent$Data(slice: Slice): {
    $$type: "Parent$Data";
    childMyAddress: Address;
};
export declare const Parent_getterMapping: {
    [key: string]: string;
};
export declare class Parent implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Parent>;
    static fromAddress(address: Address): Parent;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | ChildAddress): Promise<void>;
    getTestInitOfAddressChild(provider: ContractProvider): Promise<Address>;
    getTestMyAddressChild(provider: ContractProvider): Promise<Address>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/initof_Self.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/initof_Self.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Self$Data = {
    $$type: 'Self$Data';
};
export declare function storeSelf$Data(src: Self$Data): (builder: Builder) => void;
export declare function loadSelf$Data(slice: Slice): {
    $$type: "Self$Data";
};
export type ChildAddress = {
    $$type: 'ChildAddress';
    address: Address;
};
export declare function storeChildAddress(src: ChildAddress): (builder: Builder) => void;
export declare function loadChildAddress(slice: Slice): {
    $$type: "ChildAddress";
    address: Address;
};
export type Child$Data = {
    $$type: 'Child$Data';
    owner: Address;
};
export declare function storeChild$Data(src: Child$Data): (builder: Builder) => void;
export declare function loadChild$Data(slice: Slice): {
    $$type: "Child$Data";
    owner: Address;
};
export type Parent$Data = {
    $$type: 'Parent$Data';
    childMyAddress: Address;
};
export declare function storeParent$Data(src: Parent$Data): (builder: Builder) => void;
export declare function loadParent$Data(slice: Slice): {
    $$type: "Parent$Data";
    childMyAddress: Address;
};
export declare const Self_getterMapping: {
    [key: string]: string;
};
export declare class Self implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Self>;
    static fromAddress(address: Address): Self;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestInitOfAddress(provider: ContractProvider): Promise<Address>;
    getTestMyAddress(provider: ContractProvider): Promise<Address>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/integer-literals_IntegerLiteralsTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/integer-literals_IntegerLiteralsTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type IntegerLiteralsTester$Data = {
    $$type: 'IntegerLiteralsTester$Data';
};
export declare function storeIntegerLiteralsTester$Data(src: IntegerLiteralsTester$Data): (builder: Builder) => void;
export declare function loadIntegerLiteralsTester$Data(slice: Slice): {
    $$type: "IntegerLiteralsTester$Data";
};
export declare const IntegerLiteralsTester_getterMapping: {
    [key: string]: string;
};
export declare class IntegerLiteralsTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<IntegerLiteralsTester>;
    static fromAddress(address: Address): IntegerLiteralsTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getDecLiteral1(provider: ContractProvider): Promise<bigint>;
    getDecLiteral2(provider: ContractProvider): Promise<bigint>;
    getDecLiteral3(provider: ContractProvider): Promise<bigint>;
    getHexLiteral1(provider: ContractProvider): Promise<bigint>;
    getHexLiteral2(provider: ContractProvider): Promise<bigint>;
    getHexLiteral3(provider: ContractProvider): Promise<bigint>;
    getBinLiteral1(provider: ContractProvider): Promise<bigint>;
    getBinLiteral2(provider: ContractProvider): Promise<bigint>;
    getBinLiteral3(provider: ContractProvider): Promise<bigint>;
    getOctLiteral1(provider: ContractProvider): Promise<bigint>;
    getOctLiteral2(provider: ContractProvider): Promise<bigint>;
    getOctLiteral3(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/intrinsics_IntrinsicsTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/intrinsics_IntrinsicsTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type IntrinsicsTester$Data = {
    $$type: 'IntrinsicsTester$Data';
    a: bigint;
    b: string;
    c: Address;
    d: Cell;
    e: bigint;
    f: bigint;
    g: Slice;
    h: Slice;
    i: bigint;
    j: bigint;
    k: bigint;
    l: bigint;
    m: Slice;
    n: Slice;
    o: Slice;
    p: Slice;
    q: Slice;
    r: Slice;
    s: Slice;
    t: Slice;
    u: Slice;
    w: Slice;
    v: Slice;
};
export declare function storeIntrinsicsTester$Data(src: IntrinsicsTester$Data): (builder: Builder) => void;
export declare function loadIntrinsicsTester$Data(slice: Slice): {
    $$type: "IntrinsicsTester$Data";
    a: bigint;
    b: string;
    c: Address;
    d: Cell;
    e: bigint;
    f: bigint;
    g: Slice;
    h: Slice;
    i: bigint;
    j: bigint;
    k: bigint;
    l: bigint;
    m: Slice;
    n: Slice;
    o: Slice;
    p: Slice;
    q: Slice;
    r: Slice;
    s: Slice;
    t: Slice;
    u: Slice;
    w: Slice;
    v: Slice;
};
export declare const IntrinsicsTester_getterMapping: {
    [key: string]: string;
};
export declare class IntrinsicsTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<IntrinsicsTester>;
    static fromAddress(address: Address): IntrinsicsTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "Deploy" | "emit_1"): Promise<void>;
    getGetTons(provider: ContractProvider): Promise<bigint>;
    getGetTons2(provider: ContractProvider): Promise<bigint>;
    getGetString(provider: ContractProvider): Promise<string>;
    getGetString2(provider: ContractProvider): Promise<string>;
    getGetAddress(provider: ContractProvider): Promise<Address>;
    getGetAddress2(provider: ContractProvider): Promise<Address>;
    getGetCell(provider: ContractProvider): Promise<Cell>;
    getGetCell2(provider: ContractProvider): Promise<Cell>;
    getGetPow(provider: ContractProvider): Promise<bigint>;
    getGetPow2(provider: ContractProvider): Promise<bigint>;
    getGetComment(provider: ContractProvider): Promise<Cell>;
    getGetHash(provider: ContractProvider): Promise<bigint>;
    getGetHash2(provider: ContractProvider): Promise<bigint>;
    getGetHash3(provider: ContractProvider, src: Slice): Promise<bigint>;
    getGetHash4(provider: ContractProvider, src: string): Promise<bigint>;
    getGetHashLongComptime(provider: ContractProvider): Promise<bigint>;
    getGetHashLongRuntime(provider: ContractProvider, src: string): Promise<bigint>;
    getGetSlice(provider: ContractProvider): Promise<Slice>;
    getGetSlice2(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice2(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice3(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice4(provider: ContractProvider): Promise<Slice>;
    getGetAscii(provider: ContractProvider): Promise<bigint>;
    getGetAscii2(provider: ContractProvider): Promise<bigint>;
    getGetAscii3(provider: ContractProvider): Promise<bigint>;
    getGetAscii4(provider: ContractProvider): Promise<bigint>;
    getGetCrc32(provider: ContractProvider): Promise<bigint>;
    getGetCrc32_2(provider: ContractProvider): Promise<bigint>;
    getGetCrc32_3(provider: ContractProvider): Promise<bigint>;
    getGetCrc32_4(provider: ContractProvider): Promise<bigint>;
    getGetRawSlice5(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice6(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice7(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice8(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice9(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice10(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice11(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice12(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice13(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice14(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice15(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice16(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice17(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice18(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice19(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice20(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice21(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice22(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice23(provider: ContractProvider): Promise<Slice>;
    getGetRawSlice24(provider: ContractProvider): Promise<Slice>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/local-type-inference_LocalTypeInferenceTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/local-type-inference_LocalTypeInferenceTester.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type MyStruct = {
    $$type: 'MyStruct';
    x: bigint;
    y: bigint;
};
export declare function storeMyStruct(src: MyStruct): (builder: Builder) => void;
export declare function loadMyStruct(slice: Slice): {
    $$type: "MyStruct";
    x: bigint;
    y: bigint;
};
export type LocalTypeInferenceTester$Data = {
    $$type: 'LocalTypeInferenceTester$Data';
};
export declare function storeLocalTypeInferenceTester$Data(src: LocalTypeInferenceTester$Data): (builder: Builder) => void;
export declare function loadLocalTypeInferenceTester$Data(slice: Slice): {
    $$type: "LocalTypeInferenceTester$Data";
};
export declare const LocalTypeInferenceTester_getterMapping: {
    [key: string]: string;
};
export declare class LocalTypeInferenceTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<LocalTypeInferenceTester>;
    static fromAddress(address: Address): LocalTypeInferenceTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Deploy): Promise<void>;
    getTest1(provider: ContractProvider): Promise<bigint>;
    getTest2(provider: ContractProvider): Promise<bigint>;
    getTest3(provider: ContractProvider): Promise<Address>;
    getTest4(provider: ContractProvider): Promise<Address>;
    getTest5(provider: ContractProvider): Promise<boolean>;
    getTest6(provider: ContractProvider): Promise<Slice>;
    getTest7(provider: ContractProvider): Promise<Cell>;
    getTest8(provider: ContractProvider): Promise<Builder>;
    getTest9(provider: ContractProvider): Promise<string>;
    getTest10(provider: ContractProvider): Promise<string>;
    getTest11(provider: ContractProvider): Promise<{
        $$type: "StateInit";
        code: Cell;
        data: Cell;
    }>;
    getTest12(provider: ContractProvider): Promise<Dictionary<bigint, bigint>>;
    getTest13(provider: ContractProvider): Promise<Dictionary<bigint, number>>;
    getTest14(provider: ContractProvider): Promise<{
        $$type: "MyStruct";
        x: bigint;
        y: bigint;
    }>;
    getTest15(provider: ContractProvider): Promise<{
        $$type: "MyStruct";
        x: bigint;
        y: bigint;
    }>;
    getTest16(provider: ContractProvider): Promise<bigint | null>;
    getTest17(provider: ContractProvider): Promise<bigint | null>;
    getTest18(provider: ContractProvider): Promise<bigint | null>;
    getTest19(provider: ContractProvider): Promise<bigint | null>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/map-comparison_MapComparisonTestContract.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/map-comparison_MapComparisonTestContract.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Compare = {
    $$type: 'Compare';
    m1: Dictionary<number, boolean>;
    m2: Dictionary<number, boolean>;
};
export declare function storeCompare(src: Compare): (builder: Builder) => void;
export declare function loadCompare(slice: Slice): {
    $$type: "Compare";
    m1: Dictionary<number, boolean>;
    m2: Dictionary<number, boolean>;
};
export type CompareDeep = {
    $$type: 'CompareDeep';
    m1: Dictionary<number, boolean>;
    m2: Dictionary<number, boolean>;
};
export declare function storeCompareDeep(src: CompareDeep): (builder: Builder) => void;
export declare function loadCompareDeep(slice: Slice): {
    $$type: "CompareDeep";
    m1: Dictionary<number, boolean>;
    m2: Dictionary<number, boolean>;
};
export type MapComparisonTestContract$Data = {
    $$type: 'MapComparisonTestContract$Data';
};
export declare function storeMapComparisonTestContract$Data(src: MapComparisonTestContract$Data): (builder: Builder) => void;
export declare function loadMapComparisonTestContract$Data(slice: Slice): {
    $$type: "MapComparisonTestContract$Data";
};
export declare const MapComparisonTestContract_getterMapping: {
    [key: string]: string;
};
export declare class MapComparisonTestContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapComparisonTestContract>;
    static fromAddress(address: Address): MapComparisonTestContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | Compare | CompareDeep): Promise<void>;
    getCompareIntInt(provider: ContractProvider, m1: Dictionary<bigint, bigint>, m2: Dictionary<bigint, bigint>): Promise<boolean>;
    getCompareIntCell(provider: ContractProvider, m1: Dictionary<bigint, Cell>, m2: Dictionary<bigint, Cell>): Promise<boolean>;
    getCompareIntAddress(provider: ContractProvider, m1: Dictionary<bigint, Address>, m2: Dictionary<bigint, Address>): Promise<boolean>;
    getCompareAddressInt(provider: ContractProvider, m1: Dictionary<Address, bigint>, m2: Dictionary<Address, bigint>): Promise<boolean>;
    getCompareAddressCell(provider: ContractProvider, m1: Dictionary<Address, Cell>, m2: Dictionary<Address, Cell>): Promise<boolean>;
    getCompareAddressAddress(provider: ContractProvider, m1: Dictionary<Address, Address>, m2: Dictionary<Address, Address>): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/map-traverse_MapTraverseTestContract.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/map-traverse_MapTraverseTestContract.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MyStruct = {
    $$type: 'MyStruct';
    a: bigint;
    b: boolean;
};
export declare function storeMyStruct(src: MyStruct): (builder: Builder) => void;
export declare function loadMyStruct(slice: Slice): {
    $$type: "MyStruct";
    a: bigint;
    b: boolean;
};
export type MyStructWithMap = {
    $$type: 'MyStructWithMap';
    m: Dictionary<bigint, bigint>;
};
export declare function storeMyStructWithMap(src: MyStructWithMap): (builder: Builder) => void;
export declare function loadMyStructWithMap(slice: Slice): {
    $$type: "MyStructWithMap";
    m: Dictionary<bigint, bigint>;
};
export type MapTraverseTestContract$Data = {
    $$type: 'MapTraverseTestContract$Data';
    m: Dictionary<bigint, bigint>;
    s: MyStructWithMap;
};
export declare function storeMapTraverseTestContract$Data(src: MapTraverseTestContract$Data): (builder: Builder) => void;
export declare function loadMapTraverseTestContract$Data(slice: Slice): {
    $$type: "MapTraverseTestContract$Data";
    m: Dictionary<bigint, bigint>;
    s: {
        $$type: "MyStructWithMap";
        m: Dictionary<bigint, bigint>;
    };
};
export declare const MapTraverseTestContract_getterMapping: {
    [key: string]: string;
};
export declare class MapTraverseTestContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapTraverseTestContract>;
    static fromAddress(address: Address): MapTraverseTestContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestIntInt(provider: ContractProvider): Promise<bigint>;
    getTestIntCoins(provider: ContractProvider): Promise<bigint>;
    getTestIntVarint16(provider: ContractProvider): Promise<bigint>;
    getTestIntBool(provider: ContractProvider): Promise<bigint>;
    getTestIntCell(provider: ContractProvider): Promise<bigint>;
    getTestIntAddress(provider: ContractProvider): Promise<bigint>;
    getTestIntStruct(provider: ContractProvider): Promise<bigint>;
    getTestAddressInt(provider: ContractProvider): Promise<bigint>;
    getTestAddressCoins(provider: ContractProvider): Promise<bigint>;
    getTestAddressVarint16(provider: ContractProvider): Promise<bigint>;
    getTestAddressBool(provider: ContractProvider): Promise<bigint>;
    getTestAddressCell(provider: ContractProvider): Promise<bigint>;
    getTestAddressAddress(provider: ContractProvider): Promise<bigint>;
    getTestAddressStruct(provider: ContractProvider): Promise<bigint>;
    getTestEmptyMap(provider: ContractProvider): Promise<bigint>;
    getTestNull(provider: ContractProvider): Promise<bigint>;
    getTestMapModificationDuringTraversal1(provider: ContractProvider): Promise<bigint>;
    getTestMapModificationDuringTraversal2(provider: ContractProvider): Promise<void>;
    getTestMapSize(provider: ContractProvider): Promise<bigint>;
    getTestMapAsField(provider: ContractProvider): Promise<bigint>;
    getTestMapAsStructField(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/maps1_MapTestContract.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/maps1_MapTestContract.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    int: bigint;
    bool: boolean;
    address: Address;
    a: bigint;
    b: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    int: bigint;
    bool: boolean;
    address: Address;
    a: bigint;
    b: bigint;
};
export type GetAllMapsResult = {
    $$type: 'GetAllMapsResult';
    int_varint16: bigint | null;
    int_varint32: bigint | null;
    int_varuint16: bigint | null;
    int_varuint32: bigint | null;
    int_bool: boolean | null;
    int_cell: Cell | null;
    int_address: Address | null;
    int_struct: SomeStruct | null;
    int8_varint16: bigint | null;
    int8_varint32: bigint | null;
    int8_varuint16: bigint | null;
    int8_varuint32: bigint | null;
    int8_bool: boolean | null;
    int8_cell: Cell | null;
    int8_address: Address | null;
    int8_struct: SomeStruct | null;
    int42_varint16: bigint | null;
    int42_varint32: bigint | null;
    int42_varuint16: bigint | null;
    int42_varuint32: bigint | null;
    int42_bool: boolean | null;
    int42_cell: Cell | null;
    int42_address: Address | null;
    int42_struct: SomeStruct | null;
    int256_varint16: bigint | null;
    int256_varint32: bigint | null;
    int256_varuint16: bigint | null;
    int256_varuint32: bigint | null;
    int256_bool: boolean | null;
    int256_cell: Cell | null;
    int256_address: Address | null;
    int256_struct: SomeStruct | null;
    uint8_varint16: bigint | null;
    uint8_varint32: bigint | null;
    uint8_varuint16: bigint | null;
    uint8_varuint32: bigint | null;
    uint8_bool: boolean | null;
    uint8_cell: Cell | null;
    uint8_address: Address | null;
    uint8_struct: SomeStruct | null;
    uint42_varint16: bigint | null;
    uint42_varint32: bigint | null;
    uint42_varuint16: bigint | null;
    uint42_varuint32: bigint | null;
    uint42_bool: boolean | null;
    uint42_cell: Cell | null;
    uint42_address: Address | null;
    uint42_struct: SomeStruct | null;
    uint256_varint16: bigint | null;
    uint256_varint32: bigint | null;
    uint256_varuint16: bigint | null;
    uint256_varuint32: bigint | null;
    uint256_bool: boolean | null;
    uint256_cell: Cell | null;
    uint256_address: Address | null;
    uint256_struct: SomeStruct | null;
    address_varint16: bigint | null;
    address_varint32: bigint | null;
    address_varuint16: bigint | null;
    address_varuint32: bigint | null;
    address_bool: boolean | null;
    address_cell: Cell | null;
    address_address: Address | null;
    address_struct: SomeStruct | null;
};
export declare function storeGetAllMapsResult(src: GetAllMapsResult): (builder: Builder) => void;
export declare function loadGetAllMapsResult(slice: Slice): {
    $$type: "GetAllMapsResult";
    int_varint16: bigint | null;
    int_varint32: bigint | null;
    int_varuint16: bigint | null;
    int_varuint32: bigint | null;
    int_bool: boolean | null;
    int_cell: Cell | null;
    int_address: Address | null;
    int_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    int8_varint16: bigint | null;
    int8_varint32: bigint | null;
    int8_varuint16: bigint | null;
    int8_varuint32: bigint | null;
    int8_bool: boolean | null;
    int8_cell: Cell | null;
    int8_address: Address | null;
    int8_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    int42_varint16: bigint | null;
    int42_varint32: bigint | null;
    int42_varuint16: bigint | null;
    int42_varuint32: bigint | null;
    int42_bool: boolean | null;
    int42_cell: Cell | null;
    int42_address: Address | null;
    int42_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    int256_varint16: bigint | null;
    int256_varint32: bigint | null;
    int256_varuint16: bigint | null;
    int256_varuint32: bigint | null;
    int256_bool: boolean | null;
    int256_cell: Cell | null;
    int256_address: Address | null;
    int256_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    uint8_varint16: bigint | null;
    uint8_varint32: bigint | null;
    uint8_varuint16: bigint | null;
    uint8_varuint32: bigint | null;
    uint8_bool: boolean | null;
    uint8_cell: Cell | null;
    uint8_address: Address | null;
    uint8_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    uint42_varint16: bigint | null;
    uint42_varint32: bigint | null;
    uint42_varuint16: bigint | null;
    uint42_varuint32: bigint | null;
    uint42_bool: boolean | null;
    uint42_cell: Cell | null;
    uint42_address: Address | null;
    uint42_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    uint256_varint16: bigint | null;
    uint256_varint32: bigint | null;
    uint256_varuint16: bigint | null;
    uint256_varuint32: bigint | null;
    uint256_bool: boolean | null;
    uint256_cell: Cell | null;
    uint256_address: Address | null;
    uint256_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    address_varint16: bigint | null;
    address_varint32: bigint | null;
    address_varuint16: bigint | null;
    address_varuint32: bigint | null;
    address_bool: boolean | null;
    address_cell: Cell | null;
    address_address: Address | null;
    address_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
};
export type ReplaceAllMapsResult = {
    $$type: 'ReplaceAllMapsResult';
    int_varint16: boolean;
    int_varint32: boolean;
    int_varuint16: boolean;
    int_varuint32: boolean;
    int_bool: boolean;
    int_cell: boolean;
    int_address: boolean;
    int_struct: boolean;
    int8_varint16: boolean;
    int8_varint32: boolean;
    int8_varuint16: boolean;
    int8_varuint32: boolean;
    int8_bool: boolean;
    int8_cell: boolean;
    int8_address: boolean;
    int8_struct: boolean;
    int42_varint16: boolean;
    int42_varint32: boolean;
    int42_varuint16: boolean;
    int42_varuint32: boolean;
    int42_bool: boolean;
    int42_cell: boolean;
    int42_address: boolean;
    int42_struct: boolean;
    int256_varint16: boolean;
    int256_varint32: boolean;
    int256_varuint16: boolean;
    int256_varuint32: boolean;
    int256_bool: boolean;
    int256_cell: boolean;
    int256_address: boolean;
    int256_struct: boolean;
    uint8_varint16: boolean;
    uint8_varint32: boolean;
    uint8_varuint16: boolean;
    uint8_varuint32: boolean;
    uint8_bool: boolean;
    uint8_cell: boolean;
    uint8_address: boolean;
    uint8_struct: boolean;
    uint42_varint16: boolean;
    uint42_varint32: boolean;
    uint42_varuint16: boolean;
    uint42_varuint32: boolean;
    uint42_bool: boolean;
    uint42_cell: boolean;
    uint42_address: boolean;
    uint42_struct: boolean;
    uint256_varint16: boolean;
    uint256_varint32: boolean;
    uint256_varuint16: boolean;
    uint256_varuint32: boolean;
    uint256_bool: boolean;
    uint256_cell: boolean;
    uint256_address: boolean;
    uint256_struct: boolean;
    address_varint16: boolean;
    address_varint32: boolean;
    address_varuint16: boolean;
    address_varuint32: boolean;
    address_bool: boolean;
    address_cell: boolean;
    address_address: boolean;
    address_struct: boolean;
};
export declare function storeReplaceAllMapsResult(src: ReplaceAllMapsResult): (builder: Builder) => void;
export declare function loadReplaceAllMapsResult(slice: Slice): {
    $$type: "ReplaceAllMapsResult";
    int_varint16: boolean;
    int_varint32: boolean;
    int_varuint16: boolean;
    int_varuint32: boolean;
    int_bool: boolean;
    int_cell: boolean;
    int_address: boolean;
    int_struct: boolean;
    int8_varint16: boolean;
    int8_varint32: boolean;
    int8_varuint16: boolean;
    int8_varuint32: boolean;
    int8_bool: boolean;
    int8_cell: boolean;
    int8_address: boolean;
    int8_struct: boolean;
    int42_varint16: boolean;
    int42_varint32: boolean;
    int42_varuint16: boolean;
    int42_varuint32: boolean;
    int42_bool: boolean;
    int42_cell: boolean;
    int42_address: boolean;
    int42_struct: boolean;
    int256_varint16: boolean;
    int256_varint32: boolean;
    int256_varuint16: boolean;
    int256_varuint32: boolean;
    int256_bool: boolean;
    int256_cell: boolean;
    int256_address: boolean;
    int256_struct: boolean;
    uint8_varint16: boolean;
    uint8_varint32: boolean;
    uint8_varuint16: boolean;
    uint8_varuint32: boolean;
    uint8_bool: boolean;
    uint8_cell: boolean;
    uint8_address: boolean;
    uint8_struct: boolean;
    uint42_varint16: boolean;
    uint42_varint32: boolean;
    uint42_varuint16: boolean;
    uint42_varuint32: boolean;
    uint42_bool: boolean;
    uint42_cell: boolean;
    uint42_address: boolean;
    uint42_struct: boolean;
    uint256_varint16: boolean;
    uint256_varint32: boolean;
    uint256_varuint16: boolean;
    uint256_varuint32: boolean;
    uint256_bool: boolean;
    uint256_cell: boolean;
    uint256_address: boolean;
    uint256_struct: boolean;
    address_varint16: boolean;
    address_varint32: boolean;
    address_varuint16: boolean;
    address_varuint32: boolean;
    address_bool: boolean;
    address_cell: boolean;
    address_address: boolean;
    address_struct: boolean;
};
export type ReplaceGetAllMapsResult = {
    $$type: 'ReplaceGetAllMapsResult';
    int_varint16: bigint | null;
    int_varint32: bigint | null;
    int_varuint16: bigint | null;
    int_varuint32: bigint | null;
    int_bool: boolean | null;
    int_cell: Cell | null;
    int_address: Address | null;
    int_struct: SomeStruct | null;
    int8_varint16: bigint | null;
    int8_varint32: bigint | null;
    int8_varuint16: bigint | null;
    int8_varuint32: bigint | null;
    int8_bool: boolean | null;
    int8_cell: Cell | null;
    int8_address: Address | null;
    int8_struct: SomeStruct | null;
    int42_varint16: bigint | null;
    int42_varint32: bigint | null;
    int42_varuint16: bigint | null;
    int42_varuint32: bigint | null;
    int42_bool: boolean | null;
    int42_cell: Cell | null;
    int42_address: Address | null;
    int42_struct: SomeStruct | null;
    int256_varint16: bigint | null;
    int256_varint32: bigint | null;
    int256_varuint16: bigint | null;
    int256_varuint32: bigint | null;
    int256_bool: boolean | null;
    int256_cell: Cell | null;
    int256_address: Address | null;
    int256_struct: SomeStruct | null;
    uint8_varint16: bigint | null;
    uint8_varint32: bigint | null;
    uint8_varuint16: bigint | null;
    uint8_varuint32: bigint | null;
    uint8_bool: boolean | null;
    uint8_cell: Cell | null;
    uint8_address: Address | null;
    uint8_struct: SomeStruct | null;
    uint42_varint16: bigint | null;
    uint42_varint32: bigint | null;
    uint42_varuint16: bigint | null;
    uint42_varuint32: bigint | null;
    uint42_bool: boolean | null;
    uint42_cell: Cell | null;
    uint42_address: Address | null;
    uint42_struct: SomeStruct | null;
    uint256_varint16: bigint | null;
    uint256_varint32: bigint | null;
    uint256_varuint16: bigint | null;
    uint256_varuint32: bigint | null;
    uint256_bool: boolean | null;
    uint256_cell: Cell | null;
    uint256_address: Address | null;
    uint256_struct: SomeStruct | null;
    address_varint16: bigint | null;
    address_varint32: bigint | null;
    address_varuint16: bigint | null;
    address_varuint32: bigint | null;
    address_bool: boolean | null;
    address_cell: Cell | null;
    address_address: Address | null;
    address_struct: SomeStruct | null;
};
export declare function storeReplaceGetAllMapsResult(src: ReplaceGetAllMapsResult): (builder: Builder) => void;
export declare function loadReplaceGetAllMapsResult(slice: Slice): {
    $$type: "ReplaceGetAllMapsResult";
    int_varint16: bigint | null;
    int_varint32: bigint | null;
    int_varuint16: bigint | null;
    int_varuint32: bigint | null;
    int_bool: boolean | null;
    int_cell: Cell | null;
    int_address: Address | null;
    int_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    int8_varint16: bigint | null;
    int8_varint32: bigint | null;
    int8_varuint16: bigint | null;
    int8_varuint32: bigint | null;
    int8_bool: boolean | null;
    int8_cell: Cell | null;
    int8_address: Address | null;
    int8_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    int42_varint16: bigint | null;
    int42_varint32: bigint | null;
    int42_varuint16: bigint | null;
    int42_varuint32: bigint | null;
    int42_bool: boolean | null;
    int42_cell: Cell | null;
    int42_address: Address | null;
    int42_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    int256_varint16: bigint | null;
    int256_varint32: bigint | null;
    int256_varuint16: bigint | null;
    int256_varuint32: bigint | null;
    int256_bool: boolean | null;
    int256_cell: Cell | null;
    int256_address: Address | null;
    int256_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    uint8_varint16: bigint | null;
    uint8_varint32: bigint | null;
    uint8_varuint16: bigint | null;
    uint8_varuint32: bigint | null;
    uint8_bool: boolean | null;
    uint8_cell: Cell | null;
    uint8_address: Address | null;
    uint8_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    uint42_varint16: bigint | null;
    uint42_varint32: bigint | null;
    uint42_varuint16: bigint | null;
    uint42_varuint32: bigint | null;
    uint42_bool: boolean | null;
    uint42_cell: Cell | null;
    uint42_address: Address | null;
    uint42_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    uint256_varint16: bigint | null;
    uint256_varint32: bigint | null;
    uint256_varuint16: bigint | null;
    uint256_varuint32: bigint | null;
    uint256_bool: boolean | null;
    uint256_cell: Cell | null;
    uint256_address: Address | null;
    uint256_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
    address_varint16: bigint | null;
    address_varint32: bigint | null;
    address_varuint16: bigint | null;
    address_varuint32: bigint | null;
    address_bool: boolean | null;
    address_cell: Cell | null;
    address_address: Address | null;
    address_struct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
};
export type ExistsAllMapsResult = {
    $$type: 'ExistsAllMapsResult';
    int_varint16: boolean;
    int_varint32: boolean;
    int_varuint16: boolean;
    int_varuint32: boolean;
    int_bool: boolean;
    int_cell: boolean;
    int_address: boolean;
    int_struct: boolean;
    int8_varint16: boolean;
    int8_varint32: boolean;
    int8_varuint16: boolean;
    int8_varuint32: boolean;
    int8_bool: boolean;
    int8_cell: boolean;
    int8_address: boolean;
    int8_struct: boolean;
    int42_varint16: boolean;
    int42_varint32: boolean;
    int42_varuint16: boolean;
    int42_varuint32: boolean;
    int42_bool: boolean;
    int42_cell: boolean;
    int42_address: boolean;
    int42_struct: boolean;
    int256_varint16: boolean;
    int256_varint32: boolean;
    int256_varuint16: boolean;
    int256_varuint32: boolean;
    int256_bool: boolean;
    int256_cell: boolean;
    int256_address: boolean;
    int256_struct: boolean;
    uint8_varint16: boolean;
    uint8_varint32: boolean;
    uint8_varuint16: boolean;
    uint8_varuint32: boolean;
    uint8_bool: boolean;
    uint8_cell: boolean;
    uint8_address: boolean;
    uint8_struct: boolean;
    uint42_varint16: boolean;
    uint42_varint32: boolean;
    uint42_varuint16: boolean;
    uint42_varuint32: boolean;
    uint42_bool: boolean;
    uint42_cell: boolean;
    uint42_address: boolean;
    uint42_struct: boolean;
    uint256_varint16: boolean;
    uint256_varint32: boolean;
    uint256_varuint16: boolean;
    uint256_varuint32: boolean;
    uint256_bool: boolean;
    uint256_cell: boolean;
    uint256_address: boolean;
    uint256_struct: boolean;
    address_varint16: boolean;
    address_varint32: boolean;
    address_varuint16: boolean;
    address_varuint32: boolean;
    address_bool: boolean;
    address_cell: boolean;
    address_address: boolean;
    address_struct: boolean;
};
export declare function storeExistsAllMapsResult(src: ExistsAllMapsResult): (builder: Builder) => void;
export declare function loadExistsAllMapsResult(slice: Slice): {
    $$type: "ExistsAllMapsResult";
    int_varint16: boolean;
    int_varint32: boolean;
    int_varuint16: boolean;
    int_varuint32: boolean;
    int_bool: boolean;
    int_cell: boolean;
    int_address: boolean;
    int_struct: boolean;
    int8_varint16: boolean;
    int8_varint32: boolean;
    int8_varuint16: boolean;
    int8_varuint32: boolean;
    int8_bool: boolean;
    int8_cell: boolean;
    int8_address: boolean;
    int8_struct: boolean;
    int42_varint16: boolean;
    int42_varint32: boolean;
    int42_varuint16: boolean;
    int42_varuint32: boolean;
    int42_bool: boolean;
    int42_cell: boolean;
    int42_address: boolean;
    int42_struct: boolean;
    int256_varint16: boolean;
    int256_varint32: boolean;
    int256_varuint16: boolean;
    int256_varuint32: boolean;
    int256_bool: boolean;
    int256_cell: boolean;
    int256_address: boolean;
    int256_struct: boolean;
    uint8_varint16: boolean;
    uint8_varint32: boolean;
    uint8_varuint16: boolean;
    uint8_varuint32: boolean;
    uint8_bool: boolean;
    uint8_cell: boolean;
    uint8_address: boolean;
    uint8_struct: boolean;
    uint42_varint16: boolean;
    uint42_varint32: boolean;
    uint42_varuint16: boolean;
    uint42_varuint32: boolean;
    uint42_bool: boolean;
    uint42_cell: boolean;
    uint42_address: boolean;
    uint42_struct: boolean;
    uint256_varint16: boolean;
    uint256_varint32: boolean;
    uint256_varuint16: boolean;
    uint256_varuint32: boolean;
    uint256_bool: boolean;
    uint256_cell: boolean;
    uint256_address: boolean;
    uint256_struct: boolean;
    address_varint16: boolean;
    address_varint32: boolean;
    address_varuint16: boolean;
    address_varuint32: boolean;
    address_bool: boolean;
    address_cell: boolean;
    address_address: boolean;
    address_struct: boolean;
};
export type IsEmptyAllMapsResult = {
    $$type: 'IsEmptyAllMapsResult';
    int_varint16: boolean;
    int_varint32: boolean;
    int_varuint16: boolean;
    int_varuint32: boolean;
    int_bool: boolean;
    int_cell: boolean;
    int_address: boolean;
    int_struct: boolean;
    int8_varint16: boolean;
    int8_varint32: boolean;
    int8_varuint16: boolean;
    int8_varuint32: boolean;
    int8_bool: boolean;
    int8_cell: boolean;
    int8_address: boolean;
    int8_struct: boolean;
    int42_varint16: boolean;
    int42_varint32: boolean;
    int42_varuint16: boolean;
    int42_varuint32: boolean;
    int42_bool: boolean;
    int42_cell: boolean;
    int42_address: boolean;
    int42_struct: boolean;
    int256_varint16: boolean;
    int256_varint32: boolean;
    int256_varuint16: boolean;
    int256_varuint32: boolean;
    int256_bool: boolean;
    int256_cell: boolean;
    int256_address: boolean;
    int256_struct: boolean;
    uint8_varint16: boolean;
    uint8_varint32: boolean;
    uint8_varuint16: boolean;
    uint8_varuint32: boolean;
    uint8_bool: boolean;
    uint8_cell: boolean;
    uint8_address: boolean;
    uint8_struct: boolean;
    uint42_varint16: boolean;
    uint42_varint32: boolean;
    uint42_varuint16: boolean;
    uint42_varuint32: boolean;
    uint42_bool: boolean;
    uint42_cell: boolean;
    uint42_address: boolean;
    uint42_struct: boolean;
    uint256_varint16: boolean;
    uint256_varint32: boolean;
    uint256_varuint16: boolean;
    uint256_varuint32: boolean;
    uint256_bool: boolean;
    uint256_cell: boolean;
    uint256_address: boolean;
    uint256_struct: boolean;
    address_varint16: boolean;
    address_varint32: boolean;
    address_varuint16: boolean;
    address_varuint32: boolean;
    address_bool: boolean;
    address_cell: boolean;
    address_address: boolean;
    address_struct: boolean;
};
export declare function storeIsEmptyAllMapsResult(src: IsEmptyAllMapsResult): (builder: Builder) => void;
export declare function loadIsEmptyAllMapsResult(slice: Slice): {
    $$type: "IsEmptyAllMapsResult";
    int_varint16: boolean;
    int_varint32: boolean;
    int_varuint16: boolean;
    int_varuint32: boolean;
    int_bool: boolean;
    int_cell: boolean;
    int_address: boolean;
    int_struct: boolean;
    int8_varint16: boolean;
    int8_varint32: boolean;
    int8_varuint16: boolean;
    int8_varuint32: boolean;
    int8_bool: boolean;
    int8_cell: boolean;
    int8_address: boolean;
    int8_struct: boolean;
    int42_varint16: boolean;
    int42_varint32: boolean;
    int42_varuint16: boolean;
    int42_varuint32: boolean;
    int42_bool: boolean;
    int42_cell: boolean;
    int42_address: boolean;
    int42_struct: boolean;
    int256_varint16: boolean;
    int256_varint32: boolean;
    int256_varuint16: boolean;
    int256_varuint32: boolean;
    int256_bool: boolean;
    int256_cell: boolean;
    int256_address: boolean;
    int256_struct: boolean;
    uint8_varint16: boolean;
    uint8_varint32: boolean;
    uint8_varuint16: boolean;
    uint8_varuint32: boolean;
    uint8_bool: boolean;
    uint8_cell: boolean;
    uint8_address: boolean;
    uint8_struct: boolean;
    uint42_varint16: boolean;
    uint42_varint32: boolean;
    uint42_varuint16: boolean;
    uint42_varuint32: boolean;
    uint42_bool: boolean;
    uint42_cell: boolean;
    uint42_address: boolean;
    uint42_struct: boolean;
    uint256_varint16: boolean;
    uint256_varint32: boolean;
    uint256_varuint16: boolean;
    uint256_varuint32: boolean;
    uint256_bool: boolean;
    uint256_cell: boolean;
    uint256_address: boolean;
    uint256_struct: boolean;
    address_varint16: boolean;
    address_varint32: boolean;
    address_varuint16: boolean;
    address_varuint32: boolean;
    address_bool: boolean;
    address_cell: boolean;
    address_address: boolean;
    address_struct: boolean;
};
export type AsCellAllMapsResult = {
    $$type: 'AsCellAllMapsResult';
    int_varint16: Cell | null;
    int_varint32: Cell | null;
    int_varuint16: Cell | null;
    int_varuint32: Cell | null;
    int_bool: Cell | null;
    int_cell: Cell | null;
    int_address: Cell | null;
    int_struct: Cell | null;
    int8_varint16: Cell | null;
    int8_varint32: Cell | null;
    int8_varuint16: Cell | null;
    int8_varuint32: Cell | null;
    int8_bool: Cell | null;
    int8_cell: Cell | null;
    int8_address: Cell | null;
    int8_struct: Cell | null;
    int42_varint16: Cell | null;
    int42_varint32: Cell | null;
    int42_varuint16: Cell | null;
    int42_varuint32: Cell | null;
    int42_bool: Cell | null;
    int42_cell: Cell | null;
    int42_address: Cell | null;
    int42_struct: Cell | null;
    int256_varint16: Cell | null;
    int256_varint32: Cell | null;
    int256_varuint16: Cell | null;
    int256_varuint32: Cell | null;
    int256_bool: Cell | null;
    int256_cell: Cell | null;
    int256_address: Cell | null;
    int256_struct: Cell | null;
    uint8_varint16: Cell | null;
    uint8_varint32: Cell | null;
    uint8_varuint16: Cell | null;
    uint8_varuint32: Cell | null;
    uint8_bool: Cell | null;
    uint8_cell: Cell | null;
    uint8_address: Cell | null;
    uint8_struct: Cell | null;
    uint42_varint16: Cell | null;
    uint42_varint32: Cell | null;
    uint42_varuint16: Cell | null;
    uint42_varuint32: Cell | null;
    uint42_bool: Cell | null;
    uint42_cell: Cell | null;
    uint42_address: Cell | null;
    uint42_struct: Cell | null;
    uint256_varint16: Cell | null;
    uint256_varint32: Cell | null;
    uint256_varuint16: Cell | null;
    uint256_varuint32: Cell | null;
    uint256_bool: Cell | null;
    uint256_cell: Cell | null;
    uint256_address: Cell | null;
    uint256_struct: Cell | null;
    address_varint16: Cell | null;
    address_varint32: Cell | null;
    address_varuint16: Cell | null;
    address_varuint32: Cell | null;
    address_bool: Cell | null;
    address_cell: Cell | null;
    address_address: Cell | null;
    address_struct: Cell | null;
};
export declare function storeAsCellAllMapsResult(src: AsCellAllMapsResult): (builder: Builder) => void;
export declare function loadAsCellAllMapsResult(slice: Slice): {
    $$type: "AsCellAllMapsResult";
    int_varint16: Cell | null;
    int_varint32: Cell | null;
    int_varuint16: Cell | null;
    int_varuint32: Cell | null;
    int_bool: Cell | null;
    int_cell: Cell | null;
    int_address: Cell | null;
    int_struct: Cell | null;
    int8_varint16: Cell | null;
    int8_varint32: Cell | null;
    int8_varuint16: Cell | null;
    int8_varuint32: Cell | null;
    int8_bool: Cell | null;
    int8_cell: Cell | null;
    int8_address: Cell | null;
    int8_struct: Cell | null;
    int42_varint16: Cell | null;
    int42_varint32: Cell | null;
    int42_varuint16: Cell | null;
    int42_varuint32: Cell | null;
    int42_bool: Cell | null;
    int42_cell: Cell | null;
    int42_address: Cell | null;
    int42_struct: Cell | null;
    int256_varint16: Cell | null;
    int256_varint32: Cell | null;
    int256_varuint16: Cell | null;
    int256_varuint32: Cell | null;
    int256_bool: Cell | null;
    int256_cell: Cell | null;
    int256_address: Cell | null;
    int256_struct: Cell | null;
    uint8_varint16: Cell | null;
    uint8_varint32: Cell | null;
    uint8_varuint16: Cell | null;
    uint8_varuint32: Cell | null;
    uint8_bool: Cell | null;
    uint8_cell: Cell | null;
    uint8_address: Cell | null;
    uint8_struct: Cell | null;
    uint42_varint16: Cell | null;
    uint42_varint32: Cell | null;
    uint42_varuint16: Cell | null;
    uint42_varuint32: Cell | null;
    uint42_bool: Cell | null;
    uint42_cell: Cell | null;
    uint42_address: Cell | null;
    uint42_struct: Cell | null;
    uint256_varint16: Cell | null;
    uint256_varint32: Cell | null;
    uint256_varuint16: Cell | null;
    uint256_varuint32: Cell | null;
    uint256_bool: Cell | null;
    uint256_cell: Cell | null;
    uint256_address: Cell | null;
    uint256_struct: Cell | null;
    address_varint16: Cell | null;
    address_varint32: Cell | null;
    address_varuint16: Cell | null;
    address_varuint32: Cell | null;
    address_bool: Cell | null;
    address_cell: Cell | null;
    address_address: Cell | null;
    address_struct: Cell | null;
};
export type SetAllMaps = {
    $$type: 'SetAllMaps';
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueVarint16: bigint | null;
    valueVarint32: bigint | null;
    valueVaruint16: bigint | null;
    valueVaruint32: bigint | null;
    valueBool: boolean | null;
    valueCell: Cell | null;
    valueAddress: Address | null;
    valueStruct: SomeStruct | null;
};
export declare function storeSetAllMaps(src: SetAllMaps): (builder: Builder) => void;
export declare function loadSetAllMaps(slice: Slice): {
    $$type: "SetAllMaps";
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueVarint16: bigint | null;
    valueVarint32: bigint | null;
    valueVaruint16: bigint | null;
    valueVaruint32: bigint | null;
    valueBool: boolean | null;
    valueCell: Cell | null;
    valueAddress: Address | null;
    valueStruct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
};
export type DelAllMaps = {
    $$type: 'DelAllMaps';
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
};
export declare function storeDelAllMaps(src: DelAllMaps): (builder: Builder) => void;
export declare function loadDelAllMaps(slice: Slice): {
    $$type: "DelAllMaps";
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
};
export type ReplaceAllMaps = {
    $$type: 'ReplaceAllMaps';
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueVarint16: bigint | null;
    valueVarint32: bigint | null;
    valueVaruint16: bigint | null;
    valueVaruint32: bigint | null;
    valueBool: boolean | null;
    valueCell: Cell | null;
    valueAddress: Address | null;
    valueStruct: SomeStruct | null;
};
export declare function storeReplaceAllMaps(src: ReplaceAllMaps): (builder: Builder) => void;
export declare function loadReplaceAllMaps(slice: Slice): {
    $$type: "ReplaceAllMaps";
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueVarint16: bigint | null;
    valueVarint32: bigint | null;
    valueVaruint16: bigint | null;
    valueVaruint32: bigint | null;
    valueBool: boolean | null;
    valueCell: Cell | null;
    valueAddress: Address | null;
    valueStruct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
};
export type ReplaceGetAllMaps = {
    $$type: 'ReplaceGetAllMaps';
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueVarint16: bigint | null;
    valueVarint32: bigint | null;
    valueVaruint16: bigint | null;
    valueVaruint32: bigint | null;
    valueBool: boolean | null;
    valueCell: Cell | null;
    valueAddress: Address | null;
    valueStruct: SomeStruct | null;
};
export declare function storeReplaceGetAllMaps(src: ReplaceGetAllMaps): (builder: Builder) => void;
export declare function loadReplaceGetAllMaps(slice: Slice): {
    $$type: "ReplaceGetAllMaps";
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueVarint16: bigint | null;
    valueVarint32: bigint | null;
    valueVaruint16: bigint | null;
    valueVaruint32: bigint | null;
    valueBool: boolean | null;
    valueCell: Cell | null;
    valueAddress: Address | null;
    valueStruct: {
        $$type: "SomeStruct";
        int: bigint;
        bool: boolean;
        address: Address;
        a: bigint;
        b: bigint;
    } | null;
};
export type CheckNullReference = {
    $$type: 'CheckNullReference';
};
export declare function storeCheckNullReference(src: CheckNullReference): (builder: Builder) => void;
export declare function loadCheckNullReference(slice: Slice): {
    $$type: "CheckNullReference";
};
export type MapTestContract$Data = {
    $$type: 'MapTestContract$Data';
    int_varint16: Dictionary<bigint, bigint>;
    int_varint32: Dictionary<bigint, bigint>;
    int_varuint16: Dictionary<bigint, bigint>;
    int_varuint32: Dictionary<bigint, bigint>;
    int_bool: Dictionary<bigint, boolean>;
    int_cell: Dictionary<bigint, Cell>;
    int_address: Dictionary<bigint, Address>;
    int_struct: Dictionary<bigint, SomeStruct>;
    int8_varint16: Dictionary<number, bigint>;
    int8_varint32: Dictionary<number, bigint>;
    int8_varuint16: Dictionary<number, bigint>;
    int8_varuint32: Dictionary<number, bigint>;
    int8_bool: Dictionary<number, boolean>;
    int8_cell: Dictionary<number, Cell>;
    int8_address: Dictionary<number, Address>;
    int8_struct: Dictionary<number, SomeStruct>;
    int42_varint16: Dictionary<bigint, bigint>;
    int42_varint32: Dictionary<bigint, bigint>;
    int42_varuint16: Dictionary<bigint, bigint>;
    int42_varuint32: Dictionary<bigint, bigint>;
    int42_bool: Dictionary<bigint, boolean>;
    int42_cell: Dictionary<bigint, Cell>;
    int42_address: Dictionary<bigint, Address>;
    int42_struct: Dictionary<bigint, SomeStruct>;
    int256_varint16: Dictionary<bigint, bigint>;
    int256_varint32: Dictionary<bigint, bigint>;
    int256_varuint16: Dictionary<bigint, bigint>;
    int256_varuint32: Dictionary<bigint, bigint>;
    int256_bool: Dictionary<bigint, boolean>;
    int256_cell: Dictionary<bigint, Cell>;
    int256_address: Dictionary<bigint, Address>;
    int256_struct: Dictionary<bigint, SomeStruct>;
    uint8_varint16: Dictionary<number, bigint>;
    uint8_varint32: Dictionary<number, bigint>;
    uint8_varuint16: Dictionary<number, bigint>;
    uint8_varuint32: Dictionary<number, bigint>;
    uint8_bool: Dictionary<number, boolean>;
    uint8_cell: Dictionary<number, Cell>;
    uint8_address: Dictionary<number, Address>;
    uint8_struct: Dictionary<number, SomeStruct>;
    uint42_varint16: Dictionary<bigint, bigint>;
    uint42_varint32: Dictionary<bigint, bigint>;
    uint42_varuint16: Dictionary<bigint, bigint>;
    uint42_varuint32: Dictionary<bigint, bigint>;
    uint42_bool: Dictionary<bigint, boolean>;
    uint42_cell: Dictionary<bigint, Cell>;
    uint42_address: Dictionary<bigint, Address>;
    uint42_struct: Dictionary<bigint, SomeStruct>;
    uint256_varint16: Dictionary<bigint, bigint>;
    uint256_varint32: Dictionary<bigint, bigint>;
    uint256_varuint16: Dictionary<bigint, bigint>;
    uint256_varuint32: Dictionary<bigint, bigint>;
    uint256_bool: Dictionary<bigint, boolean>;
    uint256_cell: Dictionary<bigint, Cell>;
    uint256_address: Dictionary<bigint, Address>;
    uint256_struct: Dictionary<bigint, SomeStruct>;
    address_varint16: Dictionary<Address, bigint>;
    address_varint32: Dictionary<Address, bigint>;
    address_varuint16: Dictionary<Address, bigint>;
    address_varuint32: Dictionary<Address, bigint>;
    address_bool: Dictionary<Address, boolean>;
    address_cell: Dictionary<Address, Cell>;
    address_address: Dictionary<Address, Address>;
    address_struct: Dictionary<Address, SomeStruct>;
};
export declare function storeMapTestContract$Data(src: MapTestContract$Data): (builder: Builder) => void;
export declare function loadMapTestContract$Data(slice: Slice): {
    $$type: "MapTestContract$Data";
    int_varint16: Dictionary<bigint, bigint>;
    int_varint32: Dictionary<bigint, bigint>;
    int_varuint16: Dictionary<bigint, bigint>;
    int_varuint32: Dictionary<bigint, bigint>;
    int_bool: Dictionary<bigint, boolean>;
    int_cell: Dictionary<bigint, Cell>;
    int_address: Dictionary<bigint, Address>;
    int_struct: Dictionary<bigint, SomeStruct>;
    int8_varint16: Dictionary<number, bigint>;
    int8_varint32: Dictionary<number, bigint>;
    int8_varuint16: Dictionary<number, bigint>;
    int8_varuint32: Dictionary<number, bigint>;
    int8_bool: Dictionary<number, boolean>;
    int8_cell: Dictionary<number, Cell>;
    int8_address: Dictionary<number, Address>;
    int8_struct: Dictionary<number, SomeStruct>;
    int42_varint16: Dictionary<bigint, bigint>;
    int42_varint32: Dictionary<bigint, bigint>;
    int42_varuint16: Dictionary<bigint, bigint>;
    int42_varuint32: Dictionary<bigint, bigint>;
    int42_bool: Dictionary<bigint, boolean>;
    int42_cell: Dictionary<bigint, Cell>;
    int42_address: Dictionary<bigint, Address>;
    int42_struct: Dictionary<bigint, SomeStruct>;
    int256_varint16: Dictionary<bigint, bigint>;
    int256_varint32: Dictionary<bigint, bigint>;
    int256_varuint16: Dictionary<bigint, bigint>;
    int256_varuint32: Dictionary<bigint, bigint>;
    int256_bool: Dictionary<bigint, boolean>;
    int256_cell: Dictionary<bigint, Cell>;
    int256_address: Dictionary<bigint, Address>;
    int256_struct: Dictionary<bigint, SomeStruct>;
    uint8_varint16: Dictionary<number, bigint>;
    uint8_varint32: Dictionary<number, bigint>;
    uint8_varuint16: Dictionary<number, bigint>;
    uint8_varuint32: Dictionary<number, bigint>;
    uint8_bool: Dictionary<number, boolean>;
    uint8_cell: Dictionary<number, Cell>;
    uint8_address: Dictionary<number, Address>;
    uint8_struct: Dictionary<number, SomeStruct>;
    uint42_varint16: Dictionary<bigint, bigint>;
    uint42_varint32: Dictionary<bigint, bigint>;
    uint42_varuint16: Dictionary<bigint, bigint>;
    uint42_varuint32: Dictionary<bigint, bigint>;
    uint42_bool: Dictionary<bigint, boolean>;
    uint42_cell: Dictionary<bigint, Cell>;
    uint42_address: Dictionary<bigint, Address>;
    uint42_struct: Dictionary<bigint, SomeStruct>;
    uint256_varint16: Dictionary<bigint, bigint>;
    uint256_varint32: Dictionary<bigint, bigint>;
    uint256_varuint16: Dictionary<bigint, bigint>;
    uint256_varuint32: Dictionary<bigint, bigint>;
    uint256_bool: Dictionary<bigint, boolean>;
    uint256_cell: Dictionary<bigint, Cell>;
    uint256_address: Dictionary<bigint, Address>;
    uint256_struct: Dictionary<bigint, SomeStruct>;
    address_varint16: Dictionary<Address, bigint>;
    address_varint32: Dictionary<Address, bigint>;
    address_varuint16: Dictionary<Address, bigint>;
    address_varuint32: Dictionary<Address, bigint>;
    address_bool: Dictionary<Address, boolean>;
    address_cell: Dictionary<Address, Cell>;
    address_address: Dictionary<Address, Address>;
    address_struct: Dictionary<Address, SomeStruct>;
};
export declare const MapTestContract_getterMapping: {
    [key: string]: string;
};
export declare class MapTestContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapTestContract>;
    static fromAddress(address: Address): MapTestContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | SetAllMaps | DelAllMaps | ReplaceAllMaps | ReplaceGetAllMaps | CheckNullReference): Promise<void>;
    getAllMaps(provider: ContractProvider): Promise<{
        $$type: "MapTestContract$Data";
        int_varint16: Dictionary<bigint, bigint>;
        int_varint32: Dictionary<bigint, bigint>;
        int_varuint16: Dictionary<bigint, bigint>;
        int_varuint32: Dictionary<bigint, bigint>;
        int_bool: Dictionary<bigint, boolean>;
        int_cell: Dictionary<bigint, Cell>;
        int_address: Dictionary<bigint, Address>;
        int_struct: Dictionary<bigint, SomeStruct>;
        int8_varint16: Dictionary<number, bigint>;
        int8_varint32: Dictionary<number, bigint>;
        int8_varuint16: Dictionary<number, bigint>;
        int8_varuint32: Dictionary<number, bigint>;
        int8_bool: Dictionary<number, boolean>;
        int8_cell: Dictionary<number, Cell>;
        int8_address: Dictionary<number, Address>;
        int8_struct: Dictionary<number, SomeStruct>;
        int42_varint16: Dictionary<bigint, bigint>;
        int42_varint32: Dictionary<bigint, bigint>;
        int42_varuint16: Dictionary<bigint, bigint>;
        int42_varuint32: Dictionary<bigint, bigint>;
        int42_bool: Dictionary<bigint, boolean>;
        int42_cell: Dictionary<bigint, Cell>;
        int42_address: Dictionary<bigint, Address>;
        int42_struct: Dictionary<bigint, SomeStruct>;
        int256_varint16: Dictionary<bigint, bigint>;
        int256_varint32: Dictionary<bigint, bigint>;
        int256_varuint16: Dictionary<bigint, bigint>;
        int256_varuint32: Dictionary<bigint, bigint>;
        int256_bool: Dictionary<bigint, boolean>;
        int256_cell: Dictionary<bigint, Cell>;
        int256_address: Dictionary<bigint, Address>;
        int256_struct: Dictionary<bigint, SomeStruct>;
        uint8_varint16: Dictionary<number, bigint>;
        uint8_varint32: Dictionary<number, bigint>;
        uint8_varuint16: Dictionary<number, bigint>;
        uint8_varuint32: Dictionary<number, bigint>;
        uint8_bool: Dictionary<number, boolean>;
        uint8_cell: Dictionary<number, Cell>;
        uint8_address: Dictionary<number, Address>;
        uint8_struct: Dictionary<number, SomeStruct>;
        uint42_varint16: Dictionary<bigint, bigint>;
        uint42_varint32: Dictionary<bigint, bigint>;
        uint42_varuint16: Dictionary<bigint, bigint>;
        uint42_varuint32: Dictionary<bigint, bigint>;
        uint42_bool: Dictionary<bigint, boolean>;
        uint42_cell: Dictionary<bigint, Cell>;
        uint42_address: Dictionary<bigint, Address>;
        uint42_struct: Dictionary<bigint, SomeStruct>;
        uint256_varint16: Dictionary<bigint, bigint>;
        uint256_varint32: Dictionary<bigint, bigint>;
        uint256_varuint16: Dictionary<bigint, bigint>;
        uint256_varuint32: Dictionary<bigint, bigint>;
        uint256_bool: Dictionary<bigint, boolean>;
        uint256_cell: Dictionary<bigint, Cell>;
        uint256_address: Dictionary<bigint, Address>;
        uint256_struct: Dictionary<bigint, SomeStruct>;
        address_varint16: Dictionary<Address, bigint>;
        address_varint32: Dictionary<Address, bigint>;
        address_varuint16: Dictionary<Address, bigint>;
        address_varuint32: Dictionary<Address, bigint>;
        address_bool: Dictionary<Address, boolean>;
        address_cell: Dictionary<Address, Cell>;
        address_address: Dictionary<Address, Address>;
        address_struct: Dictionary<Address, SomeStruct>;
    }>;
    getGetAllMaps(provider: ContractProvider, keyInt: bigint, keyInt8: bigint, keyInt42: bigint, keyInt256: bigint, keyUint8: bigint, keyUint42: bigint, keyUint256: bigint, keyAddress: Address): Promise<{
        $$type: "GetAllMapsResult";
        int_varint16: bigint | null;
        int_varint32: bigint | null;
        int_varuint16: bigint | null;
        int_varuint32: bigint | null;
        int_bool: boolean | null;
        int_cell: Cell | null;
        int_address: Address | null;
        int_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        int8_varint16: bigint | null;
        int8_varint32: bigint | null;
        int8_varuint16: bigint | null;
        int8_varuint32: bigint | null;
        int8_bool: boolean | null;
        int8_cell: Cell | null;
        int8_address: Address | null;
        int8_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        int42_varint16: bigint | null;
        int42_varint32: bigint | null;
        int42_varuint16: bigint | null;
        int42_varuint32: bigint | null;
        int42_bool: boolean | null;
        int42_cell: Cell | null;
        int42_address: Address | null;
        int42_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        int256_varint16: bigint | null;
        int256_varint32: bigint | null;
        int256_varuint16: bigint | null;
        int256_varuint32: bigint | null;
        int256_bool: boolean | null;
        int256_cell: Cell | null;
        int256_address: Address | null;
        int256_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        uint8_varint16: bigint | null;
        uint8_varint32: bigint | null;
        uint8_varuint16: bigint | null;
        uint8_varuint32: bigint | null;
        uint8_bool: boolean | null;
        uint8_cell: Cell | null;
        uint8_address: Address | null;
        uint8_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        uint42_varint16: bigint | null;
        uint42_varint32: bigint | null;
        uint42_varuint16: bigint | null;
        uint42_varuint32: bigint | null;
        uint42_bool: boolean | null;
        uint42_cell: Cell | null;
        uint42_address: Address | null;
        uint42_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        uint256_varint16: bigint | null;
        uint256_varint32: bigint | null;
        uint256_varuint16: bigint | null;
        uint256_varuint32: bigint | null;
        uint256_bool: boolean | null;
        uint256_cell: Cell | null;
        uint256_address: Address | null;
        uint256_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        address_varint16: bigint | null;
        address_varint32: bigint | null;
        address_varuint16: bigint | null;
        address_varuint32: bigint | null;
        address_bool: boolean | null;
        address_cell: Cell | null;
        address_address: Address | null;
        address_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
    }>;
    getReplaceAllMaps(provider: ContractProvider, keyInt: bigint, keyInt8: bigint, keyInt42: bigint, keyInt256: bigint, keyUint8: bigint, keyUint42: bigint, keyUint256: bigint, keyAddress: Address, valueVarint16: bigint, valueVarint32: bigint, valueVaruint16: bigint, valueVaruint32: bigint, valueBool: boolean, valueCell: Cell, valueAddress: Address, valueStruct: SomeStruct): Promise<{
        $$type: "ReplaceAllMapsResult";
        int_varint16: boolean;
        int_varint32: boolean;
        int_varuint16: boolean;
        int_varuint32: boolean;
        int_bool: boolean;
        int_cell: boolean;
        int_address: boolean;
        int_struct: boolean;
        int8_varint16: boolean;
        int8_varint32: boolean;
        int8_varuint16: boolean;
        int8_varuint32: boolean;
        int8_bool: boolean;
        int8_cell: boolean;
        int8_address: boolean;
        int8_struct: boolean;
        int42_varint16: boolean;
        int42_varint32: boolean;
        int42_varuint16: boolean;
        int42_varuint32: boolean;
        int42_bool: boolean;
        int42_cell: boolean;
        int42_address: boolean;
        int42_struct: boolean;
        int256_varint16: boolean;
        int256_varint32: boolean;
        int256_varuint16: boolean;
        int256_varuint32: boolean;
        int256_bool: boolean;
        int256_cell: boolean;
        int256_address: boolean;
        int256_struct: boolean;
        uint8_varint16: boolean;
        uint8_varint32: boolean;
        uint8_varuint16: boolean;
        uint8_varuint32: boolean;
        uint8_bool: boolean;
        uint8_cell: boolean;
        uint8_address: boolean;
        uint8_struct: boolean;
        uint42_varint16: boolean;
        uint42_varint32: boolean;
        uint42_varuint16: boolean;
        uint42_varuint32: boolean;
        uint42_bool: boolean;
        uint42_cell: boolean;
        uint42_address: boolean;
        uint42_struct: boolean;
        uint256_varint16: boolean;
        uint256_varint32: boolean;
        uint256_varuint16: boolean;
        uint256_varuint32: boolean;
        uint256_bool: boolean;
        uint256_cell: boolean;
        uint256_address: boolean;
        uint256_struct: boolean;
        address_varint16: boolean;
        address_varint32: boolean;
        address_varuint16: boolean;
        address_varuint32: boolean;
        address_bool: boolean;
        address_cell: boolean;
        address_address: boolean;
        address_struct: boolean;
    }>;
    getReplaceGetAllMaps(provider: ContractProvider, keyInt: bigint, keyInt8: bigint, keyInt42: bigint, keyInt256: bigint, keyUint8: bigint, keyUint42: bigint, keyUint256: bigint, keyAddress: Address, valueVarint16: bigint, valueVarint32: bigint, valueVaruint16: bigint, valueVaruint32: bigint, valueBool: boolean, valueCell: Cell, valueAddress: Address, valueStruct: SomeStruct): Promise<{
        $$type: "ReplaceGetAllMapsResult";
        int_varint16: bigint | null;
        int_varint32: bigint | null;
        int_varuint16: bigint | null;
        int_varuint32: bigint | null;
        int_bool: boolean | null;
        int_cell: Cell | null;
        int_address: Address | null;
        int_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        int8_varint16: bigint | null;
        int8_varint32: bigint | null;
        int8_varuint16: bigint | null;
        int8_varuint32: bigint | null;
        int8_bool: boolean | null;
        int8_cell: Cell | null;
        int8_address: Address | null;
        int8_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        int42_varint16: bigint | null;
        int42_varint32: bigint | null;
        int42_varuint16: bigint | null;
        int42_varuint32: bigint | null;
        int42_bool: boolean | null;
        int42_cell: Cell | null;
        int42_address: Address | null;
        int42_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        int256_varint16: bigint | null;
        int256_varint32: bigint | null;
        int256_varuint16: bigint | null;
        int256_varuint32: bigint | null;
        int256_bool: boolean | null;
        int256_cell: Cell | null;
        int256_address: Address | null;
        int256_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        uint8_varint16: bigint | null;
        uint8_varint32: bigint | null;
        uint8_varuint16: bigint | null;
        uint8_varuint32: bigint | null;
        uint8_bool: boolean | null;
        uint8_cell: Cell | null;
        uint8_address: Address | null;
        uint8_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        uint42_varint16: bigint | null;
        uint42_varint32: bigint | null;
        uint42_varuint16: bigint | null;
        uint42_varuint32: bigint | null;
        uint42_bool: boolean | null;
        uint42_cell: Cell | null;
        uint42_address: Address | null;
        uint42_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        uint256_varint16: bigint | null;
        uint256_varint32: bigint | null;
        uint256_varuint16: bigint | null;
        uint256_varuint32: bigint | null;
        uint256_bool: boolean | null;
        uint256_cell: Cell | null;
        uint256_address: Address | null;
        uint256_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
        address_varint16: bigint | null;
        address_varint32: bigint | null;
        address_varuint16: bigint | null;
        address_varuint32: bigint | null;
        address_bool: boolean | null;
        address_cell: Cell | null;
        address_address: Address | null;
        address_struct: {
            $$type: "SomeStruct";
            int: bigint;
            bool: boolean;
            address: Address;
            a: bigint;
            b: bigint;
        } | null;
    }>;
    getExistsAllMaps(provider: ContractProvider, keyInt: bigint, keyInt8: bigint, keyInt42: bigint, keyInt256: bigint, keyUint8: bigint, keyUint42: bigint, keyUint256: bigint, keyAddress: Address): Promise<{
        $$type: "ExistsAllMapsResult";
        int_varint16: boolean;
        int_varint32: boolean;
        int_varuint16: boolean;
        int_varuint32: boolean;
        int_bool: boolean;
        int_cell: boolean;
        int_address: boolean;
        int_struct: boolean;
        int8_varint16: boolean;
        int8_varint32: boolean;
        int8_varuint16: boolean;
        int8_varuint32: boolean;
        int8_bool: boolean;
        int8_cell: boolean;
        int8_address: boolean;
        int8_struct: boolean;
        int42_varint16: boolean;
        int42_varint32: boolean;
        int42_varuint16: boolean;
        int42_varuint32: boolean;
        int42_bool: boolean;
        int42_cell: boolean;
        int42_address: boolean;
        int42_struct: boolean;
        int256_varint16: boolean;
        int256_varint32: boolean;
        int256_varuint16: boolean;
        int256_varuint32: boolean;
        int256_bool: boolean;
        int256_cell: boolean;
        int256_address: boolean;
        int256_struct: boolean;
        uint8_varint16: boolean;
        uint8_varint32: boolean;
        uint8_varuint16: boolean;
        uint8_varuint32: boolean;
        uint8_bool: boolean;
        uint8_cell: boolean;
        uint8_address: boolean;
        uint8_struct: boolean;
        uint42_varint16: boolean;
        uint42_varint32: boolean;
        uint42_varuint16: boolean;
        uint42_varuint32: boolean;
        uint42_bool: boolean;
        uint42_cell: boolean;
        uint42_address: boolean;
        uint42_struct: boolean;
        uint256_varint16: boolean;
        uint256_varint32: boolean;
        uint256_varuint16: boolean;
        uint256_varuint32: boolean;
        uint256_bool: boolean;
        uint256_cell: boolean;
        uint256_address: boolean;
        uint256_struct: boolean;
        address_varint16: boolean;
        address_varint32: boolean;
        address_varuint16: boolean;
        address_varuint32: boolean;
        address_bool: boolean;
        address_cell: boolean;
        address_address: boolean;
        address_struct: boolean;
    }>;
    getIsEmptyAllMaps(provider: ContractProvider): Promise<{
        $$type: "IsEmptyAllMapsResult";
        int_varint16: boolean;
        int_varint32: boolean;
        int_varuint16: boolean;
        int_varuint32: boolean;
        int_bool: boolean;
        int_cell: boolean;
        int_address: boolean;
        int_struct: boolean;
        int8_varint16: boolean;
        int8_varint32: boolean;
        int8_varuint16: boolean;
        int8_varuint32: boolean;
        int8_bool: boolean;
        int8_cell: boolean;
        int8_address: boolean;
        int8_struct: boolean;
        int42_varint16: boolean;
        int42_varint32: boolean;
        int42_varuint16: boolean;
        int42_varuint32: boolean;
        int42_bool: boolean;
        int42_cell: boolean;
        int42_address: boolean;
        int42_struct: boolean;
        int256_varint16: boolean;
        int256_varint32: boolean;
        int256_varuint16: boolean;
        int256_varuint32: boolean;
        int256_bool: boolean;
        int256_cell: boolean;
        int256_address: boolean;
        int256_struct: boolean;
        uint8_varint16: boolean;
        uint8_varint32: boolean;
        uint8_varuint16: boolean;
        uint8_varuint32: boolean;
        uint8_bool: boolean;
        uint8_cell: boolean;
        uint8_address: boolean;
        uint8_struct: boolean;
        uint42_varint16: boolean;
        uint42_varint32: boolean;
        uint42_varuint16: boolean;
        uint42_varuint32: boolean;
        uint42_bool: boolean;
        uint42_cell: boolean;
        uint42_address: boolean;
        uint42_struct: boolean;
        uint256_varint16: boolean;
        uint256_varint32: boolean;
        uint256_varuint16: boolean;
        uint256_varuint32: boolean;
        uint256_bool: boolean;
        uint256_cell: boolean;
        uint256_address: boolean;
        uint256_struct: boolean;
        address_varint16: boolean;
        address_varint32: boolean;
        address_varuint16: boolean;
        address_varuint32: boolean;
        address_bool: boolean;
        address_cell: boolean;
        address_address: boolean;
        address_struct: boolean;
    }>;
    getAsCellAllMaps(provider: ContractProvider): Promise<{
        $$type: "AsCellAllMapsResult";
        int_varint16: Cell | null;
        int_varint32: Cell | null;
        int_varuint16: Cell | null;
        int_varuint32: Cell | null;
        int_bool: Cell | null;
        int_cell: Cell | null;
        int_address: Cell | null;
        int_struct: Cell | null;
        int8_varint16: Cell | null;
        int8_varint32: Cell | null;
        int8_varuint16: Cell | null;
        int8_varuint32: Cell | null;
        int8_bool: Cell | null;
        int8_cell: Cell | null;
        int8_address: Cell | null;
        int8_struct: Cell | null;
        int42_varint16: Cell | null;
        int42_varint32: Cell | null;
        int42_varuint16: Cell | null;
        int42_varuint32: Cell | null;
        int42_bool: Cell | null;
        int42_cell: Cell | null;
        int42_address: Cell | null;
        int42_struct: Cell | null;
        int256_varint16: Cell | null;
        int256_varint32: Cell | null;
        int256_varuint16: Cell | null;
        int256_varuint32: Cell | null;
        int256_bool: Cell | null;
        int256_cell: Cell | null;
        int256_address: Cell | null;
        int256_struct: Cell | null;
        uint8_varint16: Cell | null;
        uint8_varint32: Cell | null;
        uint8_varuint16: Cell | null;
        uint8_varuint32: Cell | null;
        uint8_bool: Cell | null;
        uint8_cell: Cell | null;
        uint8_address: Cell | null;
        uint8_struct: Cell | null;
        uint42_varint16: Cell | null;
        uint42_varint32: Cell | null;
        uint42_varuint16: Cell | null;
        uint42_varuint32: Cell | null;
        uint42_bool: Cell | null;
        uint42_cell: Cell | null;
        uint42_address: Cell | null;
        uint42_struct: Cell | null;
        uint256_varint16: Cell | null;
        uint256_varint32: Cell | null;
        uint256_varuint16: Cell | null;
        uint256_varuint32: Cell | null;
        uint256_bool: Cell | null;
        uint256_cell: Cell | null;
        uint256_address: Cell | null;
        uint256_struct: Cell | null;
        address_varint16: Cell | null;
        address_varint32: Cell | null;
        address_varuint16: Cell | null;
        address_varuint32: Cell | null;
        address_bool: Cell | null;
        address_cell: Cell | null;
        address_address: Cell | null;
        address_struct: Cell | null;
    }>;
    getCheckNullReference(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/maps2_MapTestContract.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/maps2_MapTestContract.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    int: bigint;
    bool: boolean;
    address: Address;
    a: bigint;
    b: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    int: bigint;
    bool: boolean;
    address: Address;
    a: bigint;
    b: bigint;
};
export type GetAllMapsResult = {
    $$type: 'GetAllMapsResult';
    int_int: bigint | null;
    int_int8: bigint | null;
    int_int42: bigint | null;
    int_int256: bigint | null;
    int_uint8: bigint | null;
    int_uint42: bigint | null;
    int_uint256: bigint | null;
    int_coins: bigint | null;
    int8_int: bigint | null;
    int8_int8: bigint | null;
    int8_int42: bigint | null;
    int8_int256: bigint | null;
    int8_uint8: bigint | null;
    int8_uint42: bigint | null;
    int8_uint256: bigint | null;
    int8_coins: bigint | null;
    int42_int: bigint | null;
    int42_int8: bigint | null;
    int42_int42: bigint | null;
    int42_int256: bigint | null;
    int42_uint8: bigint | null;
    int42_uint42: bigint | null;
    int42_uint256: bigint | null;
    int42_coins: bigint | null;
    int256_int: bigint | null;
    int256_int8: bigint | null;
    int256_int42: bigint | null;
    int256_int256: bigint | null;
    int256_uint8: bigint | null;
    int256_uint42: bigint | null;
    int256_uint256: bigint | null;
    int256_coins: bigint | null;
    uint8_int: bigint | null;
    uint8_int8: bigint | null;
    uint8_int42: bigint | null;
    uint8_int256: bigint | null;
    uint8_uint8: bigint | null;
    uint8_uint42: bigint | null;
    uint8_uint256: bigint | null;
    uint8_coins: bigint | null;
    uint42_int: bigint | null;
    uint42_int8: bigint | null;
    uint42_int42: bigint | null;
    uint42_int256: bigint | null;
    uint42_uint8: bigint | null;
    uint42_uint42: bigint | null;
    uint42_uint256: bigint | null;
    uint42_coins: bigint | null;
    uint256_int: bigint | null;
    uint256_int8: bigint | null;
    uint256_int42: bigint | null;
    uint256_int256: bigint | null;
    uint256_uint8: bigint | null;
    uint256_uint42: bigint | null;
    uint256_uint256: bigint | null;
    uint256_coins: bigint | null;
    address_int: bigint | null;
    address_int8: bigint | null;
    address_int42: bigint | null;
    address_int256: bigint | null;
    address_uint8: bigint | null;
    address_uint42: bigint | null;
    address_uint256: bigint | null;
    address_coins: bigint | null;
};
export declare function storeGetAllMapsResult(src: GetAllMapsResult): (builder: Builder) => void;
export declare function loadGetAllMapsResult(slice: Slice): {
    $$type: "GetAllMapsResult";
    int_int: bigint | null;
    int_int8: bigint | null;
    int_int42: bigint | null;
    int_int256: bigint | null;
    int_uint8: bigint | null;
    int_uint42: bigint | null;
    int_uint256: bigint | null;
    int_coins: bigint | null;
    int8_int: bigint | null;
    int8_int8: bigint | null;
    int8_int42: bigint | null;
    int8_int256: bigint | null;
    int8_uint8: bigint | null;
    int8_uint42: bigint | null;
    int8_uint256: bigint | null;
    int8_coins: bigint | null;
    int42_int: bigint | null;
    int42_int8: bigint | null;
    int42_int42: bigint | null;
    int42_int256: bigint | null;
    int42_uint8: bigint | null;
    int42_uint42: bigint | null;
    int42_uint256: bigint | null;
    int42_coins: bigint | null;
    int256_int: bigint | null;
    int256_int8: bigint | null;
    int256_int42: bigint | null;
    int256_int256: bigint | null;
    int256_uint8: bigint | null;
    int256_uint42: bigint | null;
    int256_uint256: bigint | null;
    int256_coins: bigint | null;
    uint8_int: bigint | null;
    uint8_int8: bigint | null;
    uint8_int42: bigint | null;
    uint8_int256: bigint | null;
    uint8_uint8: bigint | null;
    uint8_uint42: bigint | null;
    uint8_uint256: bigint | null;
    uint8_coins: bigint | null;
    uint42_int: bigint | null;
    uint42_int8: bigint | null;
    uint42_int42: bigint | null;
    uint42_int256: bigint | null;
    uint42_uint8: bigint | null;
    uint42_uint42: bigint | null;
    uint42_uint256: bigint | null;
    uint42_coins: bigint | null;
    uint256_int: bigint | null;
    uint256_int8: bigint | null;
    uint256_int42: bigint | null;
    uint256_int256: bigint | null;
    uint256_uint8: bigint | null;
    uint256_uint42: bigint | null;
    uint256_uint256: bigint | null;
    uint256_coins: bigint | null;
    address_int: bigint | null;
    address_int8: bigint | null;
    address_int42: bigint | null;
    address_int256: bigint | null;
    address_uint8: bigint | null;
    address_uint42: bigint | null;
    address_uint256: bigint | null;
    address_coins: bigint | null;
};
export type ReplaceAllMapsResult = {
    $$type: 'ReplaceAllMapsResult';
    int_int: boolean;
    int_int8: boolean;
    int_int42: boolean;
    int_int256: boolean;
    int_uint8: boolean;
    int_uint42: boolean;
    int_uint256: boolean;
    int_coins: boolean;
    int8_int: boolean;
    int8_int8: boolean;
    int8_int42: boolean;
    int8_int256: boolean;
    int8_uint8: boolean;
    int8_uint42: boolean;
    int8_uint256: boolean;
    int8_coins: boolean;
    int42_int: boolean;
    int42_int8: boolean;
    int42_int42: boolean;
    int42_int256: boolean;
    int42_uint8: boolean;
    int42_uint42: boolean;
    int42_uint256: boolean;
    int42_coins: boolean;
    int256_int: boolean;
    int256_int8: boolean;
    int256_int42: boolean;
    int256_int256: boolean;
    int256_uint8: boolean;
    int256_uint42: boolean;
    int256_uint256: boolean;
    int256_coins: boolean;
    uint8_int: boolean;
    uint8_int8: boolean;
    uint8_int42: boolean;
    uint8_int256: boolean;
    uint8_uint8: boolean;
    uint8_uint42: boolean;
    uint8_uint256: boolean;
    uint8_coins: boolean;
    uint42_int: boolean;
    uint42_int8: boolean;
    uint42_int42: boolean;
    uint42_int256: boolean;
    uint42_uint8: boolean;
    uint42_uint42: boolean;
    uint42_uint256: boolean;
    uint42_coins: boolean;
    uint256_int: boolean;
    uint256_int8: boolean;
    uint256_int42: boolean;
    uint256_int256: boolean;
    uint256_uint8: boolean;
    uint256_uint42: boolean;
    uint256_uint256: boolean;
    uint256_coins: boolean;
    address_int: boolean;
    address_int8: boolean;
    address_int42: boolean;
    address_int256: boolean;
    address_uint8: boolean;
    address_uint42: boolean;
    address_uint256: boolean;
    address_coins: boolean;
};
export declare function storeReplaceAllMapsResult(src: ReplaceAllMapsResult): (builder: Builder) => void;
export declare function loadReplaceAllMapsResult(slice: Slice): {
    $$type: "ReplaceAllMapsResult";
    int_int: boolean;
    int_int8: boolean;
    int_int42: boolean;
    int_int256: boolean;
    int_uint8: boolean;
    int_uint42: boolean;
    int_uint256: boolean;
    int_coins: boolean;
    int8_int: boolean;
    int8_int8: boolean;
    int8_int42: boolean;
    int8_int256: boolean;
    int8_uint8: boolean;
    int8_uint42: boolean;
    int8_uint256: boolean;
    int8_coins: boolean;
    int42_int: boolean;
    int42_int8: boolean;
    int42_int42: boolean;
    int42_int256: boolean;
    int42_uint8: boolean;
    int42_uint42: boolean;
    int42_uint256: boolean;
    int42_coins: boolean;
    int256_int: boolean;
    int256_int8: boolean;
    int256_int42: boolean;
    int256_int256: boolean;
    int256_uint8: boolean;
    int256_uint42: boolean;
    int256_uint256: boolean;
    int256_coins: boolean;
    uint8_int: boolean;
    uint8_int8: boolean;
    uint8_int42: boolean;
    uint8_int256: boolean;
    uint8_uint8: boolean;
    uint8_uint42: boolean;
    uint8_uint256: boolean;
    uint8_coins: boolean;
    uint42_int: boolean;
    uint42_int8: boolean;
    uint42_int42: boolean;
    uint42_int256: boolean;
    uint42_uint8: boolean;
    uint42_uint42: boolean;
    uint42_uint256: boolean;
    uint42_coins: boolean;
    uint256_int: boolean;
    uint256_int8: boolean;
    uint256_int42: boolean;
    uint256_int256: boolean;
    uint256_uint8: boolean;
    uint256_uint42: boolean;
    uint256_uint256: boolean;
    uint256_coins: boolean;
    address_int: boolean;
    address_int8: boolean;
    address_int42: boolean;
    address_int256: boolean;
    address_uint8: boolean;
    address_uint42: boolean;
    address_uint256: boolean;
    address_coins: boolean;
};
export type ReplaceGetAllMapsResult = {
    $$type: 'ReplaceGetAllMapsResult';
    int_int: bigint | null;
    int_int8: bigint | null;
    int_int42: bigint | null;
    int_int256: bigint | null;
    int_uint8: bigint | null;
    int_uint42: bigint | null;
    int_uint256: bigint | null;
    int_coins: bigint | null;
    int8_int: bigint | null;
    int8_int8: bigint | null;
    int8_int42: bigint | null;
    int8_int256: bigint | null;
    int8_uint8: bigint | null;
    int8_uint42: bigint | null;
    int8_uint256: bigint | null;
    int8_coins: bigint | null;
    int42_int: bigint | null;
    int42_int8: bigint | null;
    int42_int42: bigint | null;
    int42_int256: bigint | null;
    int42_uint8: bigint | null;
    int42_uint42: bigint | null;
    int42_uint256: bigint | null;
    int42_coins: bigint | null;
    int256_int: bigint | null;
    int256_int8: bigint | null;
    int256_int42: bigint | null;
    int256_int256: bigint | null;
    int256_uint8: bigint | null;
    int256_uint42: bigint | null;
    int256_uint256: bigint | null;
    int256_coins: bigint | null;
    uint8_int: bigint | null;
    uint8_int8: bigint | null;
    uint8_int42: bigint | null;
    uint8_int256: bigint | null;
    uint8_uint8: bigint | null;
    uint8_uint42: bigint | null;
    uint8_uint256: bigint | null;
    uint8_coins: bigint | null;
    uint42_int: bigint | null;
    uint42_int8: bigint | null;
    uint42_int42: bigint | null;
    uint42_int256: bigint | null;
    uint42_uint8: bigint | null;
    uint42_uint42: bigint | null;
    uint42_uint256: bigint | null;
    uint42_coins: bigint | null;
    uint256_int: bigint | null;
    uint256_int8: bigint | null;
    uint256_int42: bigint | null;
    uint256_int256: bigint | null;
    uint256_uint8: bigint | null;
    uint256_uint42: bigint | null;
    uint256_uint256: bigint | null;
    uint256_coins: bigint | null;
    address_int: bigint | null;
    address_int8: bigint | null;
    address_int42: bigint | null;
    address_int256: bigint | null;
    address_uint8: bigint | null;
    address_uint42: bigint | null;
    address_uint256: bigint | null;
    address_coins: bigint | null;
};
export declare function storeReplaceGetAllMapsResult(src: ReplaceGetAllMapsResult): (builder: Builder) => void;
export declare function loadReplaceGetAllMapsResult(slice: Slice): {
    $$type: "ReplaceGetAllMapsResult";
    int_int: bigint | null;
    int_int8: bigint | null;
    int_int42: bigint | null;
    int_int256: bigint | null;
    int_uint8: bigint | null;
    int_uint42: bigint | null;
    int_uint256: bigint | null;
    int_coins: bigint | null;
    int8_int: bigint | null;
    int8_int8: bigint | null;
    int8_int42: bigint | null;
    int8_int256: bigint | null;
    int8_uint8: bigint | null;
    int8_uint42: bigint | null;
    int8_uint256: bigint | null;
    int8_coins: bigint | null;
    int42_int: bigint | null;
    int42_int8: bigint | null;
    int42_int42: bigint | null;
    int42_int256: bigint | null;
    int42_uint8: bigint | null;
    int42_uint42: bigint | null;
    int42_uint256: bigint | null;
    int42_coins: bigint | null;
    int256_int: bigint | null;
    int256_int8: bigint | null;
    int256_int42: bigint | null;
    int256_int256: bigint | null;
    int256_uint8: bigint | null;
    int256_uint42: bigint | null;
    int256_uint256: bigint | null;
    int256_coins: bigint | null;
    uint8_int: bigint | null;
    uint8_int8: bigint | null;
    uint8_int42: bigint | null;
    uint8_int256: bigint | null;
    uint8_uint8: bigint | null;
    uint8_uint42: bigint | null;
    uint8_uint256: bigint | null;
    uint8_coins: bigint | null;
    uint42_int: bigint | null;
    uint42_int8: bigint | null;
    uint42_int42: bigint | null;
    uint42_int256: bigint | null;
    uint42_uint8: bigint | null;
    uint42_uint42: bigint | null;
    uint42_uint256: bigint | null;
    uint42_coins: bigint | null;
    uint256_int: bigint | null;
    uint256_int8: bigint | null;
    uint256_int42: bigint | null;
    uint256_int256: bigint | null;
    uint256_uint8: bigint | null;
    uint256_uint42: bigint | null;
    uint256_uint256: bigint | null;
    uint256_coins: bigint | null;
    address_int: bigint | null;
    address_int8: bigint | null;
    address_int42: bigint | null;
    address_int256: bigint | null;
    address_uint8: bigint | null;
    address_uint42: bigint | null;
    address_uint256: bigint | null;
    address_coins: bigint | null;
};
export type ExistsAllMapsResult = {
    $$type: 'ExistsAllMapsResult';
    int_int: boolean;
    int_int8: boolean;
    int_int42: boolean;
    int_int256: boolean;
    int_uint8: boolean;
    int_uint42: boolean;
    int_uint256: boolean;
    int_coins: boolean;
    int8_int: boolean;
    int8_int8: boolean;
    int8_int42: boolean;
    int8_int256: boolean;
    int8_uint8: boolean;
    int8_uint42: boolean;
    int8_uint256: boolean;
    int8_coins: boolean;
    int42_int: boolean;
    int42_int8: boolean;
    int42_int42: boolean;
    int42_int256: boolean;
    int42_uint8: boolean;
    int42_uint42: boolean;
    int42_uint256: boolean;
    int42_coins: boolean;
    int256_int: boolean;
    int256_int8: boolean;
    int256_int42: boolean;
    int256_int256: boolean;
    int256_uint8: boolean;
    int256_uint42: boolean;
    int256_uint256: boolean;
    int256_coins: boolean;
    uint8_int: boolean;
    uint8_int8: boolean;
    uint8_int42: boolean;
    uint8_int256: boolean;
    uint8_uint8: boolean;
    uint8_uint42: boolean;
    uint8_uint256: boolean;
    uint8_coins: boolean;
    uint42_int: boolean;
    uint42_int8: boolean;
    uint42_int42: boolean;
    uint42_int256: boolean;
    uint42_uint8: boolean;
    uint42_uint42: boolean;
    uint42_uint256: boolean;
    uint42_coins: boolean;
    uint256_int: boolean;
    uint256_int8: boolean;
    uint256_int42: boolean;
    uint256_int256: boolean;
    uint256_uint8: boolean;
    uint256_uint42: boolean;
    uint256_uint256: boolean;
    uint256_coins: boolean;
    address_int: boolean;
    address_int8: boolean;
    address_int42: boolean;
    address_int256: boolean;
    address_uint8: boolean;
    address_uint42: boolean;
    address_uint256: boolean;
    address_coins: boolean;
};
export declare function storeExistsAllMapsResult(src: ExistsAllMapsResult): (builder: Builder) => void;
export declare function loadExistsAllMapsResult(slice: Slice): {
    $$type: "ExistsAllMapsResult";
    int_int: boolean;
    int_int8: boolean;
    int_int42: boolean;
    int_int256: boolean;
    int_uint8: boolean;
    int_uint42: boolean;
    int_uint256: boolean;
    int_coins: boolean;
    int8_int: boolean;
    int8_int8: boolean;
    int8_int42: boolean;
    int8_int256: boolean;
    int8_uint8: boolean;
    int8_uint42: boolean;
    int8_uint256: boolean;
    int8_coins: boolean;
    int42_int: boolean;
    int42_int8: boolean;
    int42_int42: boolean;
    int42_int256: boolean;
    int42_uint8: boolean;
    int42_uint42: boolean;
    int42_uint256: boolean;
    int42_coins: boolean;
    int256_int: boolean;
    int256_int8: boolean;
    int256_int42: boolean;
    int256_int256: boolean;
    int256_uint8: boolean;
    int256_uint42: boolean;
    int256_uint256: boolean;
    int256_coins: boolean;
    uint8_int: boolean;
    uint8_int8: boolean;
    uint8_int42: boolean;
    uint8_int256: boolean;
    uint8_uint8: boolean;
    uint8_uint42: boolean;
    uint8_uint256: boolean;
    uint8_coins: boolean;
    uint42_int: boolean;
    uint42_int8: boolean;
    uint42_int42: boolean;
    uint42_int256: boolean;
    uint42_uint8: boolean;
    uint42_uint42: boolean;
    uint42_uint256: boolean;
    uint42_coins: boolean;
    uint256_int: boolean;
    uint256_int8: boolean;
    uint256_int42: boolean;
    uint256_int256: boolean;
    uint256_uint8: boolean;
    uint256_uint42: boolean;
    uint256_uint256: boolean;
    uint256_coins: boolean;
    address_int: boolean;
    address_int8: boolean;
    address_int42: boolean;
    address_int256: boolean;
    address_uint8: boolean;
    address_uint42: boolean;
    address_uint256: boolean;
    address_coins: boolean;
};
export type IsEmptyAllMapsResult = {
    $$type: 'IsEmptyAllMapsResult';
    int_int: boolean;
    int_int8: boolean;
    int_int42: boolean;
    int_int256: boolean;
    int_uint8: boolean;
    int_uint42: boolean;
    int_uint256: boolean;
    int_coins: boolean;
    int8_int: boolean;
    int8_int8: boolean;
    int8_int42: boolean;
    int8_int256: boolean;
    int8_uint8: boolean;
    int8_uint42: boolean;
    int8_uint256: boolean;
    int8_coins: boolean;
    int42_int: boolean;
    int42_int8: boolean;
    int42_int42: boolean;
    int42_int256: boolean;
    int42_uint8: boolean;
    int42_uint42: boolean;
    int42_uint256: boolean;
    int42_coins: boolean;
    int256_int: boolean;
    int256_int8: boolean;
    int256_int42: boolean;
    int256_int256: boolean;
    int256_uint8: boolean;
    int256_uint42: boolean;
    int256_uint256: boolean;
    int256_coins: boolean;
    uint8_int: boolean;
    uint8_int8: boolean;
    uint8_int42: boolean;
    uint8_int256: boolean;
    uint8_uint8: boolean;
    uint8_uint42: boolean;
    uint8_uint256: boolean;
    uint8_coins: boolean;
    uint42_int: boolean;
    uint42_int8: boolean;
    uint42_int42: boolean;
    uint42_int256: boolean;
    uint42_uint8: boolean;
    uint42_uint42: boolean;
    uint42_uint256: boolean;
    uint42_coins: boolean;
    uint256_int: boolean;
    uint256_int8: boolean;
    uint256_int42: boolean;
    uint256_int256: boolean;
    uint256_uint8: boolean;
    uint256_uint42: boolean;
    uint256_uint256: boolean;
    uint256_coins: boolean;
    address_int: boolean;
    address_int8: boolean;
    address_int42: boolean;
    address_int256: boolean;
    address_uint8: boolean;
    address_uint42: boolean;
    address_uint256: boolean;
    address_coins: boolean;
};
export declare function storeIsEmptyAllMapsResult(src: IsEmptyAllMapsResult): (builder: Builder) => void;
export declare function loadIsEmptyAllMapsResult(slice: Slice): {
    $$type: "IsEmptyAllMapsResult";
    int_int: boolean;
    int_int8: boolean;
    int_int42: boolean;
    int_int256: boolean;
    int_uint8: boolean;
    int_uint42: boolean;
    int_uint256: boolean;
    int_coins: boolean;
    int8_int: boolean;
    int8_int8: boolean;
    int8_int42: boolean;
    int8_int256: boolean;
    int8_uint8: boolean;
    int8_uint42: boolean;
    int8_uint256: boolean;
    int8_coins: boolean;
    int42_int: boolean;
    int42_int8: boolean;
    int42_int42: boolean;
    int42_int256: boolean;
    int42_uint8: boolean;
    int42_uint42: boolean;
    int42_uint256: boolean;
    int42_coins: boolean;
    int256_int: boolean;
    int256_int8: boolean;
    int256_int42: boolean;
    int256_int256: boolean;
    int256_uint8: boolean;
    int256_uint42: boolean;
    int256_uint256: boolean;
    int256_coins: boolean;
    uint8_int: boolean;
    uint8_int8: boolean;
    uint8_int42: boolean;
    uint8_int256: boolean;
    uint8_uint8: boolean;
    uint8_uint42: boolean;
    uint8_uint256: boolean;
    uint8_coins: boolean;
    uint42_int: boolean;
    uint42_int8: boolean;
    uint42_int42: boolean;
    uint42_int256: boolean;
    uint42_uint8: boolean;
    uint42_uint42: boolean;
    uint42_uint256: boolean;
    uint42_coins: boolean;
    uint256_int: boolean;
    uint256_int8: boolean;
    uint256_int42: boolean;
    uint256_int256: boolean;
    uint256_uint8: boolean;
    uint256_uint42: boolean;
    uint256_uint256: boolean;
    uint256_coins: boolean;
    address_int: boolean;
    address_int8: boolean;
    address_int42: boolean;
    address_int256: boolean;
    address_uint8: boolean;
    address_uint42: boolean;
    address_uint256: boolean;
    address_coins: boolean;
};
export type AsCellAllMapsResult = {
    $$type: 'AsCellAllMapsResult';
    int_int: Cell | null;
    int_int8: Cell | null;
    int_int42: Cell | null;
    int_int256: Cell | null;
    int_uint8: Cell | null;
    int_uint42: Cell | null;
    int_uint256: Cell | null;
    int_coins: Cell | null;
    int8_int: Cell | null;
    int8_int8: Cell | null;
    int8_int42: Cell | null;
    int8_int256: Cell | null;
    int8_uint8: Cell | null;
    int8_uint42: Cell | null;
    int8_uint256: Cell | null;
    int8_coins: Cell | null;
    int42_int: Cell | null;
    int42_int8: Cell | null;
    int42_int42: Cell | null;
    int42_int256: Cell | null;
    int42_uint8: Cell | null;
    int42_uint42: Cell | null;
    int42_uint256: Cell | null;
    int42_coins: Cell | null;
    int256_int: Cell | null;
    int256_int8: Cell | null;
    int256_int42: Cell | null;
    int256_int256: Cell | null;
    int256_uint8: Cell | null;
    int256_uint42: Cell | null;
    int256_uint256: Cell | null;
    int256_coins: Cell | null;
    uint8_int: Cell | null;
    uint8_int8: Cell | null;
    uint8_int42: Cell | null;
    uint8_int256: Cell | null;
    uint8_uint8: Cell | null;
    uint8_uint42: Cell | null;
    uint8_uint256: Cell | null;
    uint8_coins: Cell | null;
    uint42_int: Cell | null;
    uint42_int8: Cell | null;
    uint42_int42: Cell | null;
    uint42_int256: Cell | null;
    uint42_uint8: Cell | null;
    uint42_uint42: Cell | null;
    uint42_uint256: Cell | null;
    uint42_coins: Cell | null;
    uint256_int: Cell | null;
    uint256_int8: Cell | null;
    uint256_int42: Cell | null;
    uint256_int256: Cell | null;
    uint256_uint8: Cell | null;
    uint256_uint42: Cell | null;
    uint256_uint256: Cell | null;
    uint256_coins: Cell | null;
    address_int: Cell | null;
    address_int8: Cell | null;
    address_int42: Cell | null;
    address_int256: Cell | null;
    address_uint8: Cell | null;
    address_uint42: Cell | null;
    address_uint256: Cell | null;
    address_coins: Cell | null;
};
export declare function storeAsCellAllMapsResult(src: AsCellAllMapsResult): (builder: Builder) => void;
export declare function loadAsCellAllMapsResult(slice: Slice): {
    $$type: "AsCellAllMapsResult";
    int_int: Cell | null;
    int_int8: Cell | null;
    int_int42: Cell | null;
    int_int256: Cell | null;
    int_uint8: Cell | null;
    int_uint42: Cell | null;
    int_uint256: Cell | null;
    int_coins: Cell | null;
    int8_int: Cell | null;
    int8_int8: Cell | null;
    int8_int42: Cell | null;
    int8_int256: Cell | null;
    int8_uint8: Cell | null;
    int8_uint42: Cell | null;
    int8_uint256: Cell | null;
    int8_coins: Cell | null;
    int42_int: Cell | null;
    int42_int8: Cell | null;
    int42_int42: Cell | null;
    int42_int256: Cell | null;
    int42_uint8: Cell | null;
    int42_uint42: Cell | null;
    int42_uint256: Cell | null;
    int42_coins: Cell | null;
    int256_int: Cell | null;
    int256_int8: Cell | null;
    int256_int42: Cell | null;
    int256_int256: Cell | null;
    int256_uint8: Cell | null;
    int256_uint42: Cell | null;
    int256_uint256: Cell | null;
    int256_coins: Cell | null;
    uint8_int: Cell | null;
    uint8_int8: Cell | null;
    uint8_int42: Cell | null;
    uint8_int256: Cell | null;
    uint8_uint8: Cell | null;
    uint8_uint42: Cell | null;
    uint8_uint256: Cell | null;
    uint8_coins: Cell | null;
    uint42_int: Cell | null;
    uint42_int8: Cell | null;
    uint42_int42: Cell | null;
    uint42_int256: Cell | null;
    uint42_uint8: Cell | null;
    uint42_uint42: Cell | null;
    uint42_uint256: Cell | null;
    uint42_coins: Cell | null;
    uint256_int: Cell | null;
    uint256_int8: Cell | null;
    uint256_int42: Cell | null;
    uint256_int256: Cell | null;
    uint256_uint8: Cell | null;
    uint256_uint42: Cell | null;
    uint256_uint256: Cell | null;
    uint256_coins: Cell | null;
    address_int: Cell | null;
    address_int8: Cell | null;
    address_int42: Cell | null;
    address_int256: Cell | null;
    address_uint8: Cell | null;
    address_uint42: Cell | null;
    address_uint256: Cell | null;
    address_coins: Cell | null;
};
export type SetAllMaps = {
    $$type: 'SetAllMaps';
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueInt: bigint | null;
    valueInt8: bigint | null;
    valueInt42: bigint | null;
    valueInt256: bigint | null;
    valueUint8: bigint | null;
    valueUint42: bigint | null;
    valueUint256: bigint | null;
    valueCoins: bigint | null;
};
export declare function storeSetAllMaps(src: SetAllMaps): (builder: Builder) => void;
export declare function loadSetAllMaps(slice: Slice): {
    $$type: "SetAllMaps";
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueInt: bigint | null;
    valueInt8: bigint | null;
    valueInt42: bigint | null;
    valueInt256: bigint | null;
    valueUint8: bigint | null;
    valueUint42: bigint | null;
    valueUint256: bigint | null;
    valueCoins: bigint | null;
};
export type DelAllMaps = {
    $$type: 'DelAllMaps';
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
};
export declare function storeDelAllMaps(src: DelAllMaps): (builder: Builder) => void;
export declare function loadDelAllMaps(slice: Slice): {
    $$type: "DelAllMaps";
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
};
export type ReplaceAllMaps = {
    $$type: 'ReplaceAllMaps';
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueInt: bigint | null;
    valueInt8: bigint | null;
    valueInt42: bigint | null;
    valueInt256: bigint | null;
    valueUint8: bigint | null;
    valueUint42: bigint | null;
    valueUint256: bigint | null;
    valueCoins: bigint | null;
};
export declare function storeReplaceAllMaps(src: ReplaceAllMaps): (builder: Builder) => void;
export declare function loadReplaceAllMaps(slice: Slice): {
    $$type: "ReplaceAllMaps";
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueInt: bigint | null;
    valueInt8: bigint | null;
    valueInt42: bigint | null;
    valueInt256: bigint | null;
    valueUint8: bigint | null;
    valueUint42: bigint | null;
    valueUint256: bigint | null;
    valueCoins: bigint | null;
};
export type ReplaceGetAllMaps = {
    $$type: 'ReplaceGetAllMaps';
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueInt: bigint | null;
    valueInt8: bigint | null;
    valueInt42: bigint | null;
    valueInt256: bigint | null;
    valueUint8: bigint | null;
    valueUint42: bigint | null;
    valueUint256: bigint | null;
    valueCoins: bigint | null;
};
export declare function storeReplaceGetAllMaps(src: ReplaceGetAllMaps): (builder: Builder) => void;
export declare function loadReplaceGetAllMaps(slice: Slice): {
    $$type: "ReplaceGetAllMaps";
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
    valueInt: bigint | null;
    valueInt8: bigint | null;
    valueInt42: bigint | null;
    valueInt256: bigint | null;
    valueUint8: bigint | null;
    valueUint42: bigint | null;
    valueUint256: bigint | null;
    valueCoins: bigint | null;
};
export type CheckNullReference = {
    $$type: 'CheckNullReference';
};
export declare function storeCheckNullReference(src: CheckNullReference): (builder: Builder) => void;
export declare function loadCheckNullReference(slice: Slice): {
    $$type: "CheckNullReference";
};
export type MapTestContract$Data = {
    $$type: 'MapTestContract$Data';
    int_int: Dictionary<bigint, bigint>;
    int_int8: Dictionary<bigint, number>;
    int_int42: Dictionary<bigint, bigint>;
    int_int256: Dictionary<bigint, bigint>;
    int_uint8: Dictionary<bigint, number>;
    int_uint42: Dictionary<bigint, bigint>;
    int_uint256: Dictionary<bigint, bigint>;
    int_coins: Dictionary<bigint, bigint>;
    int8_int: Dictionary<number, bigint>;
    int8_int8: Dictionary<number, number>;
    int8_int42: Dictionary<number, bigint>;
    int8_int256: Dictionary<number, bigint>;
    int8_uint8: Dictionary<number, number>;
    int8_uint42: Dictionary<number, bigint>;
    int8_uint256: Dictionary<number, bigint>;
    int8_coins: Dictionary<number, bigint>;
    int42_int: Dictionary<bigint, bigint>;
    int42_int8: Dictionary<bigint, number>;
    int42_int42: Dictionary<bigint, bigint>;
    int42_int256: Dictionary<bigint, bigint>;
    int42_uint8: Dictionary<bigint, number>;
    int42_uint42: Dictionary<bigint, bigint>;
    int42_uint256: Dictionary<bigint, bigint>;
    int42_coins: Dictionary<bigint, bigint>;
    int256_int: Dictionary<bigint, bigint>;
    int256_int8: Dictionary<bigint, number>;
    int256_int42: Dictionary<bigint, bigint>;
    int256_int256: Dictionary<bigint, bigint>;
    int256_uint8: Dictionary<bigint, number>;
    int256_uint42: Dictionary<bigint, bigint>;
    int256_uint256: Dictionary<bigint, bigint>;
    int256_coins: Dictionary<bigint, bigint>;
    uint8_int: Dictionary<number, bigint>;
    uint8_int8: Dictionary<number, number>;
    uint8_int42: Dictionary<number, bigint>;
    uint8_int256: Dictionary<number, bigint>;
    uint8_uint8: Dictionary<number, number>;
    uint8_uint42: Dictionary<number, bigint>;
    uint8_uint256: Dictionary<number, bigint>;
    uint8_coins: Dictionary<number, bigint>;
    uint42_int: Dictionary<bigint, bigint>;
    uint42_int8: Dictionary<bigint, number>;
    uint42_int42: Dictionary<bigint, bigint>;
    uint42_int256: Dictionary<bigint, bigint>;
    uint42_uint8: Dictionary<bigint, number>;
    uint42_uint42: Dictionary<bigint, bigint>;
    uint42_uint256: Dictionary<bigint, bigint>;
    uint42_coins: Dictionary<bigint, bigint>;
    uint256_int: Dictionary<bigint, bigint>;
    uint256_int8: Dictionary<bigint, number>;
    uint256_int42: Dictionary<bigint, bigint>;
    uint256_int256: Dictionary<bigint, bigint>;
    uint256_uint8: Dictionary<bigint, number>;
    uint256_uint42: Dictionary<bigint, bigint>;
    uint256_uint256: Dictionary<bigint, bigint>;
    uint256_coins: Dictionary<bigint, bigint>;
    address_int: Dictionary<Address, bigint>;
    address_int8: Dictionary<Address, number>;
    address_int42: Dictionary<Address, bigint>;
    address_int256: Dictionary<Address, bigint>;
    address_uint8: Dictionary<Address, number>;
    address_uint42: Dictionary<Address, bigint>;
    address_uint256: Dictionary<Address, bigint>;
    address_coins: Dictionary<Address, bigint>;
};
export declare function storeMapTestContract$Data(src: MapTestContract$Data): (builder: Builder) => void;
export declare function loadMapTestContract$Data(slice: Slice): {
    $$type: "MapTestContract$Data";
    int_int: Dictionary<bigint, bigint>;
    int_int8: Dictionary<bigint, number>;
    int_int42: Dictionary<bigint, bigint>;
    int_int256: Dictionary<bigint, bigint>;
    int_uint8: Dictionary<bigint, number>;
    int_uint42: Dictionary<bigint, bigint>;
    int_uint256: Dictionary<bigint, bigint>;
    int_coins: Dictionary<bigint, bigint>;
    int8_int: Dictionary<number, bigint>;
    int8_int8: Dictionary<number, number>;
    int8_int42: Dictionary<number, bigint>;
    int8_int256: Dictionary<number, bigint>;
    int8_uint8: Dictionary<number, number>;
    int8_uint42: Dictionary<number, bigint>;
    int8_uint256: Dictionary<number, bigint>;
    int8_coins: Dictionary<number, bigint>;
    int42_int: Dictionary<bigint, bigint>;
    int42_int8: Dictionary<bigint, number>;
    int42_int42: Dictionary<bigint, bigint>;
    int42_int256: Dictionary<bigint, bigint>;
    int42_uint8: Dictionary<bigint, number>;
    int42_uint42: Dictionary<bigint, bigint>;
    int42_uint256: Dictionary<bigint, bigint>;
    int42_coins: Dictionary<bigint, bigint>;
    int256_int: Dictionary<bigint, bigint>;
    int256_int8: Dictionary<bigint, number>;
    int256_int42: Dictionary<bigint, bigint>;
    int256_int256: Dictionary<bigint, bigint>;
    int256_uint8: Dictionary<bigint, number>;
    int256_uint42: Dictionary<bigint, bigint>;
    int256_uint256: Dictionary<bigint, bigint>;
    int256_coins: Dictionary<bigint, bigint>;
    uint8_int: Dictionary<number, bigint>;
    uint8_int8: Dictionary<number, number>;
    uint8_int42: Dictionary<number, bigint>;
    uint8_int256: Dictionary<number, bigint>;
    uint8_uint8: Dictionary<number, number>;
    uint8_uint42: Dictionary<number, bigint>;
    uint8_uint256: Dictionary<number, bigint>;
    uint8_coins: Dictionary<number, bigint>;
    uint42_int: Dictionary<bigint, bigint>;
    uint42_int8: Dictionary<bigint, number>;
    uint42_int42: Dictionary<bigint, bigint>;
    uint42_int256: Dictionary<bigint, bigint>;
    uint42_uint8: Dictionary<bigint, number>;
    uint42_uint42: Dictionary<bigint, bigint>;
    uint42_uint256: Dictionary<bigint, bigint>;
    uint42_coins: Dictionary<bigint, bigint>;
    uint256_int: Dictionary<bigint, bigint>;
    uint256_int8: Dictionary<bigint, number>;
    uint256_int42: Dictionary<bigint, bigint>;
    uint256_int256: Dictionary<bigint, bigint>;
    uint256_uint8: Dictionary<bigint, number>;
    uint256_uint42: Dictionary<bigint, bigint>;
    uint256_uint256: Dictionary<bigint, bigint>;
    uint256_coins: Dictionary<bigint, bigint>;
    address_int: Dictionary<Address, bigint>;
    address_int8: Dictionary<Address, number>;
    address_int42: Dictionary<Address, bigint>;
    address_int256: Dictionary<Address, bigint>;
    address_uint8: Dictionary<Address, number>;
    address_uint42: Dictionary<Address, bigint>;
    address_uint256: Dictionary<Address, bigint>;
    address_coins: Dictionary<Address, bigint>;
};
export declare const MapTestContract_getterMapping: {
    [key: string]: string;
};
export declare class MapTestContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapTestContract>;
    static fromAddress(address: Address): MapTestContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | SetAllMaps | DelAllMaps | ReplaceAllMaps | ReplaceGetAllMaps | CheckNullReference): Promise<void>;
    getAllMaps(provider: ContractProvider): Promise<{
        $$type: "MapTestContract$Data";
        int_int: Dictionary<bigint, bigint>;
        int_int8: Dictionary<bigint, number>;
        int_int42: Dictionary<bigint, bigint>;
        int_int256: Dictionary<bigint, bigint>;
        int_uint8: Dictionary<bigint, number>;
        int_uint42: Dictionary<bigint, bigint>;
        int_uint256: Dictionary<bigint, bigint>;
        int_coins: Dictionary<bigint, bigint>;
        int8_int: Dictionary<number, bigint>;
        int8_int8: Dictionary<number, number>;
        int8_int42: Dictionary<number, bigint>;
        int8_int256: Dictionary<number, bigint>;
        int8_uint8: Dictionary<number, number>;
        int8_uint42: Dictionary<number, bigint>;
        int8_uint256: Dictionary<number, bigint>;
        int8_coins: Dictionary<number, bigint>;
        int42_int: Dictionary<bigint, bigint>;
        int42_int8: Dictionary<bigint, number>;
        int42_int42: Dictionary<bigint, bigint>;
        int42_int256: Dictionary<bigint, bigint>;
        int42_uint8: Dictionary<bigint, number>;
        int42_uint42: Dictionary<bigint, bigint>;
        int42_uint256: Dictionary<bigint, bigint>;
        int42_coins: Dictionary<bigint, bigint>;
        int256_int: Dictionary<bigint, bigint>;
        int256_int8: Dictionary<bigint, number>;
        int256_int42: Dictionary<bigint, bigint>;
        int256_int256: Dictionary<bigint, bigint>;
        int256_uint8: Dictionary<bigint, number>;
        int256_uint42: Dictionary<bigint, bigint>;
        int256_uint256: Dictionary<bigint, bigint>;
        int256_coins: Dictionary<bigint, bigint>;
        uint8_int: Dictionary<number, bigint>;
        uint8_int8: Dictionary<number, number>;
        uint8_int42: Dictionary<number, bigint>;
        uint8_int256: Dictionary<number, bigint>;
        uint8_uint8: Dictionary<number, number>;
        uint8_uint42: Dictionary<number, bigint>;
        uint8_uint256: Dictionary<number, bigint>;
        uint8_coins: Dictionary<number, bigint>;
        uint42_int: Dictionary<bigint, bigint>;
        uint42_int8: Dictionary<bigint, number>;
        uint42_int42: Dictionary<bigint, bigint>;
        uint42_int256: Dictionary<bigint, bigint>;
        uint42_uint8: Dictionary<bigint, number>;
        uint42_uint42: Dictionary<bigint, bigint>;
        uint42_uint256: Dictionary<bigint, bigint>;
        uint42_coins: Dictionary<bigint, bigint>;
        uint256_int: Dictionary<bigint, bigint>;
        uint256_int8: Dictionary<bigint, number>;
        uint256_int42: Dictionary<bigint, bigint>;
        uint256_int256: Dictionary<bigint, bigint>;
        uint256_uint8: Dictionary<bigint, number>;
        uint256_uint42: Dictionary<bigint, bigint>;
        uint256_uint256: Dictionary<bigint, bigint>;
        uint256_coins: Dictionary<bigint, bigint>;
        address_int: Dictionary<Address, bigint>;
        address_int8: Dictionary<Address, number>;
        address_int42: Dictionary<Address, bigint>;
        address_int256: Dictionary<Address, bigint>;
        address_uint8: Dictionary<Address, number>;
        address_uint42: Dictionary<Address, bigint>;
        address_uint256: Dictionary<Address, bigint>;
        address_coins: Dictionary<Address, bigint>;
    }>;
    getGetAllMaps(provider: ContractProvider, keyInt: bigint, keyInt8: bigint, keyInt42: bigint, keyInt256: bigint, keyUint8: bigint, keyUint42: bigint, keyUint256: bigint, keyAddress: Address): Promise<{
        $$type: "GetAllMapsResult";
        int_int: bigint | null;
        int_int8: bigint | null;
        int_int42: bigint | null;
        int_int256: bigint | null;
        int_uint8: bigint | null;
        int_uint42: bigint | null;
        int_uint256: bigint | null;
        int_coins: bigint | null;
        int8_int: bigint | null;
        int8_int8: bigint | null;
        int8_int42: bigint | null;
        int8_int256: bigint | null;
        int8_uint8: bigint | null;
        int8_uint42: bigint | null;
        int8_uint256: bigint | null;
        int8_coins: bigint | null;
        int42_int: bigint | null;
        int42_int8: bigint | null;
        int42_int42: bigint | null;
        int42_int256: bigint | null;
        int42_uint8: bigint | null;
        int42_uint42: bigint | null;
        int42_uint256: bigint | null;
        int42_coins: bigint | null;
        int256_int: bigint | null;
        int256_int8: bigint | null;
        int256_int42: bigint | null;
        int256_int256: bigint | null;
        int256_uint8: bigint | null;
        int256_uint42: bigint | null;
        int256_uint256: bigint | null;
        int256_coins: bigint | null;
        uint8_int: bigint | null;
        uint8_int8: bigint | null;
        uint8_int42: bigint | null;
        uint8_int256: bigint | null;
        uint8_uint8: bigint | null;
        uint8_uint42: bigint | null;
        uint8_uint256: bigint | null;
        uint8_coins: bigint | null;
        uint42_int: bigint | null;
        uint42_int8: bigint | null;
        uint42_int42: bigint | null;
        uint42_int256: bigint | null;
        uint42_uint8: bigint | null;
        uint42_uint42: bigint | null;
        uint42_uint256: bigint | null;
        uint42_coins: bigint | null;
        uint256_int: bigint | null;
        uint256_int8: bigint | null;
        uint256_int42: bigint | null;
        uint256_int256: bigint | null;
        uint256_uint8: bigint | null;
        uint256_uint42: bigint | null;
        uint256_uint256: bigint | null;
        uint256_coins: bigint | null;
        address_int: bigint | null;
        address_int8: bigint | null;
        address_int42: bigint | null;
        address_int256: bigint | null;
        address_uint8: bigint | null;
        address_uint42: bigint | null;
        address_uint256: bigint | null;
        address_coins: bigint | null;
    }>;
    getReplaceAllMaps(provider: ContractProvider, keyInt: bigint, keyInt8: bigint, keyInt42: bigint, keyInt256: bigint, keyUint8: bigint, keyUint42: bigint, keyUint256: bigint, keyAddress: Address, valueInt: bigint, valueInt8: bigint, valueInt42: bigint, valueInt256: bigint, valueUint8: bigint, valueUint42: bigint, valueUint256: bigint, valueCoins: bigint): Promise<{
        $$type: "ReplaceAllMapsResult";
        int_int: boolean;
        int_int8: boolean;
        int_int42: boolean;
        int_int256: boolean;
        int_uint8: boolean;
        int_uint42: boolean;
        int_uint256: boolean;
        int_coins: boolean;
        int8_int: boolean;
        int8_int8: boolean;
        int8_int42: boolean;
        int8_int256: boolean;
        int8_uint8: boolean;
        int8_uint42: boolean;
        int8_uint256: boolean;
        int8_coins: boolean;
        int42_int: boolean;
        int42_int8: boolean;
        int42_int42: boolean;
        int42_int256: boolean;
        int42_uint8: boolean;
        int42_uint42: boolean;
        int42_uint256: boolean;
        int42_coins: boolean;
        int256_int: boolean;
        int256_int8: boolean;
        int256_int42: boolean;
        int256_int256: boolean;
        int256_uint8: boolean;
        int256_uint42: boolean;
        int256_uint256: boolean;
        int256_coins: boolean;
        uint8_int: boolean;
        uint8_int8: boolean;
        uint8_int42: boolean;
        uint8_int256: boolean;
        uint8_uint8: boolean;
        uint8_uint42: boolean;
        uint8_uint256: boolean;
        uint8_coins: boolean;
        uint42_int: boolean;
        uint42_int8: boolean;
        uint42_int42: boolean;
        uint42_int256: boolean;
        uint42_uint8: boolean;
        uint42_uint42: boolean;
        uint42_uint256: boolean;
        uint42_coins: boolean;
        uint256_int: boolean;
        uint256_int8: boolean;
        uint256_int42: boolean;
        uint256_int256: boolean;
        uint256_uint8: boolean;
        uint256_uint42: boolean;
        uint256_uint256: boolean;
        uint256_coins: boolean;
        address_int: boolean;
        address_int8: boolean;
        address_int42: boolean;
        address_int256: boolean;
        address_uint8: boolean;
        address_uint42: boolean;
        address_uint256: boolean;
        address_coins: boolean;
    }>;
    getReplaceGetAllMaps(provider: ContractProvider, keyInt: bigint, keyInt8: bigint, keyInt42: bigint, keyInt256: bigint, keyUint8: bigint, keyUint42: bigint, keyUint256: bigint, keyAddress: Address, valueInt: bigint, valueInt8: bigint, valueInt42: bigint, valueInt256: bigint, valueUint8: bigint, valueUint42: bigint, valueUint256: bigint, valueCoins: bigint): Promise<{
        $$type: "ReplaceGetAllMapsResult";
        int_int: bigint | null;
        int_int8: bigint | null;
        int_int42: bigint | null;
        int_int256: bigint | null;
        int_uint8: bigint | null;
        int_uint42: bigint | null;
        int_uint256: bigint | null;
        int_coins: bigint | null;
        int8_int: bigint | null;
        int8_int8: bigint | null;
        int8_int42: bigint | null;
        int8_int256: bigint | null;
        int8_uint8: bigint | null;
        int8_uint42: bigint | null;
        int8_uint256: bigint | null;
        int8_coins: bigint | null;
        int42_int: bigint | null;
        int42_int8: bigint | null;
        int42_int42: bigint | null;
        int42_int256: bigint | null;
        int42_uint8: bigint | null;
        int42_uint42: bigint | null;
        int42_uint256: bigint | null;
        int42_coins: bigint | null;
        int256_int: bigint | null;
        int256_int8: bigint | null;
        int256_int42: bigint | null;
        int256_int256: bigint | null;
        int256_uint8: bigint | null;
        int256_uint42: bigint | null;
        int256_uint256: bigint | null;
        int256_coins: bigint | null;
        uint8_int: bigint | null;
        uint8_int8: bigint | null;
        uint8_int42: bigint | null;
        uint8_int256: bigint | null;
        uint8_uint8: bigint | null;
        uint8_uint42: bigint | null;
        uint8_uint256: bigint | null;
        uint8_coins: bigint | null;
        uint42_int: bigint | null;
        uint42_int8: bigint | null;
        uint42_int42: bigint | null;
        uint42_int256: bigint | null;
        uint42_uint8: bigint | null;
        uint42_uint42: bigint | null;
        uint42_uint256: bigint | null;
        uint42_coins: bigint | null;
        uint256_int: bigint | null;
        uint256_int8: bigint | null;
        uint256_int42: bigint | null;
        uint256_int256: bigint | null;
        uint256_uint8: bigint | null;
        uint256_uint42: bigint | null;
        uint256_uint256: bigint | null;
        uint256_coins: bigint | null;
        address_int: bigint | null;
        address_int8: bigint | null;
        address_int42: bigint | null;
        address_int256: bigint | null;
        address_uint8: bigint | null;
        address_uint42: bigint | null;
        address_uint256: bigint | null;
        address_coins: bigint | null;
    }>;
    getExistsAllMaps(provider: ContractProvider, keyInt: bigint, keyInt8: bigint, keyInt42: bigint, keyInt256: bigint, keyUint8: bigint, keyUint42: bigint, keyUint256: bigint, keyAddress: Address): Promise<{
        $$type: "ExistsAllMapsResult";
        int_int: boolean;
        int_int8: boolean;
        int_int42: boolean;
        int_int256: boolean;
        int_uint8: boolean;
        int_uint42: boolean;
        int_uint256: boolean;
        int_coins: boolean;
        int8_int: boolean;
        int8_int8: boolean;
        int8_int42: boolean;
        int8_int256: boolean;
        int8_uint8: boolean;
        int8_uint42: boolean;
        int8_uint256: boolean;
        int8_coins: boolean;
        int42_int: boolean;
        int42_int8: boolean;
        int42_int42: boolean;
        int42_int256: boolean;
        int42_uint8: boolean;
        int42_uint42: boolean;
        int42_uint256: boolean;
        int42_coins: boolean;
        int256_int: boolean;
        int256_int8: boolean;
        int256_int42: boolean;
        int256_int256: boolean;
        int256_uint8: boolean;
        int256_uint42: boolean;
        int256_uint256: boolean;
        int256_coins: boolean;
        uint8_int: boolean;
        uint8_int8: boolean;
        uint8_int42: boolean;
        uint8_int256: boolean;
        uint8_uint8: boolean;
        uint8_uint42: boolean;
        uint8_uint256: boolean;
        uint8_coins: boolean;
        uint42_int: boolean;
        uint42_int8: boolean;
        uint42_int42: boolean;
        uint42_int256: boolean;
        uint42_uint8: boolean;
        uint42_uint42: boolean;
        uint42_uint256: boolean;
        uint42_coins: boolean;
        uint256_int: boolean;
        uint256_int8: boolean;
        uint256_int42: boolean;
        uint256_int256: boolean;
        uint256_uint8: boolean;
        uint256_uint42: boolean;
        uint256_uint256: boolean;
        uint256_coins: boolean;
        address_int: boolean;
        address_int8: boolean;
        address_int42: boolean;
        address_int256: boolean;
        address_uint8: boolean;
        address_uint42: boolean;
        address_uint256: boolean;
        address_coins: boolean;
    }>;
    getIsEmptyAllMaps(provider: ContractProvider): Promise<{
        $$type: "IsEmptyAllMapsResult";
        int_int: boolean;
        int_int8: boolean;
        int_int42: boolean;
        int_int256: boolean;
        int_uint8: boolean;
        int_uint42: boolean;
        int_uint256: boolean;
        int_coins: boolean;
        int8_int: boolean;
        int8_int8: boolean;
        int8_int42: boolean;
        int8_int256: boolean;
        int8_uint8: boolean;
        int8_uint42: boolean;
        int8_uint256: boolean;
        int8_coins: boolean;
        int42_int: boolean;
        int42_int8: boolean;
        int42_int42: boolean;
        int42_int256: boolean;
        int42_uint8: boolean;
        int42_uint42: boolean;
        int42_uint256: boolean;
        int42_coins: boolean;
        int256_int: boolean;
        int256_int8: boolean;
        int256_int42: boolean;
        int256_int256: boolean;
        int256_uint8: boolean;
        int256_uint42: boolean;
        int256_uint256: boolean;
        int256_coins: boolean;
        uint8_int: boolean;
        uint8_int8: boolean;
        uint8_int42: boolean;
        uint8_int256: boolean;
        uint8_uint8: boolean;
        uint8_uint42: boolean;
        uint8_uint256: boolean;
        uint8_coins: boolean;
        uint42_int: boolean;
        uint42_int8: boolean;
        uint42_int42: boolean;
        uint42_int256: boolean;
        uint42_uint8: boolean;
        uint42_uint42: boolean;
        uint42_uint256: boolean;
        uint42_coins: boolean;
        uint256_int: boolean;
        uint256_int8: boolean;
        uint256_int42: boolean;
        uint256_int256: boolean;
        uint256_uint8: boolean;
        uint256_uint42: boolean;
        uint256_uint256: boolean;
        uint256_coins: boolean;
        address_int: boolean;
        address_int8: boolean;
        address_int42: boolean;
        address_int256: boolean;
        address_uint8: boolean;
        address_uint42: boolean;
        address_uint256: boolean;
        address_coins: boolean;
    }>;
    getAsCellAllMaps(provider: ContractProvider): Promise<{
        $$type: "AsCellAllMapsResult";
        int_int: Cell | null;
        int_int8: Cell | null;
        int_int42: Cell | null;
        int_int256: Cell | null;
        int_uint8: Cell | null;
        int_uint42: Cell | null;
        int_uint256: Cell | null;
        int_coins: Cell | null;
        int8_int: Cell | null;
        int8_int8: Cell | null;
        int8_int42: Cell | null;
        int8_int256: Cell | null;
        int8_uint8: Cell | null;
        int8_uint42: Cell | null;
        int8_uint256: Cell | null;
        int8_coins: Cell | null;
        int42_int: Cell | null;
        int42_int8: Cell | null;
        int42_int42: Cell | null;
        int42_int256: Cell | null;
        int42_uint8: Cell | null;
        int42_uint42: Cell | null;
        int42_uint256: Cell | null;
        int42_coins: Cell | null;
        int256_int: Cell | null;
        int256_int8: Cell | null;
        int256_int42: Cell | null;
        int256_int256: Cell | null;
        int256_uint8: Cell | null;
        int256_uint42: Cell | null;
        int256_uint256: Cell | null;
        int256_coins: Cell | null;
        uint8_int: Cell | null;
        uint8_int8: Cell | null;
        uint8_int42: Cell | null;
        uint8_int256: Cell | null;
        uint8_uint8: Cell | null;
        uint8_uint42: Cell | null;
        uint8_uint256: Cell | null;
        uint8_coins: Cell | null;
        uint42_int: Cell | null;
        uint42_int8: Cell | null;
        uint42_int42: Cell | null;
        uint42_int256: Cell | null;
        uint42_uint8: Cell | null;
        uint42_uint42: Cell | null;
        uint42_uint256: Cell | null;
        uint42_coins: Cell | null;
        uint256_int: Cell | null;
        uint256_int8: Cell | null;
        uint256_int42: Cell | null;
        uint256_int256: Cell | null;
        uint256_uint8: Cell | null;
        uint256_uint42: Cell | null;
        uint256_uint256: Cell | null;
        uint256_coins: Cell | null;
        address_int: Cell | null;
        address_int8: Cell | null;
        address_int42: Cell | null;
        address_int256: Cell | null;
        address_uint8: Cell | null;
        address_uint42: Cell | null;
        address_uint256: Cell | null;
        address_coins: Cell | null;
    }>;
    getCheckNullReference(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/masterchain_MasterchainTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/masterchain_MasterchainTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MasterchainTester$Data = {
    $$type: 'MasterchainTester$Data';
};
export declare function storeMasterchainTester$Data(src: MasterchainTester$Data): (builder: Builder) => void;
export declare function loadMasterchainTester$Data(slice: Slice): {
    $$type: "MasterchainTester$Data";
};
export declare const MasterchainTester_getterMapping: {
    [key: string]: string;
};
export declare class MasterchainTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MasterchainTester>;
    static fromAddress(address: Address): MasterchainTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "DeployToWorkchain" | "DeployToMasterchain"): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/math_MathTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/math_MathTester.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type MathTester$Data = {
    $$type: 'MathTester$Data';
};
export declare function storeMathTester$Data(src: MathTester$Data): (builder: Builder) => void;
export declare function loadMathTester$Data(slice: Slice): {
    $$type: "MathTester$Data";
};
export declare const MathTester_getterMapping: {
    [key: string]: string;
};
export declare class MathTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MathTester>;
    static fromAddress(address: Address): MathTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Deploy): Promise<void>;
    getAdd(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getSub(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getMul(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getDiv(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getMod(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getShr(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getShl(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getAnd(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getOr(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getXor(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getBitwiseNot(provider: ContractProvider, a: bigint): Promise<bigint>;
    getAddAug(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getSubAug(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getMulAug(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getDivAug(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getModAug(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getBitwiseOrAug(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getBitwiseAndAug(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getBitwiseXorAug(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getCompare1(provider: ContractProvider, a: bigint, b: bigint | null): Promise<boolean>;
    getCompare2(provider: ContractProvider, a: bigint, b: bigint | null): Promise<boolean>;
    getCompare3(provider: ContractProvider, a: bigint | null, b: bigint): Promise<boolean>;
    getCompare4(provider: ContractProvider, a: bigint | null, b: bigint): Promise<boolean>;
    getCompare5(provider: ContractProvider, a: bigint | null, b: bigint | null): Promise<boolean>;
    getCompare6(provider: ContractProvider, a: bigint | null, b: bigint | null): Promise<boolean>;
    getCompare7(provider: ContractProvider, a: bigint, b: bigint): Promise<boolean>;
    getCompare8(provider: ContractProvider, a: bigint, b: bigint): Promise<boolean>;
    getCompare9(provider: ContractProvider, a: bigint, b: bigint): Promise<boolean>;
    getCompare10(provider: ContractProvider, a: bigint, b: bigint): Promise<boolean>;
    getCompare11(provider: ContractProvider, a: Address, b: Address): Promise<boolean>;
    getCompare12(provider: ContractProvider, a: Address, b: Address | null): Promise<boolean>;
    getCompare13(provider: ContractProvider, a: Address | null, b: Address): Promise<boolean>;
    getCompare14(provider: ContractProvider, a: Address | null, b: Address | null): Promise<boolean>;
    getCompare15(provider: ContractProvider, a: Address, b: Address): Promise<boolean>;
    getCompare16(provider: ContractProvider, a: Address, b: Address | null): Promise<boolean>;
    getCompare17(provider: ContractProvider, a: Address | null, b: Address): Promise<boolean>;
    getCompare18(provider: ContractProvider, a: Address | null, b: Address | null): Promise<boolean>;
    getCompare19(provider: ContractProvider, a: Cell, b: Cell): Promise<boolean>;
    getCompare20(provider: ContractProvider, a: Cell, b: Cell | null): Promise<boolean>;
    getCompare21(provider: ContractProvider, a: Cell | null, b: Cell): Promise<boolean>;
    getCompare22(provider: ContractProvider, a: Cell | null, b: Cell | null): Promise<boolean>;
    getCompare23(provider: ContractProvider, a: Cell, b: Cell): Promise<boolean>;
    getCompare24(provider: ContractProvider, a: Cell, b: Cell | null): Promise<boolean>;
    getCompare25(provider: ContractProvider, a: Cell | null, b: Cell): Promise<boolean>;
    getCompare26(provider: ContractProvider, a: Cell | null, b: Cell | null): Promise<boolean>;
    getCompare27(provider: ContractProvider, a: Dictionary<bigint, bigint>, b: Dictionary<bigint, bigint>): Promise<boolean>;
    getCompare28(provider: ContractProvider, a: Dictionary<bigint, bigint>, b: Dictionary<bigint, bigint>): Promise<boolean>;
    getCompare29(provider: ContractProvider, a: Slice, b: Slice): Promise<boolean>;
    getCompare30(provider: ContractProvider, a: Slice, b: Slice | null): Promise<boolean>;
    getCompare31(provider: ContractProvider, a: Slice | null, b: Slice): Promise<boolean>;
    getCompare32(provider: ContractProvider, a: Slice | null, b: Slice | null): Promise<boolean>;
    getCompare33(provider: ContractProvider, a: Slice, b: Slice): Promise<boolean>;
    getCompare34(provider: ContractProvider, a: Slice, b: Slice | null): Promise<boolean>;
    getCompare35(provider: ContractProvider, a: Slice | null, b: Slice): Promise<boolean>;
    getCompare36(provider: ContractProvider, a: Slice | null, b: Slice | null): Promise<boolean>;
    getCompare37(provider: ContractProvider, a: string, b: string): Promise<boolean>;
    getCompare38(provider: ContractProvider, a: string, b: string | null): Promise<boolean>;
    getCompare39(provider: ContractProvider, a: string | null, b: string): Promise<boolean>;
    getCompare40(provider: ContractProvider, a: string | null, b: string | null): Promise<boolean>;
    getCompare41(provider: ContractProvider, a: string, b: string): Promise<boolean>;
    getCompare42(provider: ContractProvider, a: string, b: string | null): Promise<boolean>;
    getCompare43(provider: ContractProvider, a: string | null, b: string): Promise<boolean>;
    getCompare44(provider: ContractProvider, a: string | null, b: string | null): Promise<boolean>;
    getIsNull1(provider: ContractProvider, a: bigint | null): Promise<boolean>;
    getIsNotNull1(provider: ContractProvider, a: bigint | null): Promise<boolean>;
    getIsNull2(provider: ContractProvider, address: Address | null): Promise<boolean>;
    getIsNotNull2(provider: ContractProvider, address: Address | null): Promise<boolean>;
    getIsNull3(provider: ContractProvider, cell: Cell | null): Promise<boolean>;
    getIsNotNull3(provider: ContractProvider, cell: Cell | null): Promise<boolean>;
    getLog2(provider: ContractProvider, num: bigint): Promise<bigint>;
    getLog(provider: ContractProvider, num: bigint, base: bigint): Promise<bigint>;
    getPow(provider: ContractProvider, base: bigint, exp: bigint): Promise<bigint>;
    getPow2(provider: ContractProvider, exp: bigint): Promise<bigint>;
    getPrecedence1(provider: ContractProvider): Promise<bigint>;
    getPrecedence2(provider: ContractProvider): Promise<bigint>;
    getPrecedence3(provider: ContractProvider): Promise<bigint>;
    getPrecedence4(provider: ContractProvider): Promise<bigint>;
    getPrecedence5(provider: ContractProvider): Promise<bigint>;
    getPrecedence6(provider: ContractProvider): Promise<bigint>;
    getPrecedence7(provider: ContractProvider): Promise<bigint>;
    getPrecedence8(provider: ContractProvider): Promise<bigint>;
    getPrecedence9(provider: ContractProvider): Promise<bigint>;
    getPrecedence10(provider: ContractProvider): Promise<bigint>;
    getPrecedence11(provider: ContractProvider): Promise<bigint>;
    getPrecedence12(provider: ContractProvider): Promise<bigint>;
    getBitwiseNot1(provider: ContractProvider, x: bigint): Promise<bigint>;
    getBitwiseNot2(provider: ContractProvider, x: bigint): Promise<bigint>;
    getBitwiseNot3(provider: ContractProvider, x: bigint): Promise<bigint>;
    getBitwiseNot4(provider: ContractProvider, x: bigint): Promise<bigint>;
    getAugmentedAnd(provider: ContractProvider, a: boolean, b: boolean): Promise<boolean>;
    getAugmentedOr(provider: ContractProvider, a: boolean, b: boolean): Promise<boolean>;
    getAugmentedShiftLeft(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getAugmentedShiftRight(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/mutating-methods_Tester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/mutating-methods_Tester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Foo = {
    $$type: 'Foo';
    s: Slice;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    s: Slice;
};
export type Tester$Data = {
    $$type: 'Tester$Data';
    s: Slice;
};
export declare function storeTester$Data(src: Tester$Data): (builder: Builder) => void;
export declare function loadTester$Data(slice: Slice): {
    $$type: "Tester$Data";
    s: Slice;
};
export declare const Tester_getterMapping: {
    [key: string]: string;
};
export declare class Tester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Tester>;
    static fromAddress(address: Address): Tester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTest1(provider: ContractProvider): Promise<bigint>;
    getTest2(provider: ContractProvider): Promise<bigint>;
    getTest3(provider: ContractProvider): Promise<bigint>;
    getTest4(provider: ContractProvider): Promise<bigint>;
    getTest5(provider: ContractProvider): Promise<bigint>;
    getTest6(provider: ContractProvider): Promise<void>;
    getTest7(provider: ContractProvider): Promise<bigint>;
    getTest8(provider: ContractProvider): Promise<bigint>;
    getTest9(provider: ContractProvider): Promise<bigint>;
    getTest10(provider: ContractProvider, dict: Cell | null): Promise<Cell | null>;
    getTest11(provider: ContractProvider, x: bigint | null): Promise<bigint | null>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/non-mutating-methods_Tester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/non-mutating-methods_Tester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
};
export type Tester$Data = {
    $$type: 'Tester$Data';
};
export declare function storeTester$Data(src: Tester$Data): (builder: Builder) => void;
export declare function loadTester$Data(slice: Slice): {
    $$type: "Tester$Data";
};
export declare const Tester_getterMapping: {
    [key: string]: string;
};
export declare class Tester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Tester>;
    static fromAddress(address: Address): Tester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTest1(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/optionals_ContractWithOptionals.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/optionals_ContractWithOptionals.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Struct2 = {
    $$type: 'Struct2';
    v: bigint;
};
export declare function storeStruct2(src: Struct2): (builder: Builder) => void;
export declare function loadStruct2(slice: Slice): {
    $$type: "Struct2";
    v: bigint;
};
export type OptStruct = {
    $$type: 'OptStruct';
    s: Struct2 | null;
};
export declare function storeOptStruct(src: OptStruct): (builder: Builder) => void;
export declare function loadOptStruct(slice: Slice): {
    $$type: "OptStruct";
    s: {
        $$type: "Struct2";
        v: bigint;
    } | null;
};
export type Opt2$Data = {
    $$type: 'Opt2$Data';
    stateInit: StateInit;
};
export declare function storeOpt2$Data(src: Opt2$Data): (builder: Builder) => void;
export declare function loadOpt2$Data(slice: Slice): {
    $$type: "Opt2$Data";
    stateInit: {
        $$type: "StateInit";
        code: Cell;
        data: Cell;
    };
};
export type Opt3$Data = {
    $$type: 'Opt3$Data';
};
export declare function storeOpt3$Data(src: Opt3$Data): (builder: Builder) => void;
export declare function loadOpt3$Data(slice: Slice): {
    $$type: "Opt3$Data";
};
export type OptAddr = {
    $$type: 'OptAddr';
    x: bigint;
    y: Address | null;
    z: bigint;
};
export declare function storeOptAddr(src: OptAddr): (builder: Builder) => void;
export declare function loadOptAddr(slice: Slice): {
    $$type: "OptAddr";
    x: bigint;
    y: Address | null;
    z: bigint;
};
export type Opt4$Data = {
    $$type: 'Opt4$Data';
    z: bigint;
};
export declare function storeOpt4$Data(src: Opt4$Data): (builder: Builder) => void;
export declare function loadOpt4$Data(slice: Slice): {
    $$type: "Opt4$Data";
    z: bigint;
};
export type SomeGenericStruct = {
    $$type: 'SomeGenericStruct';
    value1: bigint;
    value2: bigint;
    value3: bigint;
    value4: bigint;
    value5: bigint;
};
export declare function storeSomeGenericStruct(src: SomeGenericStruct): (builder: Builder) => void;
export declare function loadSomeGenericStruct(slice: Slice): {
    $$type: "SomeGenericStruct";
    value1: bigint;
    value2: bigint;
    value3: bigint;
    value4: bigint;
    value5: bigint;
};
export type StructWithOptionals = {
    $$type: 'StructWithOptionals';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
};
export declare function storeStructWithOptionals(src: StructWithOptionals): (builder: Builder) => void;
export declare function loadStructWithOptionals(slice: Slice): {
    $$type: "StructWithOptionals";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
};
export type Update = {
    $$type: 'Update';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
    f: StructWithOptionals | null;
};
export declare function storeUpdate(src: Update): (builder: Builder) => void;
export declare function loadUpdate(slice: Slice): {
    $$type: "Update";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
    f: {
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    } | null;
};
export type ContractWithOptionals$Data = {
    $$type: 'ContractWithOptionals$Data';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
    f: StructWithOptionals | null;
};
export declare function storeContractWithOptionals$Data(src: ContractWithOptionals$Data): (builder: Builder) => void;
export declare function loadContractWithOptionals$Data(slice: Slice): {
    $$type: "ContractWithOptionals$Data";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
    f: {
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    } | null;
};
export declare const ContractWithOptionals_getterMapping: {
    [key: string]: string;
};
export declare class ContractWithOptionals implements Contract {
    static init(a: bigint | null, b: boolean | null, c: Cell | null, d: Address | null, e: SomeGenericStruct | null, f: StructWithOptionals | null): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(a: bigint | null, b: boolean | null, c: Cell | null, d: Address | null, e: SomeGenericStruct | null, f: StructWithOptionals | null): Promise<ContractWithOptionals>;
    static fromAddress(address: Address): ContractWithOptionals;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | Update): Promise<void>;
    getIsNotNullA(provider: ContractProvider): Promise<boolean>;
    getIsNotNullB(provider: ContractProvider): Promise<boolean>;
    getIsNotNullC(provider: ContractProvider): Promise<boolean>;
    getIsNotNullD(provider: ContractProvider): Promise<boolean>;
    getIsNotNullE(provider: ContractProvider): Promise<boolean>;
    getIsNotNullF(provider: ContractProvider): Promise<boolean>;
    getNullA(provider: ContractProvider): Promise<bigint | null>;
    getNullB(provider: ContractProvider): Promise<boolean | null>;
    getNullC(provider: ContractProvider): Promise<Cell | null>;
    getNullD(provider: ContractProvider): Promise<Address | null>;
    getNullE(provider: ContractProvider): Promise<{
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null>;
    getNullF(provider: ContractProvider): Promise<{
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    } | null>;
    getNotNullA(provider: ContractProvider): Promise<bigint>;
    getNotNullB(provider: ContractProvider): Promise<boolean>;
    getNotNullC(provider: ContractProvider): Promise<Cell>;
    getNotNullD(provider: ContractProvider): Promise<Address>;
    getNotNullE(provider: ContractProvider): Promise<{
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    }>;
    getNotNullF(provider: ContractProvider): Promise<{
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    }>;
    getTestVariables(provider: ContractProvider): Promise<{
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    }>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/optionals_Opt2.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/optionals_Opt2.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Struct2 = {
    $$type: 'Struct2';
    v: bigint;
};
export declare function storeStruct2(src: Struct2): (builder: Builder) => void;
export declare function loadStruct2(slice: Slice): {
    $$type: "Struct2";
    v: bigint;
};
export type OptStruct = {
    $$type: 'OptStruct';
    s: Struct2 | null;
};
export declare function storeOptStruct(src: OptStruct): (builder: Builder) => void;
export declare function loadOptStruct(slice: Slice): {
    $$type: "OptStruct";
    s: {
        $$type: "Struct2";
        v: bigint;
    } | null;
};
export type Opt2$Data = {
    $$type: 'Opt2$Data';
    stateInit: StateInit;
};
export declare function storeOpt2$Data(src: Opt2$Data): (builder: Builder) => void;
export declare function loadOpt2$Data(slice: Slice): {
    $$type: "Opt2$Data";
    stateInit: {
        $$type: "StateInit";
        code: Cell;
        data: Cell;
    };
};
export type Opt3$Data = {
    $$type: 'Opt3$Data';
};
export declare function storeOpt3$Data(src: Opt3$Data): (builder: Builder) => void;
export declare function loadOpt3$Data(slice: Slice): {
    $$type: "Opt3$Data";
};
export type OptAddr = {
    $$type: 'OptAddr';
    x: bigint;
    y: Address | null;
    z: bigint;
};
export declare function storeOptAddr(src: OptAddr): (builder: Builder) => void;
export declare function loadOptAddr(slice: Slice): {
    $$type: "OptAddr";
    x: bigint;
    y: Address | null;
    z: bigint;
};
export type Opt4$Data = {
    $$type: 'Opt4$Data';
    z: bigint;
};
export declare function storeOpt4$Data(src: Opt4$Data): (builder: Builder) => void;
export declare function loadOpt4$Data(slice: Slice): {
    $$type: "Opt4$Data";
    z: bigint;
};
export type SomeGenericStruct = {
    $$type: 'SomeGenericStruct';
    value1: bigint;
    value2: bigint;
    value3: bigint;
    value4: bigint;
    value5: bigint;
};
export declare function storeSomeGenericStruct(src: SomeGenericStruct): (builder: Builder) => void;
export declare function loadSomeGenericStruct(slice: Slice): {
    $$type: "SomeGenericStruct";
    value1: bigint;
    value2: bigint;
    value3: bigint;
    value4: bigint;
    value5: bigint;
};
export type StructWithOptionals = {
    $$type: 'StructWithOptionals';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
};
export declare function storeStructWithOptionals(src: StructWithOptionals): (builder: Builder) => void;
export declare function loadStructWithOptionals(slice: Slice): {
    $$type: "StructWithOptionals";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
};
export type Update = {
    $$type: 'Update';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
    f: StructWithOptionals | null;
};
export declare function storeUpdate(src: Update): (builder: Builder) => void;
export declare function loadUpdate(slice: Slice): {
    $$type: "Update";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
    f: {
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    } | null;
};
export type ContractWithOptionals$Data = {
    $$type: 'ContractWithOptionals$Data';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
    f: StructWithOptionals | null;
};
export declare function storeContractWithOptionals$Data(src: ContractWithOptionals$Data): (builder: Builder) => void;
export declare function loadContractWithOptionals$Data(slice: Slice): {
    $$type: "ContractWithOptionals$Data";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
    f: {
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    } | null;
};
export declare const Opt2_getterMapping: {
    [key: string]: string;
};
export declare class Opt2 implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Opt2>;
    static fromAddress(address: Address): Opt2;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "Test"): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/optionals_Opt3.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/optionals_Opt3.d.ts" {
                import { Cell, Slice, Address, Builder, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Struct2 = {
    $$type: 'Struct2';
    v: bigint;
};
export declare function storeStruct2(src: Struct2): (builder: Builder) => void;
export declare function loadStruct2(slice: Slice): {
    $$type: "Struct2";
    v: bigint;
};
export type OptStruct = {
    $$type: 'OptStruct';
    s: Struct2 | null;
};
export declare function storeOptStruct(src: OptStruct): (builder: Builder) => void;
export declare function loadOptStruct(slice: Slice): {
    $$type: "OptStruct";
    s: {
        $$type: "Struct2";
        v: bigint;
    } | null;
};
export type Opt2$Data = {
    $$type: 'Opt2$Data';
    stateInit: StateInit;
};
export declare function storeOpt2$Data(src: Opt2$Data): (builder: Builder) => void;
export declare function loadOpt2$Data(slice: Slice): {
    $$type: "Opt2$Data";
    stateInit: {
        $$type: "StateInit";
        code: Cell;
        data: Cell;
    };
};
export type Opt3$Data = {
    $$type: 'Opt3$Data';
};
export declare function storeOpt3$Data(src: Opt3$Data): (builder: Builder) => void;
export declare function loadOpt3$Data(slice: Slice): {
    $$type: "Opt3$Data";
};
export type OptAddr = {
    $$type: 'OptAddr';
    x: bigint;
    y: Address | null;
    z: bigint;
};
export declare function storeOptAddr(src: OptAddr): (builder: Builder) => void;
export declare function loadOptAddr(slice: Slice): {
    $$type: "OptAddr";
    x: bigint;
    y: Address | null;
    z: bigint;
};
export type Opt4$Data = {
    $$type: 'Opt4$Data';
    z: bigint;
};
export declare function storeOpt4$Data(src: Opt4$Data): (builder: Builder) => void;
export declare function loadOpt4$Data(slice: Slice): {
    $$type: "Opt4$Data";
    z: bigint;
};
export type SomeGenericStruct = {
    $$type: 'SomeGenericStruct';
    value1: bigint;
    value2: bigint;
    value3: bigint;
    value4: bigint;
    value5: bigint;
};
export declare function storeSomeGenericStruct(src: SomeGenericStruct): (builder: Builder) => void;
export declare function loadSomeGenericStruct(slice: Slice): {
    $$type: "SomeGenericStruct";
    value1: bigint;
    value2: bigint;
    value3: bigint;
    value4: bigint;
    value5: bigint;
};
export type StructWithOptionals = {
    $$type: 'StructWithOptionals';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
};
export declare function storeStructWithOptionals(src: StructWithOptionals): (builder: Builder) => void;
export declare function loadStructWithOptionals(slice: Slice): {
    $$type: "StructWithOptionals";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
};
export type Update = {
    $$type: 'Update';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
    f: StructWithOptionals | null;
};
export declare function storeUpdate(src: Update): (builder: Builder) => void;
export declare function loadUpdate(slice: Slice): {
    $$type: "Update";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
    f: {
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    } | null;
};
export type ContractWithOptionals$Data = {
    $$type: 'ContractWithOptionals$Data';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
    f: StructWithOptionals | null;
};
export declare function storeContractWithOptionals$Data(src: ContractWithOptionals$Data): (builder: Builder) => void;
export declare function loadContractWithOptionals$Data(slice: Slice): {
    $$type: "ContractWithOptionals$Data";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
    f: {
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    } | null;
};
export declare const Opt3_getterMapping: {
    [key: string]: string;
};
export declare class Opt3 implements Contract {
    static init(arg: Struct2 | null): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(arg: Struct2 | null): Promise<Opt3>;
    static fromAddress(address: Address): Opt3;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/optionals_Opt4.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/optionals_Opt4.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Struct2 = {
    $$type: 'Struct2';
    v: bigint;
};
export declare function storeStruct2(src: Struct2): (builder: Builder) => void;
export declare function loadStruct2(slice: Slice): {
    $$type: "Struct2";
    v: bigint;
};
export type OptStruct = {
    $$type: 'OptStruct';
    s: Struct2 | null;
};
export declare function storeOptStruct(src: OptStruct): (builder: Builder) => void;
export declare function loadOptStruct(slice: Slice): {
    $$type: "OptStruct";
    s: {
        $$type: "Struct2";
        v: bigint;
    } | null;
};
export type Opt2$Data = {
    $$type: 'Opt2$Data';
    stateInit: StateInit;
};
export declare function storeOpt2$Data(src: Opt2$Data): (builder: Builder) => void;
export declare function loadOpt2$Data(slice: Slice): {
    $$type: "Opt2$Data";
    stateInit: {
        $$type: "StateInit";
        code: Cell;
        data: Cell;
    };
};
export type Opt3$Data = {
    $$type: 'Opt3$Data';
};
export declare function storeOpt3$Data(src: Opt3$Data): (builder: Builder) => void;
export declare function loadOpt3$Data(slice: Slice): {
    $$type: "Opt3$Data";
};
export type OptAddr = {
    $$type: 'OptAddr';
    x: bigint;
    y: Address | null;
    z: bigint;
};
export declare function storeOptAddr(src: OptAddr): (builder: Builder) => void;
export declare function loadOptAddr(slice: Slice): {
    $$type: "OptAddr";
    x: bigint;
    y: Address | null;
    z: bigint;
};
export type Opt4$Data = {
    $$type: 'Opt4$Data';
    z: bigint;
};
export declare function storeOpt4$Data(src: Opt4$Data): (builder: Builder) => void;
export declare function loadOpt4$Data(slice: Slice): {
    $$type: "Opt4$Data";
    z: bigint;
};
export type SomeGenericStruct = {
    $$type: 'SomeGenericStruct';
    value1: bigint;
    value2: bigint;
    value3: bigint;
    value4: bigint;
    value5: bigint;
};
export declare function storeSomeGenericStruct(src: SomeGenericStruct): (builder: Builder) => void;
export declare function loadSomeGenericStruct(slice: Slice): {
    $$type: "SomeGenericStruct";
    value1: bigint;
    value2: bigint;
    value3: bigint;
    value4: bigint;
    value5: bigint;
};
export type StructWithOptionals = {
    $$type: 'StructWithOptionals';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
};
export declare function storeStructWithOptionals(src: StructWithOptionals): (builder: Builder) => void;
export declare function loadStructWithOptionals(slice: Slice): {
    $$type: "StructWithOptionals";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
};
export type Update = {
    $$type: 'Update';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
    f: StructWithOptionals | null;
};
export declare function storeUpdate(src: Update): (builder: Builder) => void;
export declare function loadUpdate(slice: Slice): {
    $$type: "Update";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
    f: {
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    } | null;
};
export type ContractWithOptionals$Data = {
    $$type: 'ContractWithOptionals$Data';
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: SomeGenericStruct | null;
    f: StructWithOptionals | null;
};
export declare function storeContractWithOptionals$Data(src: ContractWithOptionals$Data): (builder: Builder) => void;
export declare function loadContractWithOptionals$Data(slice: Slice): {
    $$type: "ContractWithOptionals$Data";
    a: bigint | null;
    b: boolean | null;
    c: Cell | null;
    d: Address | null;
    e: {
        $$type: "SomeGenericStruct";
        value1: bigint;
        value2: bigint;
        value3: bigint;
        value4: bigint;
        value5: bigint;
    } | null;
    f: {
        $$type: "StructWithOptionals";
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: {
            $$type: "SomeGenericStruct";
            value1: bigint;
            value2: bigint;
            value3: bigint;
            value4: bigint;
            value5: bigint;
        } | null;
    } | null;
};
export declare const Opt4_getterMapping: {
    [key: string]: string;
};
export declare class Opt4 implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Opt4>;
    static fromAddress(address: Address): Opt4;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | OptAddr): Promise<void>;
    getZ(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/ordering_A.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/ordering_A.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type S = {
    $$type: 'S';
    v1: bigint;
    v2: bigint;
    v3: bigint;
};
export declare function storeS(src: S): (builder: Builder) => void;
export declare function loadS(slice: Slice): {
    $$type: "S";
    v1: bigint;
    v2: bigint;
    v3: bigint;
};
export type A$Data = {
    $$type: 'A$Data';
    owner: Address;
};
export declare function storeA$Data(src: A$Data): (builder: Builder) => void;
export declare function loadA$Data(slice: Slice): {
    $$type: "A$Data";
    owner: Address;
};
export type B$Data = {
    $$type: 'B$Data';
};
export declare function storeB$Data(src: B$Data): (builder: Builder) => void;
export declare function loadB$Data(slice: Slice): {
    $$type: "B$Data";
};
export declare const A_getterMapping: {
    [key: string]: string;
};
export declare class A implements Contract {
    static init(owner: Address): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(owner: Address): Promise<A>;
    static fromAddress(address: Address): A;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Deploy): Promise<void>;
    getCreate(provider: ContractProvider, v: bigint): Promise<{
        $$type: "S";
        v1: bigint;
        v2: bigint;
        v3: bigint;
    }>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/ordering_B.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/ordering_B.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type S = {
    $$type: 'S';
    v1: bigint;
    v2: bigint;
    v3: bigint;
};
export declare function storeS(src: S): (builder: Builder) => void;
export declare function loadS(slice: Slice): {
    $$type: "S";
    v1: bigint;
    v2: bigint;
    v3: bigint;
};
export type A$Data = {
    $$type: 'A$Data';
    owner: Address;
};
export declare function storeA$Data(src: A$Data): (builder: Builder) => void;
export declare function loadA$Data(slice: Slice): {
    $$type: "A$Data";
    owner: Address;
};
export type B$Data = {
    $$type: 'B$Data';
};
export declare function storeB$Data(src: B$Data): (builder: Builder) => void;
export declare function loadB$Data(slice: Slice): {
    $$type: "B$Data";
};
export declare const B_getterMapping: {
    [key: string]: string;
};
export declare class B implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<B>;
    static fromAddress(address: Address): B;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Deploy): Promise<void>;
    getCreate(provider: ContractProvider, v: bigint): Promise<{
        $$type: "S";
        v1: bigint;
        v2: bigint;
        v3: bigint;
    }>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/random_RandomContract.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/random_RandomContract.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type RandomContract$Data = {
    $$type: 'RandomContract$Data';
};
export declare function storeRandomContract$Data(src: RandomContract$Data): (builder: Builder) => void;
export declare function loadRandomContract$Data(slice: Slice): {
    $$type: "RandomContract$Data";
};
export declare const RandomContract_getterMapping: {
    [key: string]: string;
};
export declare class RandomContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<RandomContract>;
    static fromAddress(address: Address): RandomContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Deploy): Promise<void>;
    getRandomInt(provider: ContractProvider): Promise<bigint>;
    getRandom(provider: ContractProvider, min: bigint, max: bigint): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/receiver-empty_Test.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/receiver-empty_Test.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Test$Data = {
    $$type: 'Test$Data';
};
export declare function storeTest$Data(src: Test$Data): (builder: Builder) => void;
export declare function loadTest$Data(slice: Slice): {
    $$type: "Test$Data";
};
export declare const Test_getterMapping: {
    [key: string]: string;
};
export declare class Test implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<Test>;
    static fromAddress(address: Address): Test;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getBalance(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/recursion_RecursionTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/recursion_RecursionTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type RecursionTester$Data = {
    $$type: 'RecursionTester$Data';
};
export declare function storeRecursionTester$Data(src: RecursionTester$Data): (builder: Builder) => void;
export declare function loadRecursionTester$Data(slice: Slice): {
    $$type: "RecursionTester$Data";
};
export declare const RecursionTester_getterMapping: {
    [key: string]: string;
};
export declare class RecursionTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<RecursionTester>;
    static fromAddress(address: Address): RecursionTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Deploy): Promise<void>;
    getFib(provider: ContractProvider, n: bigint): Promise<bigint>;
    getFact(provider: ContractProvider, n: bigint): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/sample-jetton_JettonDefaultWallet.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/sample-jetton_JettonDefaultWallet.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type ChangeOwner = {
    $$type: 'ChangeOwner';
    queryId: bigint;
    newOwner: Address;
};
export declare function storeChangeOwner(src: ChangeOwner): (builder: Builder) => void;
export declare function loadChangeOwner(slice: Slice): {
    $$type: "ChangeOwner";
    queryId: bigint;
    newOwner: Address;
};
export type ChangeOwnerOk = {
    $$type: 'ChangeOwnerOk';
    queryId: bigint;
    newOwner: Address;
};
export declare function storeChangeOwnerOk(src: ChangeOwnerOk): (builder: Builder) => void;
export declare function loadChangeOwnerOk(slice: Slice): {
    $$type: "ChangeOwnerOk";
    queryId: bigint;
    newOwner: Address;
};
export type Mint = {
    $$type: 'Mint';
    amount: bigint;
    receiver: Address;
};
export declare function storeMint(src: Mint): (builder: Builder) => void;
export declare function loadMint(slice: Slice): {
    $$type: "Mint";
    amount: bigint;
    receiver: Address;
};
export type JettonData = {
    $$type: 'JettonData';
    totalSupply: bigint;
    mintable: boolean;
    owner: Address;
    content: Cell;
    walletCode: Cell;
};
export declare function storeJettonData(src: JettonData): (builder: Builder) => void;
export declare function loadJettonData(slice: Slice): {
    $$type: "JettonData";
    totalSupply: bigint;
    mintable: boolean;
    owner: Address;
    content: Cell;
    walletCode: Cell;
};
export type SampleJetton$Data = {
    $$type: 'SampleJetton$Data';
    totalSupply: bigint;
    max_supply: bigint;
    owner: Address;
    content: Cell;
    mintable: boolean;
};
export declare function storeSampleJetton$Data(src: SampleJetton$Data): (builder: Builder) => void;
export declare function loadSampleJetton$Data(slice: Slice): {
    $$type: "SampleJetton$Data";
    totalSupply: bigint;
    max_supply: bigint;
    owner: Address;
    content: Cell;
    mintable: boolean;
};
export type TokenTransfer = {
    $$type: 'TokenTransfer';
    queryId: bigint;
    amount: bigint;
    destination: Address;
    response_destination: Address | null;
    custom_payload: Cell | null;
    forward_ton_amount: bigint;
    forward_payload: Slice;
};
export declare function storeTokenTransfer(src: TokenTransfer): (builder: Builder) => void;
export declare function loadTokenTransfer(slice: Slice): {
    $$type: "TokenTransfer";
    queryId: bigint;
    amount: bigint;
    destination: Address;
    response_destination: Address | null;
    custom_payload: Cell | null;
    forward_ton_amount: bigint;
    forward_payload: Slice;
};
export type TokenTransferInternal = {
    $$type: 'TokenTransferInternal';
    queryId: bigint;
    amount: bigint;
    from: Address;
    response_destination: Address | null;
    forward_ton_amount: bigint;
    forward_payload: Slice;
};
export declare function storeTokenTransferInternal(src: TokenTransferInternal): (builder: Builder) => void;
export declare function loadTokenTransferInternal(slice: Slice): {
    $$type: "TokenTransferInternal";
    queryId: bigint;
    amount: bigint;
    from: Address;
    response_destination: Address | null;
    forward_ton_amount: bigint;
    forward_payload: Slice;
};
export type TokenNotification = {
    $$type: 'TokenNotification';
    queryId: bigint;
    amount: bigint;
    from: Address;
    forward_payload: Slice;
};
export declare function storeTokenNotification(src: TokenNotification): (builder: Builder) => void;
export declare function loadTokenNotification(slice: Slice): {
    $$type: "TokenNotification";
    queryId: bigint;
    amount: bigint;
    from: Address;
    forward_payload: Slice;
};
export type TokenBurn = {
    $$type: 'TokenBurn';
    queryId: bigint;
    amount: bigint;
    owner: Address;
    response_destination: Address;
};
export declare function storeTokenBurn(src: TokenBurn): (builder: Builder) => void;
export declare function loadTokenBurn(slice: Slice): {
    $$type: "TokenBurn";
    queryId: bigint;
    amount: bigint;
    owner: Address;
    response_destination: Address;
};
export type TokenBurnNotification = {
    $$type: 'TokenBurnNotification';
    queryId: bigint;
    amount: bigint;
    owner: Address;
    response_destination: Address | null;
};
export declare function storeTokenBurnNotification(src: TokenBurnNotification): (builder: Builder) => void;
export declare function loadTokenBurnNotification(slice: Slice): {
    $$type: "TokenBurnNotification";
    queryId: bigint;
    amount: bigint;
    owner: Address;
    response_destination: Address | null;
};
export type TokenExcesses = {
    $$type: 'TokenExcesses';
    queryId: bigint;
};
export declare function storeTokenExcesses(src: TokenExcesses): (builder: Builder) => void;
export declare function loadTokenExcesses(slice: Slice): {
    $$type: "TokenExcesses";
    queryId: bigint;
};
export type TokenUpdateContent = {
    $$type: 'TokenUpdateContent';
    content: Cell;
};
export declare function storeTokenUpdateContent(src: TokenUpdateContent): (builder: Builder) => void;
export declare function loadTokenUpdateContent(slice: Slice): {
    $$type: "TokenUpdateContent";
    content: Cell;
};
export type JettonDefaultWallet$Data = {
    $$type: 'JettonDefaultWallet$Data';
    balance: bigint;
    owner: Address;
    master: Address;
};
export declare function storeJettonDefaultWallet$Data(src: JettonDefaultWallet$Data): (builder: Builder) => void;
export declare function loadJettonDefaultWallet$Data(slice: Slice): {
    $$type: "JettonDefaultWallet$Data";
    balance: bigint;
    owner: Address;
    master: Address;
};
export type JettonWalletData = {
    $$type: 'JettonWalletData';
    balance: bigint;
    owner: Address;
    master: Address;
    walletCode: Cell;
};
export declare function storeJettonWalletData(src: JettonWalletData): (builder: Builder) => void;
export declare function loadJettonWalletData(slice: Slice): {
    $$type: "JettonWalletData";
    balance: bigint;
    owner: Address;
    master: Address;
    walletCode: Cell;
};
export declare const JettonDefaultWallet_getterMapping: {
    [key: string]: string;
};
export declare class JettonDefaultWallet implements Contract {
    static init(master: Address, owner: Address): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(master: Address, owner: Address): Promise<JettonDefaultWallet>;
    static fromAddress(address: Address): JettonDefaultWallet;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: TokenTransfer | TokenTransferInternal | TokenBurn): Promise<void>;
    getMsgValue(provider: ContractProvider, value: bigint): Promise<bigint>;
    getGetWalletData(provider: ContractProvider): Promise<{
        $$type: "JettonWalletData";
        balance: bigint;
        owner: Address;
        master: Address;
        walletCode: Cell;
    }>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/sample-jetton_SampleJetton.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/sample-jetton_SampleJetton.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type ChangeOwner = {
    $$type: 'ChangeOwner';
    queryId: bigint;
    newOwner: Address;
};
export declare function storeChangeOwner(src: ChangeOwner): (builder: Builder) => void;
export declare function loadChangeOwner(slice: Slice): {
    $$type: "ChangeOwner";
    queryId: bigint;
    newOwner: Address;
};
export type ChangeOwnerOk = {
    $$type: 'ChangeOwnerOk';
    queryId: bigint;
    newOwner: Address;
};
export declare function storeChangeOwnerOk(src: ChangeOwnerOk): (builder: Builder) => void;
export declare function loadChangeOwnerOk(slice: Slice): {
    $$type: "ChangeOwnerOk";
    queryId: bigint;
    newOwner: Address;
};
export type Mint = {
    $$type: 'Mint';
    amount: bigint;
    receiver: Address;
};
export declare function storeMint(src: Mint): (builder: Builder) => void;
export declare function loadMint(slice: Slice): {
    $$type: "Mint";
    amount: bigint;
    receiver: Address;
};
export type JettonData = {
    $$type: 'JettonData';
    totalSupply: bigint;
    mintable: boolean;
    owner: Address;
    content: Cell;
    walletCode: Cell;
};
export declare function storeJettonData(src: JettonData): (builder: Builder) => void;
export declare function loadJettonData(slice: Slice): {
    $$type: "JettonData";
    totalSupply: bigint;
    mintable: boolean;
    owner: Address;
    content: Cell;
    walletCode: Cell;
};
export type SampleJetton$Data = {
    $$type: 'SampleJetton$Data';
    totalSupply: bigint;
    max_supply: bigint;
    owner: Address;
    content: Cell;
    mintable: boolean;
};
export declare function storeSampleJetton$Data(src: SampleJetton$Data): (builder: Builder) => void;
export declare function loadSampleJetton$Data(slice: Slice): {
    $$type: "SampleJetton$Data";
    totalSupply: bigint;
    max_supply: bigint;
    owner: Address;
    content: Cell;
    mintable: boolean;
};
export type TokenTransfer = {
    $$type: 'TokenTransfer';
    queryId: bigint;
    amount: bigint;
    destination: Address;
    response_destination: Address | null;
    custom_payload: Cell | null;
    forward_ton_amount: bigint;
    forward_payload: Slice;
};
export declare function storeTokenTransfer(src: TokenTransfer): (builder: Builder) => void;
export declare function loadTokenTransfer(slice: Slice): {
    $$type: "TokenTransfer";
    queryId: bigint;
    amount: bigint;
    destination: Address;
    response_destination: Address | null;
    custom_payload: Cell | null;
    forward_ton_amount: bigint;
    forward_payload: Slice;
};
export type TokenTransferInternal = {
    $$type: 'TokenTransferInternal';
    queryId: bigint;
    amount: bigint;
    from: Address;
    response_destination: Address | null;
    forward_ton_amount: bigint;
    forward_payload: Slice;
};
export declare function storeTokenTransferInternal(src: TokenTransferInternal): (builder: Builder) => void;
export declare function loadTokenTransferInternal(slice: Slice): {
    $$type: "TokenTransferInternal";
    queryId: bigint;
    amount: bigint;
    from: Address;
    response_destination: Address | null;
    forward_ton_amount: bigint;
    forward_payload: Slice;
};
export type TokenNotification = {
    $$type: 'TokenNotification';
    queryId: bigint;
    amount: bigint;
    from: Address;
    forward_payload: Slice;
};
export declare function storeTokenNotification(src: TokenNotification): (builder: Builder) => void;
export declare function loadTokenNotification(slice: Slice): {
    $$type: "TokenNotification";
    queryId: bigint;
    amount: bigint;
    from: Address;
    forward_payload: Slice;
};
export type TokenBurn = {
    $$type: 'TokenBurn';
    queryId: bigint;
    amount: bigint;
    owner: Address;
    response_destination: Address;
};
export declare function storeTokenBurn(src: TokenBurn): (builder: Builder) => void;
export declare function loadTokenBurn(slice: Slice): {
    $$type: "TokenBurn";
    queryId: bigint;
    amount: bigint;
    owner: Address;
    response_destination: Address;
};
export type TokenBurnNotification = {
    $$type: 'TokenBurnNotification';
    queryId: bigint;
    amount: bigint;
    owner: Address;
    response_destination: Address | null;
};
export declare function storeTokenBurnNotification(src: TokenBurnNotification): (builder: Builder) => void;
export declare function loadTokenBurnNotification(slice: Slice): {
    $$type: "TokenBurnNotification";
    queryId: bigint;
    amount: bigint;
    owner: Address;
    response_destination: Address | null;
};
export type TokenExcesses = {
    $$type: 'TokenExcesses';
    queryId: bigint;
};
export declare function storeTokenExcesses(src: TokenExcesses): (builder: Builder) => void;
export declare function loadTokenExcesses(slice: Slice): {
    $$type: "TokenExcesses";
    queryId: bigint;
};
export type TokenUpdateContent = {
    $$type: 'TokenUpdateContent';
    content: Cell;
};
export declare function storeTokenUpdateContent(src: TokenUpdateContent): (builder: Builder) => void;
export declare function loadTokenUpdateContent(slice: Slice): {
    $$type: "TokenUpdateContent";
    content: Cell;
};
export type JettonDefaultWallet$Data = {
    $$type: 'JettonDefaultWallet$Data';
    balance: bigint;
    owner: Address;
    master: Address;
};
export declare function storeJettonDefaultWallet$Data(src: JettonDefaultWallet$Data): (builder: Builder) => void;
export declare function loadJettonDefaultWallet$Data(slice: Slice): {
    $$type: "JettonDefaultWallet$Data";
    balance: bigint;
    owner: Address;
    master: Address;
};
export type JettonWalletData = {
    $$type: 'JettonWalletData';
    balance: bigint;
    owner: Address;
    master: Address;
    walletCode: Cell;
};
export declare function storeJettonWalletData(src: JettonWalletData): (builder: Builder) => void;
export declare function loadJettonWalletData(slice: Slice): {
    $$type: "JettonWalletData";
    balance: bigint;
    owner: Address;
    master: Address;
    walletCode: Cell;
};
export declare const SampleJetton_getterMapping: {
    [key: string]: string;
};
export declare class SampleJetton implements Contract {
    static init(owner: Address, content: Cell, max_supply: bigint): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(owner: Address, content: Cell, max_supply: bigint): Promise<SampleJetton>;
    static fromAddress(address: Address): SampleJetton;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: Mint | "Mint: 100" | "Owner: MintClose" | TokenUpdateContent | TokenBurnNotification): Promise<void>;
    getGetJettonData(provider: ContractProvider): Promise<{
        $$type: "JettonData";
        totalSupply: bigint;
        mintable: boolean;
        owner: Address;
        content: Cell;
        walletCode: Cell;
    }>;
    getGetWalletAddress(provider: ContractProvider, owner: Address): Promise<Address>;
    getOwner(provider: ContractProvider): Promise<Address>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/semantics_SemanticsTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/semantics_SemanticsTester.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type SA = {
    $$type: 'SA';
    a1: bigint;
    a2: SB;
};
export declare function storeSA(src: SA): (builder: Builder) => void;
export declare function loadSA(slice: Slice): {
    $$type: "SA";
    a1: bigint;
    a2: {
        $$type: "SB";
        b1: boolean;
        b2: {
            $$type: "SC";
            c1: bigint;
        };
        b3: bigint;
    };
};
export type SB = {
    $$type: 'SB';
    b1: boolean;
    b2: SC;
    b3: bigint;
};
export declare function storeSB(src: SB): (builder: Builder) => void;
export declare function loadSB(slice: Slice): {
    $$type: "SB";
    b1: boolean;
    b2: {
        $$type: "SC";
        c1: bigint;
    };
    b3: bigint;
};
export type SC = {
    $$type: 'SC';
    c1: bigint;
};
export declare function storeSC(src: SC): (builder: Builder) => void;
export declare function loadSC(slice: Slice): {
    $$type: "SC";
    c1: bigint;
};
export type MapWrapper = {
    $$type: 'MapWrapper';
    m: Dictionary<bigint, SA>;
};
export declare function storeMapWrapper(src: MapWrapper): (builder: Builder) => void;
export declare function loadMapWrapper(slice: Slice): {
    $$type: "MapWrapper";
    m: Dictionary<bigint, SA>;
};
export type SemanticsTester$Data = {
    $$type: 'SemanticsTester$Data';
    sC: SC;
    sB: SB;
    sA: SA;
    uB: SB;
    mA: Dictionary<bigint, SA>;
    mB: Dictionary<bigint, boolean>;
    mC: Dictionary<bigint, MapWrapper>;
    mutateContractStateResult: boolean;
};
export declare function storeSemanticsTester$Data(src: SemanticsTester$Data): (builder: Builder) => void;
export declare function loadSemanticsTester$Data(slice: Slice): {
    $$type: "SemanticsTester$Data";
    sC: {
        $$type: "SC";
        c1: bigint;
    };
    sB: {
        $$type: "SB";
        b1: boolean;
        b2: {
            $$type: "SC";
            c1: bigint;
        };
        b3: bigint;
    };
    sA: {
        $$type: "SA";
        a1: bigint;
        a2: {
            $$type: "SB";
            b1: boolean;
            b2: {
                $$type: "SC";
                c1: bigint;
            };
            b3: bigint;
        };
    };
    uB: {
        $$type: "SB";
        b1: boolean;
        b2: {
            $$type: "SC";
            c1: bigint;
        };
        b3: bigint;
    };
    mA: Dictionary<bigint, SA>;
    mB: Dictionary<bigint, boolean>;
    mC: Dictionary<bigint, MapWrapper>;
    mutateContractStateResult: boolean;
};
export declare const SemanticsTester_getterMapping: {
    [key: string]: string;
};
export declare class SemanticsTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<SemanticsTester>;
    static fromAddress(address: Address): SemanticsTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | "mutate"): Promise<void>;
    getCheckAllContractFieldsAreUnchanged(provider: ContractProvider): Promise<boolean>;
    getStructAssign1(provider: ContractProvider): Promise<boolean>;
    getStructAssign2(provider: ContractProvider): Promise<boolean>;
    getParamStruct1(provider: ContractProvider): Promise<boolean>;
    getParamStruct2(provider: ContractProvider): Promise<boolean>;
    getMutateParamStruct1(provider: ContractProvider): Promise<boolean>;
    getMutateParamStruct2(provider: ContractProvider): Promise<boolean>;
    getTestReturnedStructs(provider: ContractProvider): Promise<boolean>;
    getMutatesChainStruct1(provider: ContractProvider): Promise<boolean>;
    getMutatesChainStruct2(provider: ContractProvider): Promise<boolean>;
    getMutatesChainStruct3(provider: ContractProvider): Promise<boolean>;
    getMutatesChainStruct4(provider: ContractProvider): Promise<boolean>;
    getMutatesChainStruct5(provider: ContractProvider): Promise<boolean>;
    getMutatesChainStruct6(provider: ContractProvider): Promise<boolean>;
    getMapAssign1(provider: ContractProvider): Promise<boolean>;
    getMapAssign2(provider: ContractProvider): Promise<boolean>;
    getParamMap1(provider: ContractProvider): Promise<boolean>;
    getParamMap2(provider: ContractProvider): Promise<boolean>;
    getMutateParamMap1(provider: ContractProvider): Promise<boolean>;
    getMutateParamMap2(provider: ContractProvider): Promise<boolean>;
    getTestReturnedMaps1(provider: ContractProvider): Promise<boolean>;
    getMutateNestedMap1(provider: ContractProvider): Promise<boolean>;
    getContractAssign1(provider: ContractProvider): Promise<boolean>;
    getContractAssign2(provider: ContractProvider): Promise<boolean>;
    getParamContract(provider: ContractProvider): Promise<boolean>;
    getMutateParamContract(provider: ContractProvider): Promise<boolean>;
    getAddress(provider: ContractProvider): Promise<Address>;
    getTestReturnedContracts(provider: ContractProvider): Promise<boolean>;
    getMutateContractStateFlag(provider: ContractProvider): Promise<boolean>;
    getChangesPersisted(provider: ContractProvider): Promise<boolean>;
    getMutatesChainInt1(provider: ContractProvider): Promise<boolean>;
    getMutatesChainInt2(provider: ContractProvider): Promise<boolean>;
    getMutatesChainInt3(provider: ContractProvider): Promise<boolean>;
    getMutatesChainInt4(provider: ContractProvider): Promise<boolean>;
    getMutatesChainInt5(provider: ContractProvider): Promise<boolean>;
    getMutatesChainInt6(provider: ContractProvider): Promise<boolean>;
    getAndMutateShortCircuit(provider: ContractProvider): Promise<boolean>;
    getAndInfiniteLoopShortCircuit(provider: ContractProvider): Promise<boolean>;
    getAndExceptionShortCircuit(provider: ContractProvider): Promise<boolean>;
    getOrMutateShortCircuit(provider: ContractProvider): Promise<boolean>;
    getOrInfiniteLoopShortCircuit(provider: ContractProvider): Promise<boolean>;
    getOrExceptionShortCircuit(provider: ContractProvider): Promise<boolean>;
    getTestAddressEquality(provider: ContractProvider): Promise<boolean>;
    getTestSliceEquality1(provider: ContractProvider): Promise<boolean>;
    getTestSliceEquality2(provider: ContractProvider): Promise<boolean>;
    getTestCellEquality1(provider: ContractProvider): Promise<boolean>;
    getTestCellEquality2(provider: ContractProvider): Promise<boolean>;
    getTestCellEquality3(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/send_SendTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/send_SendTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type SendTester$Data = {
    $$type: 'SendTester$Data';
};
export declare function storeSendTester$Data(src: SendTester$Data): (builder: Builder) => void;
export declare function loadSendTester$Data(slice: Slice): {
    $$type: "SendTester$Data";
};
export declare const SendTester_getterMapping: {
    [key: string]: string;
};
export declare class SendTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<SendTester>;
    static fromAddress(address: Address): SendTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "Hello" | Deploy): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/serialization-2_SerializationTester2.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/serialization-2_SerializationTester2.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Vars = {
    $$type: 'Vars';
    a: bigint;
    b: bigint;
    c: bigint;
    d: bigint;
    e: bigint;
};
export declare function storeVars(src: Vars): (builder: Builder) => void;
export declare function loadVars(slice: Slice): {
    $$type: "Vars";
    a: bigint;
    b: bigint;
    c: bigint;
    d: bigint;
    e: bigint;
};
export type Both = {
    $$type: 'Both';
    a: Vars;
    b: Vars;
};
export declare function storeBoth(src: Both): (builder: Builder) => void;
export declare function loadBoth(slice: Slice): {
    $$type: "Both";
    a: {
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    };
    b: {
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    };
};
export type Update = {
    $$type: 'Update';
    a: Vars;
    b: Vars;
};
export declare function storeUpdate(src: Update): (builder: Builder) => void;
export declare function loadUpdate(slice: Slice): {
    $$type: "Update";
    a: {
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    };
    b: {
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    };
};
export type SerializationTester2$Data = {
    $$type: 'SerializationTester2$Data';
    a: Vars;
    b: Vars;
};
export declare function storeSerializationTester2$Data(src: SerializationTester2$Data): (builder: Builder) => void;
export declare function loadSerializationTester2$Data(slice: Slice): {
    $$type: "SerializationTester2$Data";
    a: {
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    };
    b: {
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    };
};
export declare const SerializationTester2_getterMapping: {
    [key: string]: string;
};
export declare class SerializationTester2 implements Contract {
    static init(a: Vars, b: Vars): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(a: Vars, b: Vars): Promise<SerializationTester2>;
    static fromAddress(address: Address): SerializationTester2;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | Update): Promise<void>;
    getGetA(provider: ContractProvider): Promise<{
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    }>;
    getGetAOpt(provider: ContractProvider): Promise<{
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    } | null>;
    getGetB(provider: ContractProvider): Promise<{
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    }>;
    getGetBOpt(provider: ContractProvider): Promise<{
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    } | null>;
    getGetBoth(provider: ContractProvider): Promise<{
        $$type: "Both";
        a: {
            $$type: "Vars";
            a: bigint;
            b: bigint;
            c: bigint;
            d: bigint;
            e: bigint;
        };
        b: {
            $$type: "Vars";
            a: bigint;
            b: bigint;
            c: bigint;
            d: bigint;
            e: bigint;
        };
    }>;
    getGetBothOpt(provider: ContractProvider): Promise<{
        $$type: "Both";
        a: {
            $$type: "Vars";
            a: bigint;
            b: bigint;
            c: bigint;
            d: bigint;
            e: bigint;
        };
        b: {
            $$type: "Vars";
            a: bigint;
            b: bigint;
            c: bigint;
            d: bigint;
            e: bigint;
        };
    } | null>;
    getProcess(provider: ContractProvider, src: Vars, both: Both, both2: Both | null): Promise<{
        $$type: "Vars";
        a: bigint;
        b: bigint;
        c: bigint;
        d: bigint;
        e: bigint;
    }>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/serialization-3_SerializationTester3.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/serialization-3_SerializationTester3.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Update = {
    $$type: 'Update';
    a: bigint;
    b: boolean;
    c: Cell;
    d: Slice;
    e: Builder;
    f: string;
};
export declare function storeUpdate(src: Update): (builder: Builder) => void;
export declare function loadUpdate(slice: Slice): {
    $$type: "Update";
    a: bigint;
    b: boolean;
    c: Cell;
    d: Slice;
    e: Builder;
    f: string;
};
export type SerializationTester3$Data = {
    $$type: 'SerializationTester3$Data';
    a: bigint;
    b: boolean;
    c: Cell;
    d: Slice;
    e: Builder;
    f: string;
};
export declare function storeSerializationTester3$Data(src: SerializationTester3$Data): (builder: Builder) => void;
export declare function loadSerializationTester3$Data(slice: Slice): {
    $$type: "SerializationTester3$Data";
    a: bigint;
    b: boolean;
    c: Cell;
    d: Slice;
    e: Builder;
    f: string;
};
export declare const SerializationTester3_getterMapping: {
    [key: string]: string;
};
export declare class SerializationTester3 implements Contract {
    static init(a: bigint, b: boolean, c: Cell, d: Slice, e: Builder, f: string): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(a: bigint, b: boolean, c: Cell, d: Slice, e: Builder, f: string): Promise<SerializationTester3>;
    static fromAddress(address: Address): SerializationTester3;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | Update): Promise<void>;
    getGetA(provider: ContractProvider): Promise<bigint>;
    getGetB(provider: ContractProvider): Promise<boolean>;
    getGetC(provider: ContractProvider): Promise<Cell>;
    getGetD(provider: ContractProvider): Promise<Slice>;
    getGetE(provider: ContractProvider): Promise<Builder>;
    getGetF(provider: ContractProvider): Promise<string>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/serialization_SerializationTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/serialization_SerializationTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Update = {
    $$type: 'Update';
    a: bigint;
    b: bigint;
    c: bigint;
    d: bigint;
    e: bigint;
    f: bigint;
    g: bigint;
    h: bigint;
    i: bigint;
};
export declare function storeUpdate(src: Update): (builder: Builder) => void;
export declare function loadUpdate(slice: Slice): {
    $$type: "Update";
    a: bigint;
    b: bigint;
    c: bigint;
    d: bigint;
    e: bigint;
    f: bigint;
    g: bigint;
    h: bigint;
    i: bigint;
};
export type SerializationTester$Data = {
    $$type: 'SerializationTester$Data';
    a: bigint;
    b: bigint;
    c: bigint;
    d: bigint;
    e: bigint;
    f: bigint;
    g: bigint;
    h: bigint;
    i: bigint;
};
export declare function storeSerializationTester$Data(src: SerializationTester$Data): (builder: Builder) => void;
export declare function loadSerializationTester$Data(slice: Slice): {
    $$type: "SerializationTester$Data";
    a: bigint;
    b: bigint;
    c: bigint;
    d: bigint;
    e: bigint;
    f: bigint;
    g: bigint;
    h: bigint;
    i: bigint;
};
export declare const SerializationTester_getterMapping: {
    [key: string]: string;
};
export declare class SerializationTester implements Contract {
    static init(a: bigint, b: bigint, c: bigint, d: bigint, e: bigint, f: bigint, g: bigint, h: bigint, i: bigint): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(a: bigint, b: bigint, c: bigint, d: bigint, e: bigint, f: bigint, g: bigint, h: bigint, i: bigint): Promise<SerializationTester>;
    static fromAddress(address: Address): SerializationTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | Update): Promise<void>;
    getGetA(provider: ContractProvider): Promise<bigint>;
    getGetB(provider: ContractProvider): Promise<bigint>;
    getGetC(provider: ContractProvider): Promise<bigint>;
    getGetD(provider: ContractProvider): Promise<bigint>;
    getGetE(provider: ContractProvider): Promise<bigint>;
    getGetF(provider: ContractProvider): Promise<bigint>;
    getGetG(provider: ContractProvider): Promise<bigint>;
    getGetH(provider: ContractProvider): Promise<bigint>;
    getGetI(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/stdlib_StdlibTest.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/stdlib_StdlibTest.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type StdlibTest$Data = {
    $$type: 'StdlibTest$Data';
    v: bigint;
};
export declare function storeStdlibTest$Data(src: StdlibTest$Data): (builder: Builder) => void;
export declare function loadStdlibTest$Data(slice: Slice): {
    $$type: "StdlibTest$Data";
    v: bigint;
};
export declare const StdlibTest_getterMapping: {
    [key: string]: string;
};
export declare class StdlibTest implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<StdlibTest>;
    static fromAddress(address: Address): StdlibTest;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getSliceEmpty(provider: ContractProvider, sc: Slice): Promise<boolean>;
    getSliceBits(provider: ContractProvider, sc: Slice): Promise<bigint>;
    getSliceRefs(provider: ContractProvider, sc: Slice): Promise<bigint>;
    getStoreBool(provider: ContractProvider, bl: Builder, b: boolean): Promise<Builder>;
    getLoadBool(provider: ContractProvider, sc: Slice): Promise<boolean>;
    getStoreBit(provider: ContractProvider, bl: Builder, b: boolean): Promise<Builder>;
    getLoadBit(provider: ContractProvider, sc: Slice): Promise<boolean>;
    getTvm_2023_07Upgrade(provider: ContractProvider): Promise<bigint>;
    getTvm_2024_04Upgrade(provider: ContractProvider): Promise<bigint>;
    getStoreMaybeRef(provider: ContractProvider, bl: Builder, c: Cell | null): Promise<Builder>;
    getParseStdAddress(provider: ContractProvider, slice: Slice): Promise<{
        $$type: "StdAddress";
        workchain: bigint;
        address: bigint;
    }>;
    getParseVarAddress(provider: ContractProvider, slice: Slice): Promise<{
        $$type: "VarAddress";
        workchain: bigint;
        address: Slice;
    }>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/strings_StringsTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/strings_StringsTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type StringsTester$Data = {
    $$type: 'StringsTester$Data';
};
export declare function storeStringsTester$Data(src: StringsTester$Data): (builder: Builder) => void;
export declare function loadStringsTester$Data(slice: Slice): {
    $$type: "StringsTester$Data";
};
export declare const StringsTester_getterMapping: {
    [key: string]: string;
};
export declare class StringsTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<StringsTester>;
    static fromAddress(address: Address): StringsTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | "backtick-test"): Promise<void>;
    getConstantString(provider: ContractProvider): Promise<string>;
    getConstantStringUnicode(provider: ContractProvider): Promise<string>;
    getConstantStringUnicodeLong(provider: ContractProvider): Promise<string>;
    getDynamicStringCell(provider: ContractProvider): Promise<Cell>;
    getDynamicStringCell2(provider: ContractProvider): Promise<Cell>;
    getDynamicCommentCell(provider: ContractProvider): Promise<Cell>;
    getDynamicCommentCellLarge(provider: ContractProvider): Promise<Cell>;
    getDynamicCommentStringLarge(provider: ContractProvider): Promise<string>;
    getStringWithNumber(provider: ContractProvider): Promise<string>;
    getStringWithNegativeNumber(provider: ContractProvider): Promise<string>;
    getStringWithLargeNumber(provider: ContractProvider): Promise<string>;
    getStringWithFloat(provider: ContractProvider): Promise<string>;
    getBase64(provider: ContractProvider): Promise<Slice>;
    getProcessBase64(provider: ContractProvider, src: string): Promise<Slice>;
    getStringWithEscapedChars1(provider: ContractProvider): Promise<string>;
    getStringWithEscapedChars2(provider: ContractProvider): Promise<string>;
    getStringWithEscapedChars3(provider: ContractProvider): Promise<string>;
    getStringWithEscapedChars4(provider: ContractProvider): Promise<string>;
    getStringWithEscapedChars5(provider: ContractProvider): Promise<string>;
    getStringWithEscapedChars6(provider: ContractProvider): Promise<string>;
    getStringWithAddress(provider: ContractProvider): Promise<string>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/structs_StructsTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/structs_StructsTester.d.ts" {
                import { Cell, Slice, Address, Builder, Dictionary, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type S = {
    $$type: 'S';
    a: boolean;
    b: bigint;
};
export declare function storeS(src: S): (builder: Builder) => void;
export declare function loadS(slice: Slice): {
    $$type: "S";
    a: boolean;
    b: bigint;
};
export type T = {
    $$type: 'T';
    a: bigint;
    s: S;
};
export declare function storeT(src: T): (builder: Builder) => void;
export declare function loadT(slice: Slice): {
    $$type: "T";
    a: bigint;
    s: {
        $$type: "S";
        a: boolean;
        b: bigint;
    };
};
export type MyStruct1 = {
    $$type: 'MyStruct1';
    a: bigint;
    b: bigint;
    c: bigint | null;
};
export declare function storeMyStruct1(src: MyStruct1): (builder: Builder) => void;
export declare function loadMyStruct1(slice: Slice): {
    $$type: "MyStruct1";
    a: bigint;
    b: bigint;
    c: bigint | null;
};
export type MyStruct2 = {
    $$type: 'MyStruct2';
    m: Dictionary<bigint, bigint>;
    s: MyStruct1 | null;
};
export declare function storeMyStruct2(src: MyStruct2): (builder: Builder) => void;
export declare function loadMyStruct2(slice: Slice): {
    $$type: "MyStruct2";
    m: Dictionary<bigint, bigint>;
    s: {
        $$type: "MyStruct1";
        a: bigint;
        b: bigint;
        c: bigint | null;
    } | null;
};
export type MyStruct3 = {
    $$type: 'MyStruct3';
    s: string;
};
export declare function storeMyStruct3(src: MyStruct3): (builder: Builder) => void;
export declare function loadMyStruct3(slice: Slice): {
    $$type: "MyStruct3";
    s: string;
};
export type MyMessage1 = {
    $$type: 'MyMessage1';
    a: bigint;
    s: MyStruct2;
};
export declare function storeMyMessage1(src: MyMessage1): (builder: Builder) => void;
export declare function loadMyMessage1(slice: Slice): {
    $$type: "MyMessage1";
    a: bigint;
    s: {
        $$type: "MyStruct2";
        m: Dictionary<bigint, bigint>;
        s: {
            $$type: "MyStruct1";
            a: bigint;
            b: bigint;
            c: bigint | null;
        } | null;
    };
};
export type Coin = {
    $$type: 'Coin';
    first: bigint;
    second: bigint;
};
export declare function storeCoin(src: Coin): (builder: Builder) => void;
export declare function loadCoin(slice: Slice): {
    $$type: "Coin";
    first: bigint;
    second: bigint;
};
export type VarIntegers = {
    $$type: 'VarIntegers';
    a: bigint;
    b: bigint;
    c: bigint;
    d: bigint;
};
export declare function storeVarIntegers(src: VarIntegers): (builder: Builder) => void;
export declare function loadVarIntegers(slice: Slice): {
    $$type: "VarIntegers";
    a: bigint;
    b: bigint;
    c: bigint;
    d: bigint;
};
export type IntFields = {
    $$type: 'IntFields';
    i1: bigint;
    i2: bigint;
    i3: bigint;
    i255: bigint;
    i256: bigint;
    i257: bigint;
};
export declare function storeIntFields(src: IntFields): (builder: Builder) => void;
export declare function loadIntFields(slice: Slice): {
    $$type: "IntFields";
    i1: bigint;
    i2: bigint;
    i3: bigint;
    i255: bigint;
    i256: bigint;
    i257: bigint;
};
export type UintFields = {
    $$type: 'UintFields';
    u1: bigint;
    u2: bigint;
    u3: bigint;
    u254: bigint;
    u255: bigint;
    u256: bigint;
};
export declare function storeUintFields(src: UintFields): (builder: Builder) => void;
export declare function loadUintFields(slice: Slice): {
    $$type: "UintFields";
    u1: bigint;
    u2: bigint;
    u3: bigint;
    u254: bigint;
    u255: bigint;
    u256: bigint;
};
export type LongStruct15 = {
    $$type: 'LongStruct15';
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
};
export declare function storeLongStruct15(src: LongStruct15): (builder: Builder) => void;
export declare function loadLongStruct15(slice: Slice): {
    $$type: "LongStruct15";
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
};
export type LongStruct16 = {
    $$type: 'LongStruct16';
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
};
export declare function storeLongStruct16(src: LongStruct16): (builder: Builder) => void;
export declare function loadLongStruct16(slice: Slice): {
    $$type: "LongStruct16";
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
};
export type LongStruct32 = {
    $$type: 'LongStruct32';
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    x17: bigint;
    x18: bigint;
    x19: bigint;
    x20: bigint;
    x21: bigint;
    x22: bigint;
    x23: bigint;
    x24: bigint;
    x25: bigint;
    x26: bigint;
    x27: bigint;
    x28: bigint;
    x29: bigint;
    x30: bigint;
    x31: bigint;
    x32: bigint;
};
export declare function storeLongStruct32(src: LongStruct32): (builder: Builder) => void;
export declare function loadLongStruct32(slice: Slice): {
    $$type: "LongStruct32";
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    x17: bigint;
    x18: bigint;
    x19: bigint;
    x20: bigint;
    x21: bigint;
    x22: bigint;
    x23: bigint;
    x24: bigint;
    x25: bigint;
    x26: bigint;
    x27: bigint;
    x28: bigint;
    x29: bigint;
    x30: bigint;
    x31: bigint;
    x32: bigint;
};
export type LongNestedStruct = {
    $$type: 'LongNestedStruct';
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    x17: bigint;
    x18: bigint;
    x19: bigint;
    x20: bigint;
    s1: LongStruct15;
    s2: LongStruct16;
    s3: LongStruct32;
};
export declare function storeLongNestedStruct(src: LongNestedStruct): (builder: Builder) => void;
export declare function loadLongNestedStruct(slice: Slice): {
    $$type: "LongNestedStruct";
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    x17: bigint;
    x18: bigint;
    x19: bigint;
    x20: bigint;
    s1: {
        $$type: "LongStruct15";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
    };
    s2: {
        $$type: "LongStruct16";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
    };
    s3: {
        $$type: "LongStruct32";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
        x17: bigint;
        x18: bigint;
        x19: bigint;
        x20: bigint;
        x21: bigint;
        x22: bigint;
        x23: bigint;
        x24: bigint;
        x25: bigint;
        x26: bigint;
        x27: bigint;
        x28: bigint;
        x29: bigint;
        x30: bigint;
        x31: bigint;
        x32: bigint;
    };
};
export type LongNestedStructWithOpts = {
    $$type: 'LongNestedStructWithOpts';
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    x17: bigint;
    x18: bigint | null;
    x19: bigint;
    x20: bigint;
    s1: LongStruct15 | null;
    s2: LongStruct16;
    s3: LongStruct32 | null;
};
export declare function storeLongNestedStructWithOpts(src: LongNestedStructWithOpts): (builder: Builder) => void;
export declare function loadLongNestedStructWithOpts(slice: Slice): {
    $$type: "LongNestedStructWithOpts";
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    x17: bigint;
    x18: bigint | null;
    x19: bigint;
    x20: bigint;
    s1: {
        $$type: "LongStruct15";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
    } | null;
    s2: {
        $$type: "LongStruct16";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
    };
    s3: {
        $$type: "LongStruct32";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
        x17: bigint;
        x18: bigint;
        x19: bigint;
        x20: bigint;
        x21: bigint;
        x22: bigint;
        x23: bigint;
        x24: bigint;
        x25: bigint;
        x26: bigint;
        x27: bigint;
        x28: bigint;
        x29: bigint;
        x30: bigint;
        x31: bigint;
        x32: bigint;
    } | null;
};
export type Point = {
    $$type: 'Point';
    x: bigint;
    y: bigint;
};
export declare function storePoint(src: Point): (builder: Builder) => void;
export declare function loadPoint(slice: Slice): {
    $$type: "Point";
    x: bigint;
    y: bigint;
};
export type Line = {
    $$type: 'Line';
    start: Point;
    end: Point;
};
export declare function storeLine(src: Line): (builder: Builder) => void;
export declare function loadLine(slice: Slice): {
    $$type: "Line";
    start: {
        $$type: "Point";
        x: bigint;
        y: bigint;
    };
    end: {
        $$type: "Point";
        x: bigint;
        y: bigint;
    };
};
export type Location = {
    $$type: 'Location';
    idx: bigint;
    line1: Line;
    line2: Line | null;
};
export declare function storeLocation(src: Location): (builder: Builder) => void;
export declare function loadLocation(slice: Slice): {
    $$type: "Location";
    idx: bigint;
    line1: {
        $$type: "Line";
        start: {
            $$type: "Point";
            x: bigint;
            y: bigint;
        };
        end: {
            $$type: "Point";
            x: bigint;
            y: bigint;
        };
    };
    line2: {
        $$type: "Line";
        start: {
            $$type: "Point";
            x: bigint;
            y: bigint;
        };
        end: {
            $$type: "Point";
            x: bigint;
            y: bigint;
        };
    } | null;
};
export type DoubleNestedStructOpt = {
    $$type: 'DoubleNestedStructOpt';
    a: bigint;
    s: MyStruct1 | null;
};
export declare function storeDoubleNestedStructOpt(src: DoubleNestedStructOpt): (builder: Builder) => void;
export declare function loadDoubleNestedStructOpt(slice: Slice): {
    $$type: "DoubleNestedStructOpt";
    a: bigint;
    s: {
        $$type: "MyStruct1";
        a: bigint;
        b: bigint;
        c: bigint | null;
    } | null;
};
export type TripleNestedStructOpt = {
    $$type: 'TripleNestedStructOpt';
    a: bigint;
    s: DoubleNestedStructOpt | null;
};
export declare function storeTripleNestedStructOpt(src: TripleNestedStructOpt): (builder: Builder) => void;
export declare function loadTripleNestedStructOpt(slice: Slice): {
    $$type: "TripleNestedStructOpt";
    a: bigint;
    s: {
        $$type: "DoubleNestedStructOpt";
        a: bigint;
        s: {
            $$type: "MyStruct1";
            a: bigint;
            b: bigint;
            c: bigint | null;
        } | null;
    } | null;
};
export type LongAndDeepNestedStruct = {
    $$type: 'LongAndDeepNestedStruct';
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    s1: TripleNestedStructOpt;
    s2: TripleNestedStructOpt;
    s3: TripleNestedStructOpt | null;
    s4: TripleNestedStructOpt | null;
};
export declare function storeLongAndDeepNestedStruct(src: LongAndDeepNestedStruct): (builder: Builder) => void;
export declare function loadLongAndDeepNestedStruct(slice: Slice): {
    $$type: "LongAndDeepNestedStruct";
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    s1: {
        $$type: "TripleNestedStructOpt";
        a: bigint;
        s: {
            $$type: "DoubleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "MyStruct1";
                a: bigint;
                b: bigint;
                c: bigint | null;
            } | null;
        } | null;
    };
    s2: {
        $$type: "TripleNestedStructOpt";
        a: bigint;
        s: {
            $$type: "DoubleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "MyStruct1";
                a: bigint;
                b: bigint;
                c: bigint | null;
            } | null;
        } | null;
    };
    s3: {
        $$type: "TripleNestedStructOpt";
        a: bigint;
        s: {
            $$type: "DoubleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "MyStruct1";
                a: bigint;
                b: bigint;
                c: bigint | null;
            } | null;
        } | null;
    } | null;
    s4: {
        $$type: "TripleNestedStructOpt";
        a: bigint;
        s: {
            $$type: "DoubleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "MyStruct1";
                a: bigint;
                b: bigint;
                c: bigint | null;
            } | null;
        } | null;
    } | null;
};
export type Foo = {
    $$type: 'Foo';
    s: Slice;
};
export declare function storeFoo(src: Foo): (builder: Builder) => void;
export declare function loadFoo(slice: Slice): {
    $$type: "Foo";
    s: Slice;
};
export type Dict = {
    $$type: 'Dict';
    m: Dictionary<number, bigint>;
};
export declare function storeDict(src: Dict): (builder: Builder) => void;
export declare function loadDict(slice: Slice): {
    $$type: "Dict";
    m: Dictionary<number, bigint>;
};
export type OptionalFields = {
    $$type: 'OptionalFields';
    nickname: string | null;
    avatar: string | null;
};
export declare function storeOptionalFields(src: OptionalFields): (builder: Builder) => void;
export declare function loadOptionalFields(slice: Slice): {
    $$type: "OptionalFields";
    nickname: string | null;
    avatar: string | null;
};
export type S1 = {
    $$type: 'S1';
    a: bigint;
    b: bigint;
    c: bigint;
};
export declare function storeS1(src: S1): (builder: Builder) => void;
export declare function loadS1(slice: Slice): {
    $$type: "S1";
    a: bigint;
    b: bigint;
    c: bigint;
};
export type StructsTester$Data = {
    $$type: 'StructsTester$Data';
    s1: S;
    s2: S;
    t1: T;
    t2: T;
    mapWithLongStructs15: Dictionary<bigint, LongStruct15>;
    mapWithLongStructs16: Dictionary<bigint, LongStruct16>;
    mapWithLongStructs32: Dictionary<bigint, LongStruct32>;
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    x17: bigint;
    x18: bigint;
    x19: bigint;
    x20: bigint;
};
export declare function storeStructsTester$Data(src: StructsTester$Data): (builder: Builder) => void;
export declare function loadStructsTester$Data(slice: Slice): {
    $$type: "StructsTester$Data";
    s1: {
        $$type: "S";
        a: boolean;
        b: bigint;
    };
    s2: {
        $$type: "S";
        a: boolean;
        b: bigint;
    };
    t1: {
        $$type: "T";
        a: bigint;
        s: {
            $$type: "S";
            a: boolean;
            b: bigint;
        };
    };
    t2: {
        $$type: "T";
        a: bigint;
        s: {
            $$type: "S";
            a: boolean;
            b: bigint;
        };
    };
    mapWithLongStructs15: Dictionary<bigint, LongStruct15>;
    mapWithLongStructs16: Dictionary<bigint, LongStruct16>;
    mapWithLongStructs32: Dictionary<bigint, LongStruct32>;
    x1: bigint;
    x2: bigint;
    x3: bigint;
    x4: bigint;
    x5: bigint;
    x6: bigint;
    x7: bigint;
    x8: bigint;
    x9: bigint;
    x10: bigint;
    x11: bigint;
    x12: bigint;
    x13: bigint;
    x14: bigint;
    x15: bigint;
    x16: bigint;
    x17: bigint;
    x18: bigint;
    x19: bigint;
    x20: bigint;
};
export declare const StructsTester_getterMapping: {
    [key: string]: string;
};
export declare class StructsTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<StructsTester>;
    static fromAddress(address: Address): StructsTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | Foo | "example" | "exampleVarIntegers"): Promise<void>;
    getStructInitializerTest(provider: ContractProvider): Promise<boolean>;
    getToCell1(provider: ContractProvider, s: MyStruct1): Promise<Cell>;
    getToSlice1(provider: ContractProvider, s: MyStruct1): Promise<Slice>;
    getFromCell1(provider: ContractProvider, src: Cell): Promise<{
        $$type: "MyStruct1";
        a: bigint;
        b: bigint;
        c: bigint | null;
    }>;
    getFromSlice1(provider: ContractProvider, src: Slice): Promise<{
        $$type: "MyStruct1";
        a: bigint;
        b: bigint;
        c: bigint | null;
    }>;
    getToCell2(provider: ContractProvider, s: MyStruct2): Promise<Cell>;
    getFromCell2(provider: ContractProvider, src: Cell): Promise<{
        $$type: "MyStruct2";
        m: Dictionary<bigint, bigint>;
        s: {
            $$type: "MyStruct1";
            a: bigint;
            b: bigint;
            c: bigint | null;
        } | null;
    }>;
    getFromSlice2(provider: ContractProvider, src: Slice): Promise<{
        $$type: "MyStruct2";
        m: Dictionary<bigint, bigint>;
        s: {
            $$type: "MyStruct1";
            a: bigint;
            b: bigint;
            c: bigint | null;
        } | null;
    }>;
    getTest1(provider: ContractProvider, s1: MyStruct1, s2: MyStruct2): Promise<Cell>;
    getToCellMessage1(provider: ContractProvider, m: MyMessage1): Promise<Cell>;
    getFromCellMessage1(provider: ContractProvider, src: Cell): Promise<{
        $$type: "MyMessage1";
        a: bigint;
        s: {
            $$type: "MyStruct2";
            m: Dictionary<bigint, bigint>;
            s: {
                $$type: "MyStruct1";
                a: bigint;
                b: bigint;
                c: bigint | null;
            } | null;
        };
    }>;
    getFromSliceMessage1(provider: ContractProvider, src: Slice): Promise<{
        $$type: "MyMessage1";
        a: bigint;
        s: {
            $$type: "MyStruct2";
            m: Dictionary<bigint, bigint>;
            s: {
                $$type: "MyStruct1";
                a: bigint;
                b: bigint;
                c: bigint | null;
            } | null;
        };
    }>;
    getContractStructConstantImmediate(provider: ContractProvider): Promise<{
        $$type: "MyStruct3";
        s: string;
    }>;
    getGlobalConstStructConstantImmediate(provider: ContractProvider): Promise<{
        $$type: "MyStruct3";
        s: string;
    }>;
    getContractStructConstantFieldImmediate(provider: ContractProvider): Promise<string>;
    getGlobalConstStructConstantFieldImmediate(provider: ContractProvider): Promise<string>;
    getContractStructConstantViaVar(provider: ContractProvider): Promise<{
        $$type: "MyStruct3";
        s: string;
    }>;
    getGlobalConstStructConstantViaVar(provider: ContractProvider): Promise<{
        $$type: "MyStruct3";
        s: string;
    }>;
    getContractStructConstantFieldViaVar(provider: ContractProvider): Promise<string>;
    getGlobalConstStructConstantFieldViaVar(provider: ContractProvider): Promise<string>;
    getLongStruct15Test(provider: ContractProvider): Promise<{
        $$type: "LongStruct15";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
    }>;
    getLongStruct16Test(provider: ContractProvider): Promise<{
        $$type: "LongStruct16";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
    }>;
    getLongStruct32Test(provider: ContractProvider): Promise<{
        $$type: "LongStruct32";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
        x17: bigint;
        x18: bigint;
        x19: bigint;
        x20: bigint;
        x21: bigint;
        x22: bigint;
        x23: bigint;
        x24: bigint;
        x25: bigint;
        x26: bigint;
        x27: bigint;
        x28: bigint;
        x29: bigint;
        x30: bigint;
        x31: bigint;
        x32: bigint;
    }>;
    getLongNestedStructTest(provider: ContractProvider): Promise<{
        $$type: "LongNestedStruct";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
        x17: bigint;
        x18: bigint;
        x19: bigint;
        x20: bigint;
        s1: {
            $$type: "LongStruct15";
            x1: bigint;
            x2: bigint;
            x3: bigint;
            x4: bigint;
            x5: bigint;
            x6: bigint;
            x7: bigint;
            x8: bigint;
            x9: bigint;
            x10: bigint;
            x11: bigint;
            x12: bigint;
            x13: bigint;
            x14: bigint;
            x15: bigint;
        };
        s2: {
            $$type: "LongStruct16";
            x1: bigint;
            x2: bigint;
            x3: bigint;
            x4: bigint;
            x5: bigint;
            x6: bigint;
            x7: bigint;
            x8: bigint;
            x9: bigint;
            x10: bigint;
            x11: bigint;
            x12: bigint;
            x13: bigint;
            x14: bigint;
            x15: bigint;
            x16: bigint;
        };
        s3: {
            $$type: "LongStruct32";
            x1: bigint;
            x2: bigint;
            x3: bigint;
            x4: bigint;
            x5: bigint;
            x6: bigint;
            x7: bigint;
            x8: bigint;
            x9: bigint;
            x10: bigint;
            x11: bigint;
            x12: bigint;
            x13: bigint;
            x14: bigint;
            x15: bigint;
            x16: bigint;
            x17: bigint;
            x18: bigint;
            x19: bigint;
            x20: bigint;
            x21: bigint;
            x22: bigint;
            x23: bigint;
            x24: bigint;
            x25: bigint;
            x26: bigint;
            x27: bigint;
            x28: bigint;
            x29: bigint;
            x30: bigint;
            x31: bigint;
            x32: bigint;
        };
    }>;
    getLongNestedStructWithOptsTest(provider: ContractProvider): Promise<{
        $$type: "LongNestedStructWithOpts";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
        x17: bigint;
        x18: bigint | null;
        x19: bigint;
        x20: bigint;
        s1: {
            $$type: "LongStruct15";
            x1: bigint;
            x2: bigint;
            x3: bigint;
            x4: bigint;
            x5: bigint;
            x6: bigint;
            x7: bigint;
            x8: bigint;
            x9: bigint;
            x10: bigint;
            x11: bigint;
            x12: bigint;
            x13: bigint;
            x14: bigint;
            x15: bigint;
        } | null;
        s2: {
            $$type: "LongStruct16";
            x1: bigint;
            x2: bigint;
            x3: bigint;
            x4: bigint;
            x5: bigint;
            x6: bigint;
            x7: bigint;
            x8: bigint;
            x9: bigint;
            x10: bigint;
            x11: bigint;
            x12: bigint;
            x13: bigint;
            x14: bigint;
            x15: bigint;
            x16: bigint;
        };
        s3: {
            $$type: "LongStruct32";
            x1: bigint;
            x2: bigint;
            x3: bigint;
            x4: bigint;
            x5: bigint;
            x6: bigint;
            x7: bigint;
            x8: bigint;
            x9: bigint;
            x10: bigint;
            x11: bigint;
            x12: bigint;
            x13: bigint;
            x14: bigint;
            x15: bigint;
            x16: bigint;
            x17: bigint;
            x18: bigint;
            x19: bigint;
            x20: bigint;
            x21: bigint;
            x22: bigint;
            x23: bigint;
            x24: bigint;
            x25: bigint;
            x26: bigint;
            x27: bigint;
            x28: bigint;
            x29: bigint;
            x30: bigint;
            x31: bigint;
            x32: bigint;
        } | null;
    }>;
    getLongContractTest(provider: ContractProvider): Promise<bigint>;
    getLocation1(provider: ContractProvider): Promise<{
        $$type: "Location";
        idx: bigint;
        line1: {
            $$type: "Line";
            start: {
                $$type: "Point";
                x: bigint;
                y: bigint;
            };
            end: {
                $$type: "Point";
                x: bigint;
                y: bigint;
            };
        };
        line2: {
            $$type: "Line";
            start: {
                $$type: "Point";
                x: bigint;
                y: bigint;
            };
            end: {
                $$type: "Point";
                x: bigint;
                y: bigint;
            };
        } | null;
    }>;
    getLocation2(provider: ContractProvider): Promise<{
        $$type: "Location";
        idx: bigint;
        line1: {
            $$type: "Line";
            start: {
                $$type: "Point";
                x: bigint;
                y: bigint;
            };
            end: {
                $$type: "Point";
                x: bigint;
                y: bigint;
            };
        };
        line2: {
            $$type: "Line";
            start: {
                $$type: "Point";
                x: bigint;
                y: bigint;
            };
            end: {
                $$type: "Point";
                x: bigint;
                y: bigint;
            };
        } | null;
    }>;
    getTripleNestedStructOpt1(provider: ContractProvider): Promise<{
        $$type: "TripleNestedStructOpt";
        a: bigint;
        s: {
            $$type: "DoubleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "MyStruct1";
                a: bigint;
                b: bigint;
                c: bigint | null;
            } | null;
        } | null;
    }>;
    getTripleNestedStructOpt2(provider: ContractProvider): Promise<{
        $$type: "TripleNestedStructOpt";
        a: bigint;
        s: {
            $$type: "DoubleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "MyStruct1";
                a: bigint;
                b: bigint;
                c: bigint | null;
            } | null;
        } | null;
    }>;
    getTripleNestedStructOpt3(provider: ContractProvider): Promise<{
        $$type: "TripleNestedStructOpt";
        a: bigint;
        s: {
            $$type: "DoubleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "MyStruct1";
                a: bigint;
                b: bigint;
                c: bigint | null;
            } | null;
        } | null;
    }>;
    getLongAndDeepNestedStruct1(provider: ContractProvider): Promise<{
        $$type: "LongAndDeepNestedStruct";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
        s1: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        };
        s2: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        };
        s3: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        } | null;
        s4: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        } | null;
    }>;
    getLongAndDeepNestedStruct2(provider: ContractProvider): Promise<{
        $$type: "LongAndDeepNestedStruct";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
        s1: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        };
        s2: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        };
        s3: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        } | null;
        s4: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        } | null;
    }>;
    getLongAndDeepNestedStruct3(provider: ContractProvider): Promise<{
        $$type: "LongAndDeepNestedStruct";
        x1: bigint;
        x2: bigint;
        x3: bigint;
        x4: bigint;
        x5: bigint;
        x6: bigint;
        x7: bigint;
        x8: bigint;
        x9: bigint;
        x10: bigint;
        x11: bigint;
        x12: bigint;
        x13: bigint;
        x14: bigint;
        x15: bigint;
        x16: bigint;
        s1: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        };
        s2: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        };
        s3: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        } | null;
        s4: {
            $$type: "TripleNestedStructOpt";
            a: bigint;
            s: {
                $$type: "DoubleNestedStructOpt";
                a: bigint;
                s: {
                    $$type: "MyStruct1";
                    a: bigint;
                    b: bigint;
                    c: bigint | null;
                } | null;
            } | null;
        } | null;
    }>;
    getIntFieldsStruct(provider: ContractProvider): Promise<{
        $$type: "IntFields";
        i1: bigint;
        i2: bigint;
        i3: bigint;
        i255: bigint;
        i256: bigint;
        i257: bigint;
    }>;
    getIntFieldsFromCell(provider: ContractProvider, src: Cell): Promise<{
        $$type: "IntFields";
        i1: bigint;
        i2: bigint;
        i3: bigint;
        i255: bigint;
        i256: bigint;
        i257: bigint;
    }>;
    getUintFieldsMessage(provider: ContractProvider): Promise<{
        $$type: "UintFields";
        u1: bigint;
        u2: bigint;
        u3: bigint;
        u254: bigint;
        u255: bigint;
        u256: bigint;
    }>;
    getUintFieldsFromCell(provider: ContractProvider, src: Cell): Promise<{
        $$type: "UintFields";
        u1: bigint;
        u2: bigint;
        u3: bigint;
        u254: bigint;
        u255: bigint;
        u256: bigint;
    }>;
    getOptionalFields(provider: ContractProvider): Promise<{
        $$type: "OptionalFields";
        nickname: string | null;
        avatar: string | null;
    }>;
    getDestructuringTest1(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest1Const(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest2(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest2Const(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest3(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest3Const(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest4(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest4Const(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest5(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest5Const(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest6(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest6Const(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest7(provider: ContractProvider): Promise<{
        $$type: "S1";
        a: bigint;
        b: bigint;
        c: bigint;
    }>;
    getDestructuringTest7Const(provider: ContractProvider): Promise<{
        $$type: "S1";
        a: bigint;
        b: bigint;
        c: bigint;
    }>;
    getDestructuringTest8(provider: ContractProvider): Promise<bigint>;
    getDestructuringTest8Const(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/ternary_TernaryTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/ternary_TernaryTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type TernaryTester$Data = {
    $$type: 'TernaryTester$Data';
};
export declare function storeTernaryTester$Data(src: TernaryTester$Data): (builder: Builder) => void;
export declare function loadTernaryTester$Data(slice: Slice): {
    $$type: "TernaryTester$Data";
};
export declare const TernaryTester_getterMapping: {
    [key: string]: string;
};
export declare class TernaryTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<TernaryTester>;
    static fromAddress(address: Address): TernaryTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTest1(provider: ContractProvider, a: bigint): Promise<bigint>;
    getTest2(provider: ContractProvider, a: bigint): Promise<bigint>;
    getTest3(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getTest4(provider: ContractProvider, a: bigint, b: bigint): Promise<bigint>;
    getTest5(provider: ContractProvider): Promise<bigint>;
    getTest6(provider: ContractProvider): Promise<bigint>;
    getTest7(provider: ContractProvider): Promise<bigint>;
    getTest8(provider: ContractProvider): Promise<bigint>;
    getTest9(provider: ContractProvider): Promise<bigint>;
    getTest10(provider: ContractProvider, a: bigint): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/text-message-receivers_TextMessageReceivers.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/text-message-receivers_TextMessageReceivers.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type Deploy = {
    $$type: 'Deploy';
    queryId: bigint;
};
export declare function storeDeploy(src: Deploy): (builder: Builder) => void;
export declare function loadDeploy(slice: Slice): {
    $$type: "Deploy";
    queryId: bigint;
};
export type DeployOk = {
    $$type: 'DeployOk';
    queryId: bigint;
};
export declare function storeDeployOk(src: DeployOk): (builder: Builder) => void;
export declare function loadDeployOk(slice: Slice): {
    $$type: "DeployOk";
    queryId: bigint;
};
export type FactoryDeploy = {
    $$type: 'FactoryDeploy';
    queryId: bigint;
    cashback: Address;
};
export declare function storeFactoryDeploy(src: FactoryDeploy): (builder: Builder) => void;
export declare function loadFactoryDeploy(slice: Slice): {
    $$type: "FactoryDeploy";
    queryId: bigint;
    cashback: Address;
};
export type TextMessageReceivers$Data = {
    $$type: 'TextMessageReceivers$Data';
    counter: bigint;
};
export declare function storeTextMessageReceivers$Data(src: TextMessageReceivers$Data): (builder: Builder) => void;
export declare function loadTextMessageReceivers$Data(slice: Slice): {
    $$type: "TextMessageReceivers$Data";
    counter: bigint;
};
export declare const TextMessageReceivers_getterMapping: {
    [key: string]: string;
};
export declare class TextMessageReceivers implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<TextMessageReceivers>;
    static fromAddress(address: Address): TextMessageReceivers;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: "increment'" | "increment-2\\\"" | "increment-3`" | "\\\\increment-4\\\\" | Deploy): Promise<void>;
    getGetCounter(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/traits_LaikaContract.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/traits_LaikaContract.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type LaikaContract$Data = {
    $$type: 'LaikaContract$Data';
};
export declare function storeLaikaContract$Data(src: LaikaContract$Data): (builder: Builder) => void;
export declare function loadLaikaContract$Data(slice: Slice): {
    $$type: "LaikaContract$Data";
};
export declare const LaikaContract_getterMapping: {
    [key: string]: string;
};
export declare class LaikaContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<LaikaContract>;
    static fromAddress(address: Address): LaikaContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | "make sound"): Promise<void>;
    getSay(provider: ContractProvider): Promise<string>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/try-catch_TryCatchTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/try-catch_TryCatchTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type TryCatchTester$Data = {
    $$type: 'TryCatchTester$Data';
    counter: bigint;
};
export declare function storeTryCatchTester$Data(src: TryCatchTester$Data): (builder: Builder) => void;
export declare function loadTryCatchTester$Data(slice: Slice): {
    $$type: "TryCatchTester$Data";
    counter: bigint;
};
export declare const TryCatchTester_getterMapping: {
    [key: string]: string;
};
export declare class TryCatchTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<TryCatchTester>;
    static fromAddress(address: Address): TryCatchTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | "increment" | "incrementTryCatch" | "tryCatchRegisters"): Promise<void>;
    getGetCounter(provider: ContractProvider): Promise<bigint>;
    getTestTryCatch1(provider: ContractProvider): Promise<bigint>;
    getTestTryCatch2(provider: ContractProvider): Promise<bigint>;
    getTestTryCatch3(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/contracts/output/underscore-variable_UnderscoreVariableTestContract.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/contracts/output/underscore-variable_UnderscoreVariableTestContract.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type UnderscoreVariableTestContract$Data = {
    $$type: 'UnderscoreVariableTestContract$Data';
    something: bigint;
};
export declare function storeUnderscoreVariableTestContract$Data(src: UnderscoreVariableTestContract$Data): (builder: Builder) => void;
export declare function loadUnderscoreVariableTestContract$Data(slice: Slice): {
    $$type: "UnderscoreVariableTestContract$Data";
    something: bigint;
};
export declare const UnderscoreVariableTestContract_getterMapping: {
    [key: string]: string;
};
export declare class UnderscoreVariableTestContract implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<UnderscoreVariableTestContract>;
    static fromAddress(address: Address): UnderscoreVariableTestContract;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTest1(provider: ContractProvider): Promise<bigint>;
    getTest2(provider: ContractProvider): Promise<bigint>;
    getTest3(provider: ContractProvider): Promise<bigint>;
    getTest4(provider: ContractProvider): Promise<bigint>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int10_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int256_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int257_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int2_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-int37_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint256_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint2_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint32_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int-as-uint8_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-coins/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-coins/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int10/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int10/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int257/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int257/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int37/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-int37/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-uint2/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-uint2/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-uint256/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-uint256/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-uint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-uint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-uint8/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-uint8/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-varint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-varint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-varint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-varint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-varuint16/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-varuint16/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-varuint32/test_MapIntLimitTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-int-limits_Int_Int-as-varuint32/test_MapIntLimitTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type MapIntLimitTester$Data = {
    $$type: 'MapIntLimitTester$Data';
};
export declare function storeMapIntLimitTester$Data(src: MapIntLimitTester$Data): (builder: Builder) => void;
export declare function loadMapIntLimitTester$Data(slice: Slice): {
    $$type: "MapIntLimitTester$Data";
};
export declare const MapIntLimitTester_getterMapping: {
    [key: string]: string;
};
export declare class MapIntLimitTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapIntLimitTester>;
    static fromAddress(address: Address): MapIntLimitTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestSetMinAndMaxDoesNotThrow(provider: ContractProvider): Promise<boolean>;
    getTestGetGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestGetSmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetKeyGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetKeySmallerThanMin(provider: ContractProvider): Promise<boolean>;
    getTestSetValGreaterThanMax(provider: ContractProvider): Promise<boolean>;
    getTestSetValSmallerThanMin(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Address/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Address/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: Address;
    _2: Address;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Address;
    _2: Address;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Bool/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Bool/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: boolean;
    _2: boolean;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: boolean;
    _2: boolean;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Cell/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Cell/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: Cell;
    _2: Cell;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Cell;
    _2: Cell;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-coins/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-coins/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-int257/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-int257/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-int42/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-int42/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-int8/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-int8/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-uint256/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-uint256/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-uint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-uint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-uint9/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-uint9/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-varint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-varint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-varint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-varint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-varuint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-varuint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-varuint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_Int-as-varuint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_SomeMessage/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_SomeMessage/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeMessage;
    _2: SomeMessage;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
    _2: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_SomeStruct/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Address_SomeStruct/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: Address;
    _2: Address;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: Address;
    _2: Address;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeStruct;
    _2: SomeStruct;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
    _2: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Address/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Address/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Address;
    _2: Address;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Address;
    _2: Address;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Bool/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Bool/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: boolean;
    _2: boolean;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: boolean;
    _2: boolean;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Cell/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Cell/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Cell;
    _2: Cell;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Cell;
    _2: Cell;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-coins/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-coins/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-int257/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-int257/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-int42/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-int42/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-int8/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-int8/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-uint256/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-uint256/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-uint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-uint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-uint9/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-uint9/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-varint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-varint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-varint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-varint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-varuint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-varuint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-varuint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_Int-as-varuint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_SomeMessage/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_SomeMessage/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeMessage;
    _2: SomeMessage;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
    _2: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_SomeStruct/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int257_SomeStruct/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeStruct;
    _2: SomeStruct;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
    _2: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Address/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Address/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Address;
    _2: Address;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Address;
    _2: Address;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Bool/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Bool/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: boolean;
    _2: boolean;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: boolean;
    _2: boolean;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Cell/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Cell/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Cell;
    _2: Cell;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Cell;
    _2: Cell;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-coins/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-coins/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-int257/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-int257/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-int42/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-int42/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-int8/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-int8/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-uint256/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-uint256/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-uint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-uint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-uint9/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-uint9/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-varint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-varint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-varint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-varint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-varuint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-varuint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-varuint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_Int-as-varuint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_SomeMessage/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_SomeMessage/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeMessage;
    _2: SomeMessage;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
    _2: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_SomeStruct/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int42_SomeStruct/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeStruct;
    _2: SomeStruct;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
    _2: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Address/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Address/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Address;
    _2: Address;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Address;
    _2: Address;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Bool/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Bool/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: boolean;
    _2: boolean;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: boolean;
    _2: boolean;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Cell/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Cell/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Cell;
    _2: Cell;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Cell;
    _2: Cell;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-coins/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-coins/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-int257/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-int257/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-int42/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-int42/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-int8/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-int8/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-uint256/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-uint256/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-uint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-uint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-uint9/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-uint9/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-varint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-varint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-varint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-varint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-varuint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-varuint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-varuint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_Int-as-varuint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_SomeMessage/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_SomeMessage/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeMessage;
    _2: SomeMessage;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
    _2: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_SomeStruct/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-int8_SomeStruct/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeStruct;
    _2: SomeStruct;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
    _2: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Address/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Address/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Address;
    _2: Address;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Address;
    _2: Address;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Bool/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Bool/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: boolean;
    _2: boolean;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: boolean;
    _2: boolean;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Cell/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Cell/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Cell;
    _2: Cell;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Cell;
    _2: Cell;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-coins/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-coins/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-int257/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-int257/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-int42/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-int42/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-int8/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-int8/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-uint256/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-uint256/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-uint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-uint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-uint9/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-uint9/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-varint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-varint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-varint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-varint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-varuint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-varuint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-varuint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_Int-as-varuint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_SomeMessage/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_SomeMessage/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeMessage;
    _2: SomeMessage;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
    _2: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_SomeStruct/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint256_SomeStruct/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeStruct;
    _2: SomeStruct;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
    _2: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Address/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Address/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Address;
    _2: Address;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Address;
    _2: Address;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Bool/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Bool/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: boolean;
    _2: boolean;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: boolean;
    _2: boolean;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Cell/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Cell/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Cell;
    _2: Cell;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Cell;
    _2: Cell;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-coins/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-coins/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-int257/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-int257/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-int42/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-int42/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-int8/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-int8/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-uint256/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-uint256/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-uint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-uint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-uint9/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-uint9/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-varint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-varint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-varint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-varint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-varuint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-varuint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-varuint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_Int-as-varuint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_SomeMessage/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_SomeMessage/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeMessage;
    _2: SomeMessage;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
    _2: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_SomeStruct/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint32_SomeStruct/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeStruct;
    _2: SomeStruct;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
    _2: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Address/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Address/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Address;
    _2: Address;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Address;
    _2: Address;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Bool/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Bool/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: boolean;
    _2: boolean;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: boolean;
    _2: boolean;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Cell/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Cell/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: Cell;
    _2: Cell;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: Cell;
    _2: Cell;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-coins/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-coins/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-int257/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-int257/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-int42/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-int42/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-int8/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-int8/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-uint256/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-uint256/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-uint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-uint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-uint9/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-uint9/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-varint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-varint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-varint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-varint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-varuint16/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-varuint16/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-varuint32/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_Int-as-varuint32/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: bigint;
    _2: bigint;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: bigint;
    _2: bigint;
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_SomeMessage/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_SomeMessage/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeMessage;
    _2: SomeMessage;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
    _2: {
        $$type: "SomeMessage";
        buyer: Address;
        nonce: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_SomeStruct/test_MapPropertiesTester.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/build/map-properties_Int-as-uint9_SomeStruct/test_MapPropertiesTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type KeyData = {
    $$type: 'KeyData';
    _1: bigint;
    _2: bigint;
};
export declare function storeKeyData(src: KeyData): (builder: Builder) => void;
export declare function loadKeyData(slice: Slice): {
    $$type: "KeyData";
    _1: bigint;
    _2: bigint;
};
export type ValData = {
    $$type: 'ValData';
    _1: SomeStruct;
    _2: SomeStruct;
};
export declare function storeValData(src: ValData): (builder: Builder) => void;
export declare function loadValData(slice: Slice): {
    $$type: "ValData";
    _1: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
    _2: {
        $$type: "SomeStruct";
        i: bigint;
        b: boolean;
        a: Address;
        u1: bigint;
        u2: bigint;
    };
};
export type SomeStruct = {
    $$type: 'SomeStruct';
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export declare function storeSomeStruct(src: SomeStruct): (builder: Builder) => void;
export declare function loadSomeStruct(slice: Slice): {
    $$type: "SomeStruct";
    i: bigint;
    b: boolean;
    a: Address;
    u1: bigint;
    u2: bigint;
};
export type SomeMessage = {
    $$type: 'SomeMessage';
    buyer: Address;
    nonce: bigint;
};
export declare function storeSomeMessage(src: SomeMessage): (builder: Builder) => void;
export declare function loadSomeMessage(slice: Slice): {
    $$type: "SomeMessage";
    buyer: Address;
    nonce: bigint;
};
export type MapPropertiesTester$Data = {
    $$type: 'MapPropertiesTester$Data';
};
export declare function storeMapPropertiesTester$Data(src: MapPropertiesTester$Data): (builder: Builder) => void;
export declare function loadMapPropertiesTester$Data(slice: Slice): {
    $$type: "MapPropertiesTester$Data";
};
export declare const MapPropertiesTester_getterMapping: {
    [key: string]: string;
};
export declare class MapPropertiesTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<MapPropertiesTester>;
    static fromAddress(address: Address): MapPropertiesTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null): Promise<void>;
    getTestEmptyMapGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelGetSameKeyMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfPresentModifies(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelDelOfSameDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetDelOfMissingDoesNotModify(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSamePresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfSameMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelSetOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSingletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDoubletonMapSize(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestGetNonNullEquivalentExists(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestNonEmptyMapsNotIsEmpty(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEqualsImpliesDeepEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestThereDeepEqualMapsThatAreNotEqual(provider: ContractProvider, _key: KeyData, _val: ValData): Promise<boolean>;
    getTestAsCellEquals(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestAsCellDoesNothing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceEmptyMap(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceDoesNotModifyIfKeyIsMissing(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceWorksAsSetIfKeyIsPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetSameKeyIfPresent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceGetNotSameKey(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceIdempotent(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestReplaceReplaceOfNotSameCommutes(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestEmptyMapReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestDelReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
    getTestSetReplaceGet(provider: ContractProvider, key: KeyData, val: ValData): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/generate.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/generate.d.ts" {
                export {};

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/map-int-limits-key-value-types.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/map-int-limits-key-value-types.d.ts" {
                type FixedWidthFormat = "int" | "uint";
type VarWidthFormat = "varint" | "varuint";
type MapIntKeyDescription = {
    format: FixedWidthFormat;
    size: number;
} | {
    format: null;
};
type MapIntValDescription = MapIntKeyDescription | {
    format: VarWidthFormat;
    size: 16 | 32;
} | {
    format: "coins";
};
export declare const minInt: (descr: MapIntValDescription) => bigint;
export declare const maxInt: (descr: MapIntValDescription) => bigint;
export declare const descriptionToString: (descr: MapIntValDescription) => string;
export declare const intKeyFormats: MapIntKeyDescription[];
export declare const intValFormats: MapIntValDescription[];
export {};

            };
/// <amd-module name="tact-compiler/test/e2e-emulated/map-tests/map-properties-key-value-types.d.ts" /> 
 declare module "tact-compiler/test/e2e-emulated/map-tests/map-properties-key-value-types.d.ts" {
                type MapType = {
    type: string;
    _1: string;
    _2: string;
};
export declare const keyTypes: MapType[];
export declare const valTypes: MapType[];
export {};

            };
/// <amd-module name="tact-compiler/test/exit-codes/contracts/output/compute-phase-errors_ComputePhaseErrorsTester.d.ts" /> 
 declare module "tact-compiler/test/exit-codes/contracts/output/compute-phase-errors_ComputePhaseErrorsTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type ComputePhaseErrorsTester$Data = {
    $$type: 'ComputePhaseErrorsTester$Data';
    tmpI: bigint;
    tmpC: Cell;
};
export declare function storeComputePhaseErrorsTester$Data(src: ComputePhaseErrorsTester$Data): (builder: Builder) => void;
export declare function loadComputePhaseErrorsTester$Data(slice: Slice): {
    $$type: "ComputePhaseErrorsTester$Data";
    tmpI: bigint;
    tmpC: Cell;
};
export type ExitCode4 = {
    $$type: 'ExitCode4';
    val0: bigint;
    val1: bigint;
};
export declare function storeExitCode4(src: ExitCode4): (builder: Builder) => void;
export declare function loadExitCode4(slice: Slice): {
    $$type: "ExitCode4";
    val0: bigint;
    val1: bigint;
};
export declare const ComputePhaseErrorsTester_getterMapping: {
    [key: string]: string;
};
export declare class ComputePhaseErrorsTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<ComputePhaseErrorsTester>;
    static fromAddress(address: Address): ComputePhaseErrorsTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | "0" | "1" | "2" | "3" | ExitCode4 | "5" | "6" | "7" | "8" | "9" | "10" | "11" | "13"): Promise<void>;
}

            };
/// <amd-module name="tact-compiler/test/exit-codes/contracts/output/repeat-range_RepeatRangeTester.d.ts" /> 
 declare module "tact-compiler/test/exit-codes/contracts/output/repeat-range_RepeatRangeTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type RepeatRangeTester$Data = {
    $$type: 'RepeatRangeTester$Data';
};
export declare function storeRepeatRangeTester$Data(src: RepeatRangeTester$Data): (builder: Builder) => void;
export declare function loadRepeatRangeTester$Data(slice: Slice): {
    $$type: "RepeatRangeTester$Data";
};
export declare const RepeatRangeTester_getterMapping: {
    [key: string]: string;
};
export declare class RepeatRangeTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<RepeatRangeTester>;
    static fromAddress(address: Address): RepeatRangeTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | "testMaxEffectiveRange"): Promise<void>;
    getTestIgnoredRange(provider: ContractProvider): Promise<boolean>;
    getTestInvalidRange(provider: ContractProvider): Promise<boolean>;
    getTestMinEffectiveRange(provider: ContractProvider): Promise<boolean>;
}

            };
/// <amd-module name="tact-compiler/test/exit-codes/contracts/output/tact-reserved-contract-errors_ReservedContractErrorsTester.d.ts" /> 
 declare module "tact-compiler/test/exit-codes/contracts/output/tact-reserved-contract-errors_ReservedContractErrorsTester.d.ts" {
                import { Cell, Slice, Address, Builder, ContractProvider, Sender, Contract, ContractABI } from '@ton/core';
export type StateInit = {
    $$type: 'StateInit';
    code: Cell;
    data: Cell;
};
export declare function storeStateInit(src: StateInit): (builder: Builder) => void;
export declare function loadStateInit(slice: Slice): {
    $$type: "StateInit";
    code: Cell;
    data: Cell;
};
export type StdAddress = {
    $$type: 'StdAddress';
    workchain: bigint;
    address: bigint;
};
export declare function storeStdAddress(src: StdAddress): (builder: Builder) => void;
export declare function loadStdAddress(slice: Slice): {
    $$type: "StdAddress";
    workchain: bigint;
    address: bigint;
};
export type VarAddress = {
    $$type: 'VarAddress';
    workchain: bigint;
    address: Slice;
};
export declare function storeVarAddress(src: VarAddress): (builder: Builder) => void;
export declare function loadVarAddress(slice: Slice): {
    $$type: "VarAddress";
    workchain: bigint;
    address: Slice;
};
export type Context = {
    $$type: 'Context';
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export declare function storeContext(src: Context): (builder: Builder) => void;
export declare function loadContext(slice: Slice): {
    $$type: "Context";
    bounced: boolean;
    sender: Address;
    value: bigint;
    raw: Slice;
};
export type SendParameters = {
    $$type: 'SendParameters';
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export declare function storeSendParameters(src: SendParameters): (builder: Builder) => void;
export declare function loadSendParameters(slice: Slice): {
    $$type: "SendParameters";
    bounce: boolean;
    to: Address;
    value: bigint;
    mode: bigint;
    body: Cell | null;
    code: Cell | null;
    data: Cell | null;
};
export type ChangeOwner = {
    $$type: 'ChangeOwner';
    queryId: bigint;
    newOwner: Address;
};
export declare function storeChangeOwner(src: ChangeOwner): (builder: Builder) => void;
export declare function loadChangeOwner(slice: Slice): {
    $$type: "ChangeOwner";
    queryId: bigint;
    newOwner: Address;
};
export type ChangeOwnerOk = {
    $$type: 'ChangeOwnerOk';
    queryId: bigint;
    newOwner: Address;
};
export declare function storeChangeOwnerOk(src: ChangeOwnerOk): (builder: Builder) => void;
export declare function loadChangeOwnerOk(slice: Slice): {
    $$type: "ChangeOwnerOk";
    queryId: bigint;
    newOwner: Address;
};
export type DNSResolveResult = {
    $$type: 'DNSResolveResult';
    prefix: bigint;
    record: Cell | null;
};
export declare function storeDNSResolveResult(src: DNSResolveResult): (builder: Builder) => void;
export declare function loadDNSResolveResult(slice: Slice): {
    $$type: "DNSResolveResult";
    prefix: bigint;
    record: Cell | null;
};
export type SpanishInquisition = {
    $$type: 'SpanishInquisition';
};
export declare function storeSpanishInquisition(src: SpanishInquisition): (builder: Builder) => void;
export declare function loadSpanishInquisition(slice: Slice): {
    $$type: "SpanishInquisition";
};
export type ReservedContractErrorsTester$Data = {
    $$type: 'ReservedContractErrorsTester$Data';
    owner: Address;
};
export declare function storeReservedContractErrorsTester$Data(src: ReservedContractErrorsTester$Data): (builder: Builder) => void;
export declare function loadReservedContractErrorsTester$Data(slice: Slice): {
    $$type: "ReservedContractErrorsTester$Data";
    owner: Address;
};
export declare const ReservedContractErrorsTester_getterMapping: {
    [key: string]: string;
};
export declare class ReservedContractErrorsTester implements Contract {
    static init(): Promise<{
        code: Cell;
        data: Cell;
    }>;
    static fromInit(): Promise<ReservedContractErrorsTester>;
    static fromAddress(address: Address): ReservedContractErrorsTester;
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    };
    readonly abi: ContractABI;
    private constructor();
    send(provider: ContractProvider, via: Sender, args: {
        value: bigint;
        bounce?: boolean | null | undefined;
    }, message: null | "128" | "130" | "132" | "134"): Promise<void>;
    getOwner(provider: ContractProvider): Promise<Address>;
}

            };
/// <amd-module name="tact-compiler/test/util.d.ts" /> 
 declare module "tact-compiler/test/util.d.ts" {
                export declare const CONTRACTS_DIR: string;
export declare function trimTrailingCR(input: string): string;

            };
/// <amd-module name="tact-compiler/test/utils/randomAddress.d.ts" /> 
 declare module "tact-compiler/test/utils/randomAddress.d.ts" {
                import { Address } from "@ijstech/ton-core";
export declare function randomAddress(workchain: number, seed: string): Address;

            };
/// <amd-module name="tact-compiler/types/getSupportedInterfaces.d.ts" /> 
 declare module "tact-compiler/types/getSupportedInterfaces.d.ts" {
                import { CompilerContext } from "../context/context";
import { TypeDescription } from "./types";
export declare function getSupportedInterfaces(type: TypeDescription, ctx: CompilerContext): string[];

            };
/// <amd-module name="tact-compiler/types/isRuntimeType.d.ts" /> 
 declare module "tact-compiler/types/isRuntimeType.d.ts" {
                import { TypeRef } from "./types";
export declare function isRuntimeType(src: TypeRef): boolean;

            };
/// <amd-module name="tact-compiler/types/resolveABITypeRef.d.ts" /> 
 declare module "tact-compiler/types/resolveABITypeRef.d.ts" {
                import { ABITypeRef } from "@ijstech/ton-core";
import { AstFieldDecl } from "../ast/ast";
import { TypeRef } from "./types";
import { CompilerContext } from "../context/context";
import { SrcInfo } from "../grammar";
type FormatDef = Record<string, {
    type: string;
    format: string | number;
} | undefined>;
export declare const intMapKeyFormats: FormatDef;
export declare const intMapValFormats: FormatDef;
export declare function resolveABIType(src: AstFieldDecl): ABITypeRef;
export declare function createABITypeRefFromTypeRef(ctx: CompilerContext, src: TypeRef, loc: SrcInfo): ABITypeRef;
export {};

            };
/// <amd-module name="tact-compiler/types/resolveDescriptors.d.ts" /> 
 declare module "tact-compiler/types/resolveDescriptors.d.ts" {
                import { AstId, AstType, AstTypeId, FactoryAst } from "../ast/ast";
import { CompilerContext } from "../context/context";
import { ConstantDescription, FunctionDescription, TypeDescription, TypeRef } from "./types";
export declare const toBounced: (type: string) => string;
export declare function resolveTypeRef(ctx: CompilerContext, type: AstType): TypeRef;
export declare function resolveDescriptors(ctx: CompilerContext, Ast: FactoryAst): CompilerContext;
export declare function getType(ctx: CompilerContext, ident: AstId | AstTypeId | string): TypeDescription;
export declare function getAllTypes(ctx: CompilerContext): TypeDescription[];
export declare function getContracts(ctx: CompilerContext): string[];
export declare function getStaticFunction(ctx: CompilerContext, name: string): FunctionDescription;
export declare function hasStaticFunction(ctx: CompilerContext, name: string): boolean;
export declare function getStaticConstant(ctx: CompilerContext, name: string): ConstantDescription;
export declare function hasStaticConstant(ctx: CompilerContext, name: string): boolean;
export declare function getAllStaticFunctions(ctx: CompilerContext): FunctionDescription[];
export declare function getAllStaticConstants(ctx: CompilerContext): ConstantDescription[];

            };
/// <amd-module name="tact-compiler/types/resolveErrors.d.ts" /> 
 declare module "tact-compiler/types/resolveErrors.d.ts" {
                import { CompilerContext } from "../context/context";
import { FactoryAst } from "../ast/ast";
type Exception = {
    value: string;
    id: number;
};
export declare function resolveErrors(ctx: CompilerContext, Ast: FactoryAst): CompilerContext;
export declare function getAllErrors(ctx: CompilerContext): Exception[];
export declare function getErrorId(value: string, ctx: CompilerContext): number;
export {};

            };
/// <amd-module name="tact-compiler/types/resolveExpression.d.ts" /> 
 declare module "tact-compiler/types/resolveExpression.d.ts" {
                import { AstExpression } from "../ast/ast";
import { CompilerContext } from "../context/context";
import { TypeRef } from "./types";
import { StatementContext } from "./resolveStatements";
export declare function getExpType(ctx: CompilerContext, exp: AstExpression): TypeRef;
export declare function resolveExpression(exp: AstExpression, sctx: StatementContext, ctx: CompilerContext): CompilerContext;
export declare function getAllExpressionTypes(ctx: CompilerContext): [string, string][];

            };
/// <amd-module name="tact-compiler/types/resolveSignatures.d.ts" /> 
 declare module "tact-compiler/types/resolveSignatures.d.ts" {
                import { CompilerContext } from "../context/context";
import { FactoryAst } from "../ast/ast";
export declare function resolveSignatures(ctx: CompilerContext, Ast: FactoryAst): CompilerContext;

            };
/// <amd-module name="tact-compiler/types/resolveStatements.d.ts" /> 
 declare module "tact-compiler/types/resolveStatements.d.ts" {
                import { CompilerContext } from "../context/context";
import { AstId, FactoryAst } from "../ast/ast";
import { TypeRef } from "./types";
import { SrcInfo } from "../grammar";
export type StatementContext = {
    root: SrcInfo;
    funName: string | null;
    returns: TypeRef;
    vars: Map<string, TypeRef>;
    requiredFields: string[];
};
export declare function emptyContext(root: SrcInfo, funName: string | null, returns: TypeRef): StatementContext;
export declare function isLvalue(path: AstId[], ctx: CompilerContext): boolean;
export declare function resolveStatements(ctx: CompilerContext, Ast: FactoryAst): CompilerContext;

            };
/// <amd-module name="tact-compiler/types/subtyping.d.ts" /> 
 declare module "tact-compiler/types/subtyping.d.ts" {
                import { TypeRef } from "./types";
export declare function isAssignable(src: TypeRef, to: TypeRef): boolean;
export declare function moreGeneralType(type1: TypeRef, type2: TypeRef): TypeRef | null;

            };
/// <amd-module name="tact-compiler/types/types.d.ts" /> 
 declare module "tact-compiler/types/types.d.ts" {
                import { ABIField } from "@ijstech/ton-core";
import { AstConstantDef, AstFunctionDef, AstContractInit, AstNativeFunctionDecl, AstReceiver, AstTypeDecl, AstId, AstFunctionDecl, AstConstantDecl, AstFieldDecl, AstAsmFunctionDef, AstNumber, AstLiteral } from "../ast/ast";
import { ItemOrigin, SrcInfo } from "../grammar";
export type TypeDescription = {
    kind: "struct" | "primitive_type_decl" | "contract" | "trait";
    origin: ItemOrigin;
    name: string;
    uid: number;
    header: AstNumber | null;
    tlb: string | null;
    signature: string | null;
    fields: FieldDescription[];
    partialFieldCount: number;
    traits: TypeDescription[];
    functions: Map<string, FunctionDescription>;
    receivers: ReceiverDescription[];
    init: InitDescription | null;
    ast: AstTypeDecl;
    dependsOn: TypeDescription[];
    interfaces: string[];
    constants: ConstantDescription[];
};
export type TypeRef = {
    kind: "ref";
    name: string;
    optional: boolean;
} | {
    kind: "map";
    key: string;
    keyAs: string | null;
    value: string;
    valueAs: string | null;
} | {
    kind: "ref_bounced";
    name: string;
} | {
    kind: "void";
} | {
    kind: "null";
};
export declare function showValue(val: AstLiteral): string;
export type FieldDescription = {
    name: string;
    index: number;
    type: TypeRef;
    as: string | null;
    default: AstLiteral | undefined;
    loc: SrcInfo;
    ast: AstFieldDecl;
    abi: ABIField;
};
export type ConstantDescription = {
    name: string;
    type: TypeRef;
    value: AstLiteral | undefined;
    loc: SrcInfo;
    ast: AstConstantDef | AstConstantDecl;
};
export type FunctionParameter = {
    name: AstId;
    type: TypeRef;
    loc: SrcInfo;
};
export type InitParameter = {
    name: AstId;
    type: TypeRef;
    as: string | null;
    loc: SrcInfo;
};
export type FunctionDescription = {
    name: string;
    origin: ItemOrigin;
    isGetter: boolean;
    methodId: number | null;
    isMutating: boolean;
    isOverride: boolean;
    isVirtual: boolean;
    isAbstract: boolean;
    isInline: boolean;
    self: TypeRef | null;
    returns: TypeRef;
    params: FunctionParameter[];
    ast: AstFunctionDef | AstNativeFunctionDecl | AstFunctionDecl | AstAsmFunctionDef;
};
export type BinaryReceiverSelector = {
    kind: "internal-binary";
    type: string;
    name: AstId;
} | {
    kind: "bounce-binary";
    name: AstId;
    type: string;
    bounced: boolean;
} | {
    kind: "external-binary";
    type: string;
    name: AstId;
};
export type CommentReceiverSelector = {
    kind: "internal-comment";
    comment: string;
} | {
    kind: "external-comment";
    comment: string;
};
type EmptyReceiverSelector = {
    kind: "internal-empty";
} | {
    kind: "external-empty";
};
type FallbackReceiverSelector = {
    kind: "internal-comment-fallback";
    name: AstId;
} | {
    kind: "internal-fallback";
    name: AstId;
} | {
    kind: "bounce-fallback";
    name: AstId;
} | {
    kind: "external-comment-fallback";
    name: AstId;
} | {
    kind: "external-fallback";
    name: AstId;
};
export type ReceiverSelector = BinaryReceiverSelector | CommentReceiverSelector | EmptyReceiverSelector | FallbackReceiverSelector;
export declare function receiverSelectorName(selector: ReceiverSelector): string;
export type ReceiverDescription = {
    selector: ReceiverSelector;
    ast: AstReceiver;
};
export type InitDescription = {
    params: InitParameter[];
    ast: AstContractInit;
};
export declare function printTypeRef(src: TypeRef): string;
export declare function typeRefEquals(a: TypeRef, b: TypeRef): boolean;
export {};

            };
/// <amd-module name="tact-compiler/utils/array.d.ts" /> 
 declare module "tact-compiler/utils/array.d.ts" {
                export declare const isUndefined: <T>(t: T | undefined) => t is undefined;
export declare const groupBy: <T, U>(items: readonly T[], f: (t: T) => U) => readonly (readonly T[])[];
export declare const intercalate: <T>(items: readonly (readonly T[])[], value: T) => readonly T[];

            };
/// <amd-module name="tact-compiler/utils/calculateIPFSlink.d.ts" /> 
 declare module "tact-compiler/utils/calculateIPFSlink.d.ts" {
                export declare function calculateIPFSlink(data: Buffer): Promise<string>;

            };
/// <amd-module name="tact-compiler/utils/crc16.d.ts" /> 
 declare module "tact-compiler/utils/crc16.d.ts" {
                export declare function crc16(data: string | Buffer): number;

            };
/// <amd-module name="tact-compiler/utils/filePath.d.ts" /> 
 declare module "tact-compiler/utils/filePath.d.ts" {
                export declare function posixNormalize(path: string): string;

            };
/// <amd-module name="tact-compiler/utils/idToHex.d.ts" /> 
 declare module "tact-compiler/utils/idToHex.d.ts" {
                export declare function idToHex(id: number): string;

            };
/// <amd-module name="tact-compiler/utils/isSubsetOf.d.ts" /> 
 declare module "tact-compiler/utils/isSubsetOf.d.ts" {
                /** Taken from TypeScript collection lib to perfectly match the .isSubsetOf signature */
export interface ReadonlySetLike<T> {
    /**
     * Despite its name, returns an iterator of the values in the set-like.
     */
    keys(): Iterator<T>;
    /**
     * @returns a boolean indicating whether an element with the specified value exists in the set-like or not.
     */
    has(value: T): boolean;
    /**
     * @returns the number of (unique) elements in the set-like.
     */
    readonly size: number;
}
/**
 * @returns a boolean indicating whether all the elements in Set `one` are also in the `other`.
 */
export declare function isSubsetOf<T>(one: Set<T>, other: ReadonlySetLike<unknown>): boolean;

            };
/// <amd-module name="tact-compiler/utils/loadCases.d.ts" /> 
 declare module "tact-compiler/utils/loadCases.d.ts" {
                export declare function loadCases(src: string): {
    name: string;
    code: string;
}[];

            };
/// <amd-module name="tact-compiler/utils/testKey.d.ts" /> 
 declare module "tact-compiler/utils/testKey.d.ts" {
                export declare function testKey(seed: string): import("@ton/crypto").KeyPair;

            };
/// <amd-module name="tact-compiler/utils/text.d.ts" /> 
 declare module "tact-compiler/utils/text.d.ts" {
                export declare function isBlank(src: string): boolean;
export declare function trimIndent(src: string): string;
/**
 * Escapes unicode control codes in the [src] string
 * See: https://en.m.wikipedia.org/wiki/List_of_Unicode_characters#Control_codes
 */
export declare function escapeUnicodeControlCodes(src: string): string;

            };
/// <amd-module name="tact-compiler/utils/tricks.d.ts" /> 
 declare module "tact-compiler/utils/tricks.d.ts" {
                type Extend<T extends any[], H> = H extends infer A ? [...T, A] : never;
type Flat<TS extends any[], R extends any[] = []> = TS extends [
    infer H,
    ...infer T
] ? Flat<T, Extend<R, H>> : R;
declare const NoSuchCase: unique symbol;
interface NoSuchCaseBug<L> extends Array<never> {
    [NoSuchCase]: L;
}
type On<I extends any[], O> = {
    on: <const DI extends any[]>(...key: I extends Flat<DI> ? DI : NoSuchCaseBug<DI>) => <const DO>(handler: (...args: Extract<I, Flat<DI>>) => DO) => MV<Exclude<I, Flat<DI>>, O | DO>;
};
declare const CasesAreNotExhaustive: unique symbol;
interface NonExhaustiveBug<L> {
    [CasesAreNotExhaustive]: L;
}
type End<I extends any[], O> = [I] extends [never] ? EndInternal<I, O> : {
    otherwise: <const DO>(handle: (...input: I) => DO) => O | DO;
    end: NonExhaustiveBug<I>;
};
type MV<I extends any[], O> = End<I, O> & On<I, O>;
type EndInternal<I extends any[], O> = {
    otherwise: <const DO>(handle: (...input: I) => DO) => O | DO;
    end: () => O;
};
export declare const match: <const I extends any[]>(...args: I) => MV<Flat<I>, never>;
/**
 * Convert union to intersection. See https://stackoverflow.com/q/50374908
 */
type Intersect<T> = (T extends unknown ? (x: T) => 0 : never) extends (x: infer R) => 0 ? R : never;
/**
 * Makes types more readable
 * Example: Unwrap<{ a: 1 } & { b: 2 }> = { a: 1, b: 2 }
 */
type Unwrap<T> = T extends infer R ? {
    [K in keyof R]: R[K];
} : never;
type Inputs<I, T extends string> = I extends {
    [Z in T]: infer K;
} ? K extends string ? Record<K, (input: I) => unknown> : never : never;
type Outputs<O> = {
    [K in keyof O]: (input: never) => O[K];
};
type Handlers<I, O, T extends string> = Unwrap<Intersect<Inputs<I, T>>> & Outputs<O>;
export declare const makeMakeVisitor: <T extends string>(tag: T) => <I>() => <O>(handlers: Handlers<I, O, T>) => (input: Extract<I, { [K in T]: string; }>) => O[keyof O];
/**
 * Make visitor for disjoint union (tagged union, discriminated union)
 */
export declare const makeVisitor: <I>() => <O>(handlers: Handlers<I, O, "kind">) => (input: Extract<I, {
    kind: string;
}>) => O[keyof O];
export {};

            };
/// <amd-module name="tact-compiler/utils/utils.d.ts" /> 
 declare module "tact-compiler/utils/utils.d.ts" {
                export declare function topologicalSort<T>(src: T[], references: (src: T) => T[]): T[];

            };
/// <amd-module name="tact-compiler/utils/Writer.d.ts" /> 
 declare module "tact-compiler/utils/Writer.d.ts" {
                export declare class Writer {
    private indent;
    private lines;
    inIndent: (handler: () => void) => void;
    append(src?: string): void;
    write(src: string): void;
    end(): string;
}

            };
/// <amd-module name="tact-compiler/vfs/createNodeFileSystem.d.ts" /> 
 declare module "tact-compiler/vfs/createNodeFileSystem.d.ts" {
                import { VirtualFileSystem } from "./VirtualFileSystem";
export declare function createNodeFileSystem(root: string, readonly?: boolean): VirtualFileSystem;

            };
/// <amd-module name="tact-compiler/vfs/createVirtualFileSystem.d.ts" /> 
 declare module "tact-compiler/vfs/createVirtualFileSystem.d.ts" {
                import { VirtualFileSystem } from "./VirtualFileSystem";
export declare function createVirtualFileSystem(root: string, fs: Record<string, string>, readonly?: boolean): VirtualFileSystem;

            };
/// <amd-module name="tact-compiler/vfs/VirtualFileSystem.d.ts" /> 
 declare module "tact-compiler/vfs/VirtualFileSystem.d.ts" {
                export type VirtualFileSystem = {
    root: string;
    resolve(...path: string[]): string;
    exists(path: string): boolean;
    readFile(path: string): Buffer;
    writeFile(path: string, content: Buffer | string): void;
};

            };

                export { enableFeatures, build } from "./pipeline/build";
export { precompile } from "./pipeline/precompile";
export { TactError, TactCompilationError, TactInternalCompilerError, TactConstEvalError, TactErrorCollection, } from "./error/errors";
export { optionsSchema, projectSchema, configSchema, } from "./config/parseConfig";
export { AstSorter } from "./ast/sort";
export { AstRenamer } from "./ast/rename";
export { AstHasher } from "./ast/hash";
export { AstComparator } from "./ast/compare";
export { Config, ConfigProject, parseConfig, verifyConfig, } from "./config/parseConfig";
export { PackageFileFormat } from "./packaging/fileFormat";
export { VirtualFileSystem } from "./vfs/VirtualFileSystem";
export { createVirtualFileSystem } from "./vfs/createVirtualFileSystem";
export * from "./browser";
export * from "./context/logger";
export * from "./error/errors";

            };
 export = TactCompiler;